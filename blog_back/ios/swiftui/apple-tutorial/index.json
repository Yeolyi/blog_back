{"pathArr":[],"metaData":{"title":"애플 공식 튜토리얼"},"content":"\n[iOS App Dev Tutorials](https://developer.apple.com/tutorials/app-dev-training)를참고했다. 애플 홈페이지에서는 못찾았는데 uikit tutorial이라고 구글에 검색하니 떴다.\n\n---\n\nSwift에서 클로저를 많이 쓸테니 잘 보라는 말이 인상깊다.\n\n> SwiftUI is a declarative framework for building apps for any Apple platform.\n\n선언적 프로그래밍이 뭐지?\n\n> In computer science, **declarative programming** is a programming paradigm—a style of building the structure and elements of computer programs—that expresses the logic of a computation without describing its control flow.\n\n## 주요 SwiftUI 기능\n\n- 선언적 구문\n- Compositional API - 빌트인된 뷰와 변경자로 UI를 빠르게 만들기. 구성적이라는 말은 객체지향에서 나온것 같은데 한 클래스가 다른 클래스를 포함하는 상속과 같은개념이라고 한다. 나중에 또 찾아보자.\n- 강력한 레이아웃 시스템\n- 뷰가 앱 데이터를 반영함 - 데이터 의존성을 정의하면 데이터의 변화에 따라 자동으로 뷰를 업데이트.\n- 자동으로 접근성 지원\n\n## Using Stacks to Arrange Views\n\nYou build a complex view by composing it of small, simple views. Stacks group views horizontally, vertically, or back to front. The system treats SFSymbols like fonts, so they scale dynamically with a user’s device settings. Some systems use left and right alignment. SwiftUI uses leading and trailing alignment to ease the localization of your app. To customize a SwiftUI view, you call methods known as **modifiers**. Each modifier returns a new view. You can use multiple modifiers on a single view. To chain modifiers, stack them vertically. strokeBorder modifier 해석이 안된다 ㅋㅋㅋ accessibility label은 왜 text를 패러미터로 받지?\n\n```swift\nButton(action: {}) {\n    Image(systemName: \"forward.fill\")\n}\n.accessibilityLabel(Text(\"Next speaker\"))\n```\n\nVoiceOver reads the label “Next speaker,” followed by the inherent accessibility trait “Button.”\n\n![](quiz_voiceover.png)\n\n## Creating a CardView\n\n> The DailyScrum model will contain the following four properties, all with simple value types: title, attendees, lengthInMinutes, and color. Because DailyScrum will primarily carry value data, you’ll make it a value type by declaring it as a struct.\n\n오홍 모델을 이렇게 만드는구나.\n\n왜 테스트 데이터를 computed property으로 선언했을까? [When should you use a computed property or a stored property?](https://www.hackingwithswift.com/quick-start/understanding-swift/when-should-you-use-a-computed-property-or-a-stored-property) 자주 사용하지 않는 값이어서 그런듯,,,? static인건 struct 타입에 속하는건 맞으니까,,?\n\n.previewLayout(.fixed(width: 400, height: 60)) 이건 잘 안써봤네!\n\n오 샘플 코드에 배경 따라 텍스트 색 선택하는 코드가 있네. 유용할듯!\n\nVStack은 다음과 같이 선언되어있다.\n\n```swift\n@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)\n@frozen public struct VStack<Content> : View where Content : View {\n\n    /// Creates an instance with the given spacing and horizontal alignment.\n    ///\n    /// - Parameters:\n    ///   - alignment: The guide for aligning the subviews in this stack. This\n    ///     guide has the same vertical screen coordinate for every child view.\n    ///   - spacing: The distance between adjacent subviews, or `nil` if you\n    ///     want the stack to choose a default distance for each pair of\n    ///     subviews.\n    ///   - content: A view builder that creates the content of this stack.\n    @inlinable public init(alignment: HorizontalAlignment = .center, spacing: CGFloat? = nil, @ViewBuilder content: () -> Content)\n\n    /// The type of view representing the body of this view.\n    ///\n    /// When you create a custom view, Swift infers this type from your\n    /// implementation of the required ``View/body-swift.property`` property.\n    public typealias Body = Never\n}\n```\n\nresultBuilder는 또 뭐지? [링크](https://www.swiftbysundell.com/articles/deep-dive-into-swift-function-builders/)도나중에 정리해보자.\n\nSF Symbols used in labels and images scale and align appropriately with changes in font weight and size.\n\n## Displaying Data in a List\n\nThe List initializer in this step accepts a **ViewBuilder** as its only parameter. So, you can add rows with the same syntax you’ve been using with other container views such as HStack and VStack.\n\nList에 대한 문서 읽어보기. 거기에 init에 대해서도 나와있음. Never 키워드는 뭐였더라,,,?\n\n[What is the difference between List and ForEach in SwiftUI?](https://stackoverflow.com/questions/56535326/what-is-the-difference-between-list-and-foreach-in-swiftui)\n\nYou create a SwiftUI app by declaring a structure that conforms to the App protocol. The app’s body property returns a Scene that contains a view hierarchy representing the primary user interface for the app.\n\nWindowGroup is one of the primitive scenes that SwiftUI provides. On iOS, the views you add to the WindowGroup scene builder are presented in a window that fills the device’s entire screen.\n\n![](quiz_foreach.png) viewbuilder는 return이 필요없는듯.\n\n## Creating a Navigation Hierarchy\n\npush the timer view to the top of the navigation stack. 스택으로 작동하는 것 같은데, 이것도 알아보자 .\n\nNotice that you add the .navigationTitle modifier to the List. The child view can affect the appearance of the NavigationView using modifiers.\n\n그나저나 스크럼에 대해서도 찾아보자\n\nnavigationBarItems(leading:trailing:). Deprecated. Use toolbar(content:) with navigationBarLeading or navigationBarTrailing placement.\n\n```swift\n.toolbar {\n    ToolbarItem(placement: .navigationBarTrailing) {\n        Button(action: {}) {\n            Image(systemName: \"plus\")\n        }\n    }\n}\n```\n\nThe compiler error is resolved with the update to the call. 콜이 업데이트됐다는게 뭘까?\n\nSections create visual distinctions within your list. They help you to chunk content and establish groups in the information hierarchy of the list view.\n\n왜 list style에는 built-in static var이 있고 타입도 있을까? [How to change ListStyle in List](https://stackoverflow.com/questions/56474019/how-to-change-liststyle-in-list)\n\nSwiftUI automatically includes the animations when pushing and popping from the navigation stack.\n\nNavigationView is a container view that presents a stack of views in a navigation hierarchy.\n\nNavigation modifiers, such as title and bar items, are added to child views and propagated to the parent NavigationView.\n\n## Creating the Edit View\n\nAs the user edits, the view stores the scrum values in a Data property. If the user confirms the change, the view updates DailyScrum using the contents of Data.\n\n이런 방법으로 수정/적용할 수도 있구나~!\n\nSwiftUI observes @State properties and automatically redraws the view’s body when the property changes. This behavior ensures the UI stays up to date as the user manipulates the onscreen controls.\n\nEach piece of data that you use in your view hierarchy should have a single source of truth. You can use the @State property wrapper to define the source of truth for value types.\n\nDeclare @State properties as private so they can be accessed only within the view in which you define them.\n\nTextField takes a binding to a String. A binding is a reference to a state that is owned by another view.\n\n```swift\nSlider(value: $scrumData.lengthInMinutes, in: 5...30, step: 1.0) {\n    Text(\"Length\")\n}\n```\n\nThe Text view won’t appear on screen, but VoiceOver uses it to identify the purpose of the slider.\n\n```swift\nColorPicker(\"Color\", selection: $scrumData.color)\n    .accessibilityValue(Text(\"Color picker\"))\n```\n\nThe color picker has the “button” accessibility trait, so don’t include the word “button” in the label.\n\nfullScreenCover 속 버튼이 뷰의 state를 건들이는데 왜 escaping closure가 아닌지궁금했다. outlive가 아니라서 그런듯??\n\nThe method remove(atOffsets:) uses the **IndexSet** to remove elements from the array.\n\n## Passing Data with Bindings\n\nYou should maintain a single source of truth for every piece of data in your app and use bindings to share a reference to that source of truth. The edit screen should act on data that the detail screen owns, instead of creating a new source of truth.\n\nYou can use the constant(\\_:) type method to create a binding to a hard-coded, immutable value. Constant bindings are useful in previews or when you’re prototyping your app’s UI.\n\n그.. 여기 방식이 좋은건가? edit이랑 상관없는 뷰에 순전히 edit을 위한 변수가 있는게 맞는걸까?? 그리고이럴거면 왜 binding을 해 그냥 값으로 넘겨줘도 되지. 아 굳이 edit에 모델을 통으로 넣지 않기 위해 이러는건가?!?! edit 뷰를 부모 뷰에서 많이 정의하는 것이 인상깊다.\n\n```swift\nButton(\"Edit\") {\n    isPresented = true\n    data = scrum.data\n}\n```\n\n이게 되는거보면 순서는 클로저 내에서 상관없는듯??\n\n```swift\nprivate func binding(for scrum: DailyScrum) -> Binding<DailyScrum> {\n        guard let scrumIndex = scrums.firstIndex(where: { $0.id == scrum.id }) else {\n            fatalError(\"Can't find scrum in array\")\n        }\n        return $scrums[scrumIndex]\n    }\n```\n\n이런걸 만들어쓰네,,,! Using the utility method to create the binding keeps the DetailView initializer concise.\n\nbinding에 대해서. 달러 표시는 왜 나오는걸까? [애플 공식 문서](https://developer.apple.com/documentation/swiftui/binding)에 따르면\n\n> Applying the $ prefix to a property wrapped value returns its projectedValue, which for a state property wrapper returns a binding to the value.\n\nprojectedValue란 A binding to the state value.\n\n> In addition to the wrapped value, a property wrapper can expose additional functionality by defining a projected value—for example, a property wrapper that manages access to a database can expose a flushDatabaseConnection() method on its projected value. The name of the projected value is the same as the wrapped value, except it begins with a dollar sign ($). Because your code can’t define properties that start with $ the projected value never interferes with properties you define.\n\n@State가 아니면 Cannot find '$scrums' in scope이라고 뜸. projectedValue가 없어서그럴까?\n\n```swift\nstruct Book {\n    var title: String\n    var identifier: Int\n}\n\n@State private var book = Book(title: \"The Adventures of Smudge\", identifier: 19237)\n\n// $book.identifier는 Binding<Int>\n```\n\n## Managing State and Life Cycle\n\nZStack overlays views back to front\n\n.previewLayout(.sizeThatFits)\n\n```swift\nprivate var minutesRemaining: Int {\n    secondsRemaining / 60\n}\nprivate var minutesRemainingMetric: String {\n    minutesRemaining == 1 ? \"minute\" : \"minutes\"\n}\n```\n\n아니 이러면 1분 미만이면 어떡하게???\n\n```swift\nstruct ScrumProgressViewStyle: ProgressViewStyle {\n    var scrumColor: Color\n\n    func makeBody(configuration: Configuration) -> some View {\n        ZStack {\n            RoundedRectangle(cornerRadius: 10.0)\n                .fill(scrumColor.accessibleFontColor)\n                .frame(height: 20.0)\n            ProgressView(configuration)\n                .frame(height: 12.0)\n                .padding(.horizontal)\n        }\n    }\n}\n```\n\n오 스타일을 이렇게 만드는구나.\n\nYou’ve used @State to create a source of truth for value type models. You can use @StateObject to create a source of truth for reference type models that conform to the ObservableObject protocol.\n\nObservedObject의 문제점이 뭐였더라,,, [링크](https://nalexn.github.io/swiftui-observableobject/)\n\n```swift\ntimer = Timer.scheduledTimer(withTimeInterval: frequency, repeats: true) { [weak self] timer in\n    if let self = self, let startDate = self.startDate {\n        let secondsElapsed = Date().timeIntervalSince1970 - startDate.timeIntervalSince1970\n        self.update(secondsElapsed: Int(secondsElapsed))\n    }\n}\n```\n\n왜 weak self를 썼는지도 알아보자,,, [클로저](https://seolhee2750.tistory.com/117)도 공부하기!!\n\nSwiftUI provides life cycle methods to trigger events when a view appears and disappears.\n\nThe timer stops each time an **instance of MeetingView** leaves the screen, indicating that a meeting has ended.\n\n오 dropLast 메소드 기억해두기!\n\n타이머에서 스킵이 즉 scrumTimer에서의 스킵이지만 논리 분리?를 위해 패러미터로 따로 받는 것 인상깊음.\n\n## Updating App Data\n\n## Persisting Data\n\nIn this tutorial, you’ll update Scrumdinger to support persistence, an essential feature of most apps. You’ll add Codable conformance for the app’s models and write methods to load and save scrums.\n\nCodable is a type alias that combines the Encodable and Decodable protocols. When you implement these protocols on your types, you can use the Codable API to easily serialize data to and from JSON.\n\nColor 구조체 Codable하게 만드는 코드가 있음!\n\nAn ObservableObject includes an objectWillChange publisher that emits when one of its @Published properties is about to change. Any view observing an instance of ScrumData will re-render when the scrums value changes. Observe라는게 특별한뜻이 또 있는거 아닐까?!\n\nDispatch queues are first in, first out (FIFO) queues to which your application can submit tasks. Background tasks have the lowest priority of all tasks.\n\nSelf vs self\n\nFileManager, DispatchQueue... JSONDecoder...\n\n```swift\nimport Foundation\n\nclass ScrumData: ObservableObject {\n    private static var documentsFolder: URL {\n        do {\n            return try FileManager.default.url(for: .documentDirectory,\n                                               in: .userDomainMask,\n                                               appropriateFor: nil,\n                                               create: false)\n        } catch {\n            fatalError(\"Can't find documents directory.\")\n        }\n    }\n    private static var fileURL: URL {\n        return documentsFolder.appendingPathComponent(\"scrums.data\")\n    }\n    @Published var scrums: [DailyScrum] = []\n    \n    func load() {\n        DispatchQueue.global(qos: .background).async { [weak self] in\n            guard let data = try? Data(contentsOf: Self.fileURL) else {\n                #if DEBUG\n                DispatchQueue.main.async {\n                    self?.scrums = DailyScrum.data\n                }\n                #endif\n                return\n            }\n            guard let dailyScrums = try? JSONDecoder().decode([DailyScrum].self, from: data) else {\n                fatalError(\"Can't decode saved scrum data.\")\n            }\n            DispatchQueue.main.async {\n                self?.scrums = dailyScrums\n            }\n        }\n    }\n    func save() {\n        DispatchQueue.global(qos: .background).async { [weak self] in\n            guard let scrums = self?.scrums else { fatalError(\"Self out of scope\") }\n            guard let data = try? JSONEncoder().encode(scrums) else { fatalError(\"Error encoding data\") }\n            do {\n                let outfile = Self.fileURL\n                try data.write(to: outfile)\n            } catch {\n                fatalError(\"Can't write to file\")\n            }\n        }\n    }\n}\n```\n\n여기 분석할 것들이 한가득\n\nIn ScrumsView.swift, add an @Environment property for the scenePhase value. You’ll observe this value and save user data when it becomes inactive.\n\n## Drawing the Timer View\n","path":"ios/swiftui/apple-tutorial/index.md"}