{"pathArr":[],"metaData":{"title":"자바"},"content":"\n## 자바의 정석\n\n출처: Java의 정석 3rd Edition, 남궁성\n\n### 1. 자바를 시작하기 전에\n\n자바의 가장 중요한 특징은 OS 독립적이라는 것이다.\n\n자바의 연산자와 기본 구문은 C++에서, 객체지향관련 구문은 스몰토크에서 가져왔다.\n\n인터넷과 대규모 분산 환경을 염두에 두어 다양한 네트워크 API가 존재한다.\n\n멀티쓰레드를 기본으로 지원한다. 스케줄링은 자바 인터프리터가 담당한다.\n\n자바는 동적 로딩을 지원하여 필요한 시점에 클래스가 로딩되고 애플리케이션을 일부만 컴파일할 수 있다. JIT?\n\n```java\nimport java.util.Calendar;\n\npublic class Start {\n\n  public static void main(String[] args) {\n    System.out.println(\"Hello, world!\");\n  }\n}\n```\n\n자바 컴파일러(javac)로 클래스 파일(\\*.class) 생성 후 자바 인터프리터(java)로 실행.\n\n자바의 모든 코드는 반드시 클래스 안에 존재한다. 하나의 소스 파일에는 최대 하나의 public class가 존재 할 수 있다. \\*.class는 클래스 당 하나씩 만들어진다.\n\n### 2. 변수(variable)\n\n> 변수란 단 하나의 값을 저장할 수 있는 메모리 공간이다.\n\n기본형과 참조형으로 나뉘는데 C와 달리 참조형 변수간의 연산을 할 수는 없다? 아 배열에서 포인터 뺄셈등?\n\n기본형: boolean, char, byte, short, int, long, float, double\n\n> The size of an int in Java is completely independent of the 32-bitness or 64-bitness of a JDK. It is always 4 bytes = 32 bits = −2,147,483,648 to 2,147,483,647. https://stackoverflow.com/questions/17553183/integer-range-when-using-64bit-jdk\n\n```java\nfinal int MAX_SPEED = 10;\n```\n\n[Java에서의 Emoji처리에 대해](https://meetup.toast.com/posts/317)\n\n덧셈 연산자는 피연산자 중 어느 하나가 String이면 나머지를 문자열로 변환해서 결합 .\n\n```java\nSystem.out.println(true + \"\");\n```\n\n```java\nimport java.util.*;\n\npublic class ScannerEx {\n\n  public static void main(String[] args) {\n    Scanner scanner = new Scanner(System.in);\n    // Resource leak: 'scanner' is never closed\n    String input = scanner.nextLine();\n    int num = Integer.parseInt(input);\n    System.out.print(num);\n  }\n}\n```\n\nchar에 -1은 int값이라고 대입 못함.\n\n한글 표현 방식에는 확장형과 조합형이 있는데 후자는 사용되지 않고 완성형인 KSC 5601에 없는 글자를 추가한 확장 완성형 CP 949가 사용된다. 한글 윈도우가 사용.\n\n이후 인터넷 통신이 이루어짐에 따라 유니코드개발. UTF-8은 1~4 가변, UTF-16은 2 고정. 자바는 후자. 인터넷은 전송 속도가 중요하므로 UTF-8 많이 사용.\n\nJVM의 피연산자 스택은 피연산자를 4바이트 단위로 저장한다.\n\nshort는 음수가 있고, char는 음수가 없다.\n\n기본형과 참조형간의 형변환은 불가능하다.\n\n부동 소수점 관련해서는 공부해보기~!\n\n형변환을 생략해도 컴파일러가 해준다. 하지만 데이터가 유실될 수 있는 경우 형변환을 명시해주어야 한다.\n\n> 연산 과정에서 자동적으로 발생하는 형변환을 산술 변환이라고 한다.\n\n### 3. 연산자\n\n부호 연산자와 뺄셈 연산자는 생긴건 같지만 다르다.\n\n쉬프트 연산자는 덧셈 연산자보다 우선순위가 낮다.\n\n비트 연산자는 비교 연산자보다 낮다.\n\nAND가 OR보다 높다.\n\n대입 연산자는 연산자의 결합 규칙이 오른쪽에서 왼쪽이다.\n\n**산술 > 비교 > 논리 > 대입, 단항 > 이항 > 삼항 순서로 진행. 단항과 대입 제외 모두 왼쪽에서 오른쪽으로 결합.**\n\nint / int = int\n\n```java\npackage chapter3;\n\npublic class CharOperator {\n\n  public static void main(String[] args) {\n    System.out.println('d' - 'a'); // 3\n    for (int i = 0; i < 10; i++) {\n      // 포매팅하니까 (char) 다음 공백 있는게 신기\n      System.out.println((char) (i + 'a')); // a-j\n    }\n    char c2 = 'a' + 1; // 형변환이 없지만 리터럴간의 연산이기에 컴파일러가 계산해서 문제 없음.\n  }\n}\n```\n\n나머지 연산자에서 나누는 수가 음수이면 해당 음수를 무시하고 나온 결과에 왼쪽 피연산자의 부호를 붙인다.\n\nfloat과 double의 비교에서 float -> double 변환을 해도 어차피 같은 값이므로 double -> float 형변환을 해야 한다.\n\n```java\npackage chapter3;\n\npublic class StringComp {\n\n  public static void main(String[] args) {\n    String str1 = \"abc\";\n    String str2 = new String(\"abc\");\n    System.out.println(str1 == \"abc\"); // true\n    System.out.println(\"abc\" == \"abc\"); // true\n    System.out.println(str1 == str2); // false\n    // String과 string 차이 그런 느낌인가?\n  }\n}\n```\n\n단축 평가로 인해 같은 조건식이라도 피연산자의 위치에 따라서 연산속도가 달라질 수있다.\n\n### 4. 조건문과 반복문\n\n> 프로그램의 흐름(flow)를 바꾸는 역할을 하는 문장들을 제어문이라고 한다.\n\nswitch문에서 break는 필수. 아래같은 경우가 있긴 하다.\n\n```java\nswitch (level) {\n    case 3:\n        grantDelete();\n    case 2:\n        grantWrite();\n    case 1:\n        grantRead();\n}\n```\n\nswitch문의 조건식 결과는 반드시 정수/문자열이어야 한다. case문의 값은 정수 상수/ 문자열 리터럴만 가능하다.\n\nSwitch의 구현은 공부해봐야겠지만 조건식을 한번만 계산하는 듯? switch 테이블 어쩌구 그건가.\n\nfor문: 초기화 -> (조건식 -> 수행될 문들 -> 증감식)\n\nfor문에서 % 연산자로 순환, / 연산자로 반복을 할 수 있다.\n\n```java\n// enhanced for statement\nfor (int tmp: arr)\n    System.out.println(tmp);\n```\n\n```java\npackage chapter4;\n\npublic class While {\n\n  public static void main(String[] args) {\n    int i = 5;\n    while (--i != 0) { // i--와 차이는?\n      System.out.println(i);\n    }\n  }\n}\n```\n\n```java\n// do while 문은 사용자 입력 받아서 처리할 때 사용될 수 있다.\n\ndo {\n    // ...\n} while (input != answer);\n```\n\n### 5. 배열\n\n> 배열은 같은 타입의 여러 변수를 하나의 묶음으로 다루는 것.\n\n배열의 길이는 0일 수도 있다.\n\n배열은 한번 생성하면 길이를 변경할 수 없기에 arr.length는 상수이다.\n\n배열은 생성과 동시에 자동적으로 자신의 타입에 해당하는 기본값으로 초기화된다.\n\n```java\nint[] score = new int[5];\n\nint[] score = new int[]{1, 2, 3, 4, 5};\nint[] score = {1, 2, 3, 4, 5};\n// 이외에 선언과 생성이 별도인 경우와 함수의 매개변수에서는 new 어쩌구를 생략할 수 없다.\n```\n\n```java\npackage chapter5;\n\npublic class ArrPrint {\n\n  public static void main(String[] args) {\n    // 타입@주소의 형식\n    System.out.println(new int[5]);\n  }\n}\n```\n\nSystem.arraycopy는 배열 요소를 한 번에 복사한다.\n\n```java\npackage chapter5;\n\nimport java.util.Arrays;\n\npublic class ArrayCopy {\n\n  public static void main(String[] args) {\n    final int[] arr1 = { 1, 2, 3 };\n    final int[] arr2 = new int[6];\n    System.arraycopy(arr1, 0, arr2, 0, 3);\n    System.arraycopy(arr1, 0, arr2, 3, 3);\n    System.out.println(Arrays.toString(arr2)); // [1, 2, 3, 1, 2, 3]\n  }\n}\n```\n\n참조형 변수의 기본값은 null이다.\n\n> String 클래스는 char배열에 기능(메서드)을 추가한 것이다.\n\nString 객체의 내용을 바꿀 수는 없다. Mutable한 문자열은 StringBuffer 클래스를 사용한다.\n\n```java\npackage chapter5;\n\npublic class StringObj {\n\n  public static void main(String[] args) {\n    String str = \"🙂\";\n    System.out.println(str.charAt(0)); // ?\n  }\n}\n```\n\n이전에 말한 길이 0인 배열은 커맨드라인에서 인수가 0개일 때 args값에서 사용된다.\n\n[how-do-i-compare-strings-in-java](https://stackoverflow.com/questions/513832/how-do-i-compare-strings-in-java)\n\n```java\n// ... but these are because literals are interned by\n// the compiler and thus refer to the same object\n\"test\" == \"test\" // --> true\n```\n\n### 6. 객체지향 프로그래밍 1\n\n1960년대에 객체지향이론을 프로그래밍 언어에 적용한 시뮬라라는 최초의 객체지향언어가 탄생하였다.\n\n객체는 모든 인스턴스를 대표하는 포괄적인 의미를 가지고, 인스턴스는 어떤 클래스로부터 만들어진 것인지를 강조하는 보다 구체적인 의미를 가지고 있다.\n\n```java\npackage chapter6;\n\npublic class ObjectArr {\n\n  public static void main(String[] args) {\n    A[] arr = new A[3];\n    System.out.println(arr[0].toString());\n    // Exception in thread \"main\" java.lang.NullPointerException\n  }\n}\n\nclass A {}\n```\n\n```java\npackage chapter6;\n\npublic class StaticVar {\n\n  public static void main(String[] args) {\n    (new B()).foo();\n  }\n}\n\n// A -> B로 변경하기 전에 java.lang.NoClassDefFoundError: 에러 뜸.\n// 다른 파일에 같은 클래스 이름이 있으면 안되는건가?\nclass B {\n\n  int sv;\n\n  void foo() {\n    // Swift와 달리 따로 명시하지 않아도 된다.\n    System.out.println(sv);\n  }\n}\n```\n\n**JVM의 메모리 구조**\n\n메서드 영역: 프로그램 실행 중 어떤 클래스가 사용되면 해당 \\*.class 파일을 읽어관련 정보를 이곳에 저장한다. 클래스 변수도 이 영역에 생성된다.\n\n힙: 인스턴스가 생성되는 공간. 인스턴스 변수들이 생성되는 공간.\n\n호출 스택(call stak, execution stack): 메서드 작업에 필요한 메모리 공간 제공.\n\n[Evaluation_strategy](https://en.wikipedia.org/wiki/Evaluation_strategy)\n\n반복문에 비해 재귀 호출은 메서드 호출에서의 오버헤드, 즉 매개변수 복사와 종료 후복귀할 주소 저장 등이 추가로 필요하기 때문에 더 오래 걸린다.\n\nmain 메서드 역시 자기 자신을 호출하는 것이 가능하다.\n\n멤버 변수는 인스턴스 변수와 static 변수를 통칭하는 말이다.\n\n인스턴스 메서드는 실행 시 호출되어야 할 메서드를 찾는 과정이 추가적으로 필요하기때문에 시간이 더 걸린다.\n\nMath 클래스의 메서드는 모두 클래스 메서드이다.\n\n> 한 클래스 내에 같은 이름의 메서드를 여러 개 정의하는 것을 메서드 오버로딩 혹은오버로딩이라고 한다.\n\n반환 타입은 오버로딩을 구현하는데 아무런 영향을 주지 못한다.\n\n```java\npackage chapter6;\n\nclass Overloading {\n\n  public static void main(String[] args) {\n    System.out.println(add(3, 3));\n  }\n\n  static long add(int a, long b) {\n    return a + b;\n  }\n  // 이 함수가 있는 순간 main에서의 함수 호출 유추가 불가능해짐.\n  // static long add(long a, int b) {\n  //     return a + b;\n  // }\n}\n```\n\n가변인자가 선언된 메서드를 호출할 때마다 배열이 새로 생성되는 비효율이 숨어있음알기.\n\n가능한 가변인자를 사용한 메서드는 오버로딩하지 않는 것이 좋다.\n\n연산자 new가 인스턴스를 생성하는 것이지 생성자가 인스턴스를 생성하는 것이 아니다.\n\n**인스턴스 생성 과정**\n\n- 연산자 new에 의해 힙에 클래스의 인스턴스가 생성된다.\n- 생성자가 호출되어 수행된다.\n- 연산자 new의 결과로 생성된 인스턴스의 주소가 반환되어 참조변수에 저장된다.\n\n클래스의 접근 제어자가 public인 경우에는 기본 생성자로 public 클래스이름() {}이추가된다.\n\n생성자간 호출이 가능하지만 생성자의 이름으로 this를 사용하고 반드시 첫 줄에서 호출해야한다.\n\n지역변수는 사용하기 전에 반드시 초기화해야한다.\n\n```java\n// 이런게 된다.\nclass A {\n    int x;\n    int y=x;\n}\n```\n\n초기화 블럭이라는 개념이 존재.\n\n```java\npackage chapter6;\n\n// 명시적 초기화 이후 초기화 블럭 실행\n// 따라서 10 이후 3 출력\npublic class InitBlock {\n\n  static int a = 10;\n  static final int b;\n\n  static {\n    System.out.println(a);\n    a = 3;\n    // 생성자 말고 초기화 블럭에서도 초기화할 수 있다.\n    b = 10;\n  }\n\n  public static void main(String[] args) {\n    System.out.println(a);\n  }\n}\n```\n\n클래스 변수는 클래스가 처음 로딩될 때 한번 초기화되고, 로딩 시점은 JVM 종류에 따라 클래스가 필요할때일 수도 있고 프로그램 시작 때 미리 로딩할 수도 있다.\n\n```java\npackage chapter6;\n\nclass Document {\n\n  static int count = 0;\n  String name;\n\n  Document() {\n    this(\"제목없음\" + ++count);\n  }\n\n  Document(String name) {\n    this.name = name;\n    System.out.println(this.name);\n  }\n}\n\nclass DocumentTest {\n\n  public static void main(String[] args) {\n    new Document(\"Temp\");\n    for (int i = 0; i < 5; i++) {\n      new Document();\n    }\n  }\n}\n```\n\n### 7. 객체지향 프로그래밍 2\n\n생성자와 초기화 블럭은 상속되지 않고 멤버만 상속된다.\n\n클래스 간의 관계에서 형제 관계와 같은 것은 없다.\n\nis-a, has-a\n\n```java\npackage chapter7;\n\nclass ToString {\n\n  // 자동완성쓰니 여기에 @override 이런게 삽입됨.\n  public String toString() {\n    return \"Hello, world!\";\n  }\n}\n\nclass ToStringTest {\n\n  public static void main(String[] args) {\n    System.out.println(new ToString()); // Hello, world!\n  }\n}\n```\n\noverride하는데 따로 명시가 필요한 것 같지는 않다.\n\n자바에서는 단일 상속만 허용한다.\n\nObject 클래스는 모든 클래스 상속계층도의 최상위에 있는 조상클래스이다.\n\n**오버라이딩에서 접근 제어자는 좁아질 수 없고, 예외는 많아질 수 없다.**\n\nstatic 메서드는 오버라이드되지 않고 별도의 메서드가 정의되는 것이다.\n\n> 조상의 멤버와 자신의 멤버를 구별하는데 사용된다는 점을 제외하고는 super와 this 는 근본적으로 같다. 모든 인스턴스 메서드는 자신이 속한 인스턴스의 주소가 지역변수로 저장되는데, 이것이 참조변수인 this 와 super의 값이 된다,,, 객체지향 구현에 대해 더 찾아보기.\n\n같은 패키지 내에서는 클래스 공유되는 듯?\n\n```java\npackage chapter7;\n\nimport static java.lang.System.out;\n\n// AA INIT\n// 10\n// 20\nclass VariableOverride {\n\n  public static void main(String[] args) {\n    new BB();\n  }\n}\n\nclass AA {\n\n  int x = 10;\n\n  AA() {\n    System.out.println(\"AA INIT\");\n  }\n}\n\nclass BB extends AA {\n\n  int x = 20;\n\n  BB() {\n    out.println(super.x); // 10\n    out.println(x); // 20\n  }\n}\n```\n\nswift와 달리 자기 클래스 변수 초기화 안하고 첫줄에 조상 클래스의 생성자를 호출한다. 조상 클래스의 멤버변수는 조상의 생성자를 통해 초기화한다. 없으면 컴파일러가집어넣는듯.\n\n클래스의 실제 이름은 패키지명을 포함한다. 패키지는 물리적으로 .class를 포함하는하나의 디렉토리이다.모든 클래스는 하나의 패키지에 속해야 하며 .을 구분자로 계층구조로 구성할 수 있다.\n\nVSCode에서 하는데 왜 unnamed package가 안될까?\n\nimport문에서의 \\*가 하위 패키지의 클래스까지 포함하지는 않는다.\n\nSystem와 String을 사용할 수 있었던건 import java.lang.\\*이 생략되어있었기 때문이다.\n\nimport static을 통해 static 멤버를 사용할 수 있다.\n\n주로 접근제어자를 가장 왼쪽에 놓는다.\n\nWindowAdapter처럼 abstract 메서드가 없어도 클래스에 abstract를 붙일 수 있는데, 이 경우 필요한 것만구현해서 쓸 수 있다.\n\nprivate는 같은 클래스 내에서, default는 같은 패키지 내에서, protected는 같은 패키지 혹은 다른 패키지의 자식 클래스에서, public은 접근 제한이 없다. 클래스는 public과 default만 사용할 수 있다.\n\ndefault 안에 public 메서드가 가능하네??\n\n하나의 소스파일에는 public 클래스가 단 하나만 존재할 수 있고 소스파일의 이름은 public 클래스의 이름과 같아야 한다.\n\npublic 클래스가 없어도 되지만 다른 패키지에서 접근은 불가능한듯. [what is the difference between `public class` and just `class`?](https://stackoverflow.com/questions/16779245/what-is-the-difference-between-public-class-and-just-class)\n\n생성자가 private인 클래스는 다른 클래스의 조상이 될 수 없으므로 클래스 앞에 final을 붙이는 것이 좋다.\n\n```java\npackage chapter7;\n\nclass AAA {\n\n  private AAA() {}\n}\n\nclass BBB extends AAA {\n\n  // Implicit super constructor AAA() is not visible. Must explicitly invoke\n  // another constructor\n  BBB() {}\n}\n```\n\n모든 참조변수는 null또는 4byte의 주소값이 저장되며, 참조변수의 타입은 참조할 수있는 객체의 종류와 사용할 수 있는 멤버의 수를 결정한다.\n\n[Package-private class within a .java file - why is it accessible?](https://stackoverflow.com/questions/7634131/package-private-class-within-a-java-file-why-is-it-accessible)\n\n```java\npackage chapter7;\n\npublic class WrongCast {\n\n  public static void main(String[] args) {\n    X x = new X();\n    Y y = (Y) x;\n    // Exception in thread \"main\" java.lang.ClassCastException: class chapter6.X\n    // cannot be cast to class chapter6.Y (chapter6.X and chapter6.Y are in unnamed\n    // module of loader 'app')\n    // at chapter6.WrongCast.main(WrongCast.java:6)\n    System.out.print(y.toString());\n\n    if (y instanceof Y) {\n      // ...\n    }\n  }\n}\n\nclass X {}\n\nclass Y extends X {}\n```\n\n**멤버변수가 조상 클래스와 자손 클래스에 중복으로 정의된 경우, 참조변수의 타입에따라 접근되는 변수가 달라진다.**\n\n```java\npackage chapter7;\n\nclass AAA {\n\n  private AAA() {}\n}\n\nclass BBB extends AAA {\n\n  // Implicit super constructor AAA() is not visible. Must explicitly invoke\n  // another constructor\n  BBB() {}\n}\n```\n\nprint함수는 다형성을 활용해 toString을 호출하여 작동한다.\n\nVector는 동적으로 크기가 관리되는 객체 배열이다.\n\n추상 메서드가 없는 완성된 클래스라 할지라도 추상클래스로 지정되면 클래스의 인스턴스를 생성할 수 없다.\n\n> 추상 메서드를 선언하는 이유는 자식 클래스에서 추상메서드를 반드시 구현하도록강요하기 위해서이다.\n\n> 인터페이스는 추상클래스처럼 추상메서드를 갖지만 추상화 정도가 높아 몸통을 갖춘일반 메서드 또는 멤버변수를 구성원으로 가질 수 없다.\n\n인터페이스의 모든 멤버변수는 public static final이고, 메서드는 static 메서드와디폴트 메서드 제외 public abstract이어야 한다. 이들은 생략 가능하다.\n\nclass -> extends, interface -> implements\n\n인터페이스의 이름에는 주로 -able로 끝나는 것들이 많은데 어떠한 기능 또는 행위를하는데 필요한 메서드를 제공한다는 의미를 강조하기 위해서이다.\n\n```java\npackage chapter7;\n\ninterface Movable {\n  void move();\n}\n\nclass Fighter implements Movable {\n\n  // Cannot reduce the visibility of the inherited method from Movable\n  // void move() {\n  // }\n  public void move() {}\n}\n```\n\n**클래스와 클래스간의 직접적인 관계를 인터페이스를 이용해서 간접적인 관계로 변경하면, 한 클래스의 변경이 관련된 다른 클래스에 영향을 미치지 않는 독립적인 프로그래밍이 가능하다.**\n\nThread(Runnable target)이 인터페이스를 매개변수로 전달받는 형태이고, JDBC의 DriverManager클래스처럼 제3의 클래스를 통해 인스턴스를 제공받을 수도 있다.\n\nJDK1.8부터 static 메서드를 인터페이스에 추가할 수 있었으나, 이전에는 아니어서 Collection관련 static 메서드들은 Collections 클래스에 존재한다.\n\n> 디폴트 메서드는 추상 메서드의 기본적인 구현을 제공하는 메서드로 추상 메서드가아니기 때문에 디폴트메서드가 새로 추가되어도 해당 인터페이스를 구현한 클래스를 변경하지 않아도 된다.\n\n```java\npackage chapter7;\n\npublic class StaticMethodTest {\n\n  public static void main(String[] args) {\n    MyClass x = new MyClass();\n    MyInterface.method();\n    x.method(); // The method method() is undefined for the type MyClass\n  }\n}\n\nclass MyClass implements MyInterface {}\n\ninterface MyInterface {\n  static void method() {}\n}\n```\n\n```java\n// 내부 클래스 예시\nclass Outer {\n    private class InstanceInner {}\n    protected static class StaticInner {}\n    void myMethod() {\n        // 지역 클래스는 외부 클래스에서 final이 붙은 지역 변수만 접근 가능한데 이는 메서드가 수행을 마쳐서 지역변수가 소멸된 시점에도 지역 클래스의 인스턴스가 소멸된 지역변수를 참조하려는 경우가 있을 수 있기 때문이다.\n        // final이 없어도 컴파일러가 자동으로 붙여준다.\n        // 자바에는 클로저 이런 개념이 없어서 그런가?\n        class LocalInner {}\n    }\n}\n```\n\n내부 클래스와 외부 클래스에 선언된 변수명이 같은 때는 외부 클래스명.this로 구분할 수 있는데 쓸 일이 있을까,,,?\n\n```java\nimport java.awt.*;\nimport java.awt.event.*;\n\nclass InnerEx7 {\n    public static void main(String[] args) {\n        Button b = new Button(\"Start\");\n        b.addActionListener(new EvenrHandler());\n    }\n}\n\nclass EventHandler implements ActionListener {\n    public void actionPerformed(ActionEvent e) {\n        System.out.println(\"ActionEvent occurred\");\n    }\n}\n```\n\n### 8. 예외처리\n\n자바는 프로그램 오류를 두 가지로 구분한다.\n\n> 에러(error): 프로그램 코드에 의해서 수습될 수 없는 심각한 오류예외(exception): 프로그램 코드에 의해서 수습도리 수 있는 다소 미약한 오류\n\nException 클래스의 자손들 중 RuntimeException은 주로 프로그래머의 실수에 의해서발생될 수 있는 것이고, RuntimeException을 제외한 것들은 외부의 영향으로 발생할수있는 것들이다.\n\ntry-catch문의 마지막에 Exception 클래스를 사용하면 모든 예외를 잡을 수 있다.\n\n|를 사용한 멀티 catch 블럭으로 여러 에러를 잡을 수 있다. 멀티 catch 블럭의 e는상수이다??\n\n컴파일러가 예외처리를 확인하지 않는 RuntimeException 클래스들은 unchecked 예외라고 부르고, 예외처리를 확인하는 Exception 클래스들은 checked 예외라고 부른다. RuntimeException은 메서드에 예외를 선언할때도 보통 적지 않는다.\n\n두 메서드가 예외처리를 분담할 수도 있다.\n\ntry 블럭에서 return 문이 실행되는 경우에도 finally 블럭의 문장들이 먼저 실행된후에 현재 실행중인 메서드를 종료한다.\n\n기본적으로 finally문에서 예외가 발생하면 try블럭의 예외는 무시된다. try-with-resources문의 괄호 안에서 Autoclosable을 채택한 객체를 생성하는 문장을넣으면 try문을 벗어날 때 자동적으로 close가 호출된다. 이때 try에서와 finally에서모두 예외가 발생하면 CloseException은 억제된 예외로 다룬다.\n\n현재 자바는 모바일이나 웹 프로그래밍에서 주로 사용되는데, 프로그래밍 환경이 달라진 만큼 필수적으로처리해야만 할 것 같았던 예외들이 선택적으로 처리해도 되는 상황으로 바뀌는 경우가 종종 있다. 따라서 unchecked 예외가 더 환영받고 있다. 따라서점점 Exception보다는 RutimeException을 상속받아서 작성하는경우가 많아지고 있다.\n\nfinally문에서도 return을 할 수 있으며 try나 catch블럭의 return문 다음에 실행되며최종적으로 반환되는값이다.\n\ninitCause/getCause로 연결된 예외를 다룰 수 있고 checked 예외를 unchecked 예외로바꿀 수 있다.\n\n```java\nRuntimeException(Throwable cause)\n```\n\n### 9. java.lang 패키지와 유용한 클래스\n\n```java\npackage chapter9;\n\nimport static java.lang.System.out;\n\npublic class Lang {\n\n  public static void main(String[] args) {\n    A a1 = new A(1);\n    A a2 = new A(1);\n    out.println(a1 == a2); // false\n    out.println(a1.equals(a2)); // true\n  }\n}\n\nclass A {\n\n  int id;\n\n  A(int id) {\n    this.id = id;\n  }\n\n  public boolean equals(Object obj) {\n    return (obj instanceof A && ((A) obj).id == id);\n  }\n}\n```\n\nequals를 구현했으면 hashCode 메서드도 같은 값이 나오게 바꾸어주어야한다.\n\n```java\n// 기본 toString() 구현\npublic String toString() {\n    return getClass().getName() + \"@\" + Integer.toHexString(hashCode());\n}\n```\n\nClonable 인터페이스를 구현한 클래스만 clone메서드를 부를 수 있다. 이때 공변 변환타입(coviriant return type)덕분에 Object 타입이 반환되지 않아도 된다.\n\nClonable은 얕은 복사를 한다.\n\n클래스 객체는 특정 클래스의 인스턴스로 이름이 'Class'이다. Class 객체는 클래스의모든 정보를 담고 있고 클래스 당 1개만 존재한다. 클래스 파일이 클래스 로더에 의해메모리에 올라갈 때 자동으로 생성된다.\n\n> 클래스 로더는 실행시에 필요한 클래스를 동적으로 메모리에 로드하는 역할을 하며기존에 생성된 클래스객체가 메모리에 없다면 클래스 패스에 지정된 경로를 따라클래스 파일을 찾는다.\n\n```java\nClass cobj = new Card().getClass();\nClass cObj = Card.class;\nClass cObj = Class.forName(\"Card\");\n```\n\n> 동적으로 객체를 생성하고 메서드를 호출하는 방법에 대해 더 알고 싶다면 '리플렉션 API'로 검색하면 된다.\n\n문자열간의 결합이나 추출 등 문자열을 다루는 작업이 많이 필요한 경우에는 StringBuffer 클래스를 사용하는 것이 좋다.\n\n문자열 리터럴은 이미 존재하는 것을 재사용하는 것이다. 자바 소스파일에 포함된 모든 문자열 리터럴은 컴파일 시에 클래스 파일에 저장된다. constant pool.\n\n자바는 C와 달리 문자열 맨 끝에 nul이 있지는 않고 문자열의 길이 정보를 저장한다.\n\nintern: 문자열을 상수풀에 등록한다. 이미 있으면 그 문자열의 주소값을 반환한다.\n\nStringbuffer 클래스에는 append처럼 자기 자신을 반환하는 메서드들이 많이 있다. .append().append()... 가능.\n\nStringbuffer는 thread safe하도록 동기화가 되어 성능이 떨어지고, StringBuilder는멀티쓰레드 지원이 없다. 나머진 완전 동일.\n\nrint는 반환값이 double이고 가장 가까운 짝수 정수를 반환한다.\n\nMath클래스는 OS 의존적인 계산을 하지만 StrictMath는 성능은 다소 포기해도 모두 같은 결과를 반환한다.\n\n기본형 변수도 객체로 다루어야할 때 래퍼 클래스를 이용한다.\n\n기본형 값을 래퍼 클래스의 객체로 컴파일러가 자동 변환해주는 것을 오토박싱, 반대는 언박싱이라고 한다.\n\n챕터 9 뒤쪽은 훑어보기만 함~\n\n### 10. 날짜와 시간 & 형식화\n\nCalendar는 바로는 못쓰고 getInstance 메소드를 쓰면 지역에 따라 적당한 인스턴스를반환해준다.\n\n자바스크립트와 마찬가지로 Month가 0부터 시작한다. 자스가 자바 따라했다는 것 같기도,,,?\n\nroll 메서드는 다른 필드의 값을 바꾸지 않는다. 회전하는? 느낌인 듯.\n\n날짜 관련은 동기부여가 안돼서 포기,, 나중에 다시 찾아오기-!\n\n### 11. 컬렉션 프레임웍\n\n컬렉션(collection): 데이터 군\n\nCollection -> List(ArrayList, LinkedList, Stack, Vector) -> Set(HashSet, TreeSet)\n\nMap(HashMap, TreeMap, Hashtable, Propertied)\n\n명명법이 다른 애들은 프레임워크 이전에도 있었던 애들로, 새로 추가된 애들을 대신사용하는 것이 좋다.\n\nCollection은 인터페이스이고 Collections는 클래스이다.\n\n배열을 이용한 자료구조는 용량을 변경할 때 새로운 배열을 생성해야하므로 효율이 상당히 떨어진다.\n\nLinkedList 클래스는 양방향 연결 리스트로 구현되어있다.\n\n```java\npackage chapter9;\n\nimport static java.lang.System.out;\n\nimport java.util.*;\n\npublic class ArrayListVSLinkedList {\n\n  public static void main(String[] args) {\n    ArrayList<Number> al = new ArrayList<Number>(2000000);\n    LinkedList<Number> ll = new LinkedList<Number>();\n\n    // 순차적으로 추가\n    out.println(add1(al));\n    out.println(add1(ll));\n    // 중간에 추가\n    out.println(add2(al));\n    out.println(add2(ll));\n    // 중간에 삭제\n    out.println(remove2(al));\n    out.println(remove2(ll));\n    // 순차적 삭제\n    out.println(remove1(al));\n    out.println(remove1(ll));\n    // 중간에 추가/삭제는 연결 리스트가 확실히 빠름.\n    // 순차적인건 ArrayList가 빠른데 압도적 차이까지는 아닌 느낌?\n  }\n\n  public static long add1(List<Number> list) {\n    long start = System.currentTimeMillis();\n    for (int i = 0; i < 1000000; i++) list.add(i);\n    long end = System.currentTimeMillis();\n    return end - start;\n  }\n\n  public static long add2(List<Number> list) {\n    long start = System.currentTimeMillis();\n    for (int i = 0; i < 10000; i++) list.add(500, i);\n    long end = System.currentTimeMillis();\n    return end - start;\n  }\n\n  public static long remove1(List<Number> list) {\n    long start = System.currentTimeMillis();\n    for (int i = list.size() - 1; i >= 0; i--) list.remove(i);\n    long end = System.currentTimeMillis();\n    return end - start;\n  }\n\n  public static long remove2(List<Number> list) {\n    long start = System.currentTimeMillis();\n    for (int i = 0; i < 10000; i++) list.remove(i);\n    long end = System.currentTimeMillis();\n    return end - start;\n  }\n}\n```\n\n일반 배열은 짐작?으로 배열 크기를 선언해야하므로 메모리 사용이 비효율적임.\n\nStack을 구현한 클래스는 따로 있지만 Queue는 해당 인터페이스를 구현한 LinkedList 같은 애들을 가져다쓰면 된다. Stack은 인터페이스가 없나??\n\nStack은 맨 위에 저장된 객체의 index를 1로 정의한다??\n\nEnumeration은 Iterator의 구버전이고, ListIterator는 Iterator를 상속받아 향상시킨것이다. 양방향 이동이 가능하다.\n\nextends Vector implements Iterator로 할 수 있는데 한 클래스에서 한번에 하는거 어디서 읽었더라?\n\nArrays에 정의된 메서드는 모두 static 메서드이다.\n","path":"language/java/index.md"}