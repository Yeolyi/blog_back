{"pathArr":[],"metaData":{"title":"Clojure"},"content":"\n## Living Clojure\n\nLiving Clojure by Carin Meier. Copyright © 2015 Carin Meier. All rights reserved. Published by O’Reilly Media, Inc., 1005 Gravenstein Highway North, Sebastopol, CA 95472.\n\n[GitHub](https://github.com/gigasquid/wonderland-clojure-katas)\n\n## Preface\n\n> We will be concentrating on the major aspects of the language, not the minutaie, with the goal being to learn how to _think_ closure.\n\nClojure runs on the Java virtual machine(JVM).\n\n```clj\n42\n;; -> 42\n```\n\n## 1. A Guided Tour of Clojure\n\nIt is designed to get you up and running with a rounded undertstanding of the language, project setup, and useful libraries.\n\n### 1. The Structure of Clojure\n\n클로저 코드는 표현식으로 구성되어있으며 평가 후 결과를 반환한다. 가장 간단한 표현식은 그 자신으로 평가되며 simple values/literal로 불린다.\n\n```clj\n(println 1/3) ; 1/3\n(println 4/2) ; 2\n; (println 4.0/2) Invalid number: 4.0/2\n\n(println (/ 1 3)) ; 1/3\n(println (/ 1.0 3)) ; 0.3333...\n\n(println \"JAM\") ; JAM\n\n; Clojure에서 키워드는 symbolic identifier이다. \n; 아주 유용하게 사용됨. 단순 값. \n(println :jam) ; :jam\n\n; character\n(println \\j) ; j\n\n; boolean\n(println true false) ; true false\n; 그나저나 쉼표 유무는 상관 없는 듯?\n(println true, false) ; true false\n\n; nil \n(println nil)\n\n(println (+ 1 1)) ; 2\n(println (+ 1 ( + 8 3))) ; 12\n```\n\n클로저에서는 함수나 연산자가 패러미터보다 먼저 등장한다.\n\nClojure collection에는 list, vector, map, set이 있다.\n\n```clj\n; List\n(println '(1 2 \"A\" :B))\n; 쉼표는 무시되고 공백과 같이 처리된다.\n; 클로저에서는 코드 스타일의 맥락에서 idiomatic이란 단어가 자주 사용된다. \n; 'You can use commas, but it is idiomatic not to.'\n\n(println (first '(:a :b :c :d))) ; :a\n(println (rest '(:a :b :c :d))) ; (:b :c :d)\n(println (first (rest '(:a :b :c :d)))) ; :b\n\n(println (first '())) ; nil\n\n; 첫번째 인자는 추가하고자 하는 요소, 두번째는 리스트\n(println (cons 5 '())) ; (5)\n; 리스트의 끝은 nil로 specified되므로 아래도 된다.\n(println (cons 5 nil)) ; (5)\n(println (cons 1 '(2))) ; (1 2)\n; (println (cons '(2) 1)) IllegalArgumentException\n\n\n; Vector\n; Collecting Data by Index\n(println [1 2 3 4 5]) ; [1 2 3 4 5]\n; 리스트와 달리 fast index access 가능\n(println (nth [1 2 3 4 5] 3)) ; 4\n(println (nth '(1 2 3 4 5) 3)) ; 4\n; 되지만 vector에서 더 성능이 좋다. 리스트에서는 첫번째 인덱스부터 탐색한다\n\n(println (count [1 2 3])) ; 3\n\n; conj 함수는 가장 자연스러운 위치에 원소를 삽입한다.\n(println (conj '(1 2) 3)) ; (3 1 2)\n; 정황상 list는 연결리스트인 것 같기도?\n(println (conj [1 2] 3)) ; [1 2 3]\n\n\n; Map\n(println {:jam1 \"strawberry\" :jam2 \"blackberry\"})\n; Maps are the on place that it can be idiomatic to leave the commas in for readability.\n(println {:jam1 \"strawberry\", :jam2 \"blackberry\"})\n\n(println (get {:jam1 \"strawberry\", :jam2 \"blackberry\"} :jam3)) ; nil\n(println (get {:jam1 \"strawberry\", :jam2 \"blackberry\"} :jam3 \"not found\")) ; not found\n\n; 키를 함수로써 사용할 수 있다.\n; 키워드는 맵의 키로써 가장 많이 사용된다. \n(println (:jam1 {:jam1 \"strawberry\", :jam2 \"blackberry\"})) ; strawberry\n\n(println (keys {:jam1 \"strawberry\", :jam2 \"blackberry\"})); ; (:jam1 :jam2)\n(println (vals {:jam1 \"strawberry\", :jam2 \"blackberry\"})); ; (:jam1 :jam2)\n\n(println (assoc {:jam1 \"red\" :jam2 \"black\"} :jam1 \"orange\")); \n(println (dissoc {:jam1 \"red\" :jam2 \"black\"} :jam1 \"orange\")); \n(println (merge {:jam1 \"red\" :jam2 \"black\"} {:jam1 \"orange\"})); \n\n; Set\n(println #{:red :blue :white :pink})\n; (println #{:red :blue :white :pink :pink}) Duplicate key: pink\n\n(require 'clojure.set) ; 책에는 왜 이거 없냐\n(println (clojure.set/union #{:r :b :w} #{:w :p :y}))\n(println (clojure.set/difference #{:r :b :w} #{:w :p :y}))\n(println (clojure.set/intersection #{:r :b :w} #{:w :p :y}))\n\n(println (set [:a :b :c]))\n(println (get (set {:a 1 :b 2 :c 3}) [:a 1]))\n(println (contains? #{:a :b :c} :a)) ; true\n\n; conj와 disj가 동일하게 작동\n```\n\n모든 collection은 immutable하고 persistent하다. 전자는 불변성이고, 후자는 각 collection이 structural sharing을 사용해 새로운 버전의 스스로를 smart creation한다는 것이다.\n\nLists are actually at the heart of Clojure.\n\nClojure의 기본 구조는 LISP(LISt Processing)에서 왔고, LISP에서 표현식의 첫 요소는 연산자 혹은 함수로 간주된다. 따라서 Clojure에서 리스트는 `(어쩌구)로 표현된다. 없으면 문자열을 함수로 실행시키려고 함.\n\n> ‘All Clojure code is made of lists of data.’\n\n```clj\n; def allows us to give something a name\n(def developer \"Alice\")\n(println developer) ; Alice\n\n; 콘솔에서 실행시키면 아래처럼 user 네임스페이스가 있음\n; Created a var object in the default namespace of our REPL called user\n; (def developer \"Alice\")\n; -> #'user/developer’\n; user/devloper\n; -> \"Alice\"\n\n\n; let은 자신이 속한 context에서만 유효한 심벌에 값을 바인딩한다. \n(\n  let [a \"a\" b \"b\"]\n  (println a b)\n)\n; (print a b) 없음\n\n; defn\n(defn follow-the-rabbit [] \"Off we go!\")\n(println  (follow-the-rabbit))\n\n(defn shop-for-jams [jam1 jam2]\n  {:name \"jam-basket\"\n   :jam1 jam1\n   :jam2 jam2\n  }\n)\n(println (shop-for-jams \"strawberry\" \"marmalade\"))\n\n; 괄호 두 개여야 invoke\n(println ((fn [] (str \"Off we go\" \"!\"))))\n\n; 사실 defn은 fn로 만든 익명 함수에 def한 것과 같다.\n\n; 익명 함수 shorthand\n(println (#(str \"Off we go\" \"!\")))\n(println (#(str \"Off we go\" \"!\" \"-\" %) \"again\"))\n(println (#(str \"Off we go\" \"!\" \"-\" %1 %2) \"again\" \" again!!\"))\n```\n\nOOP에서는 객체로 정리하지만 클로저에서는 네임스페이스를 활용한다.\n\n```clj\n(println (ns alice.favfoods)) ; nil\n; (println ns alice.favfoods) ; 이러면 터짐\n;이후의 def는 해당 이름 공간에 할당된다.\n\n; REPL에서 *ns*로 현재 네임스페이스 알 수 있음\n; 별표는 earmuff로 used as a convention for things that are intended for rebinding\n\n(def fav-food \"strawberry jam\")\n(println fav-food)\n\n(ns rabbit.favfoods)\n\n(def fav-food \"lettuce soup\")\n(println fav-food)\n(println alice.favfoods/fav-food)\n\n; 클로저 libs도 이를 적극 활용 중\n; REPL이 실행될 때 auto-required되지만 아니면 아래 구문으로 require\n; (require 'clojure.set)\n\n(ns wonderland)\n(require '[alice.favfoods :as af])\n(println af/fav-food) ; strawberry jam\n\n(ns wonderland (:require [alice.favfoods :as af])) ; ?????\n\n; Most Clojure code will use libs with a require and specify an alias using :as\n\n; :refer :all은 추천하지 않는다니 공부 생략\n```\n","path":"language/clojure/index.md"}