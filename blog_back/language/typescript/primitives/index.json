{"pathArr":[],"metaData":{"title":"Primitives"},"content":"\n## Any\n\n> Any is the TypeScript escape clause. Any declares to TypeScript to trust your code as being safe because you know more about it.\n\nJSON 파싱등에서 사용될 수 있다. never를 제외한 모든 타입을 교체 가능.\n\n```ts\n// TypeScript will take into account the position of the\n// anys in different forms\nfunction swap(x: [number, string]): [string, number] {\n  return [x[1], x[0]];\n}\n\nconst pair: [any, any] = [1, 'hello'];\nconsole.log(swap(pair));\n```\n\nUnknown is a sibling type to any, if any is about saying \"I know what's best\", then unknown is a way to say \"I'm not sure what is best, so you need to tell TS the type\"\n\n## Literals\n\n> A literal is a more concrete subtype of a collective type.\n\nWhat this means is that \"Hello World\" is a string, but a string is not \"Hello World\" inside the type system??\n\n```ts\nfunction allowsFirstFiveNumbers(arg: 1 | 2 | 3 | 4 | 5) {\n  console.log(arg);\n}\n\n// allowsFirstFiveNumbers(10);\n\n// let number = 1;\n// allowsFirstFiveNumbers(number);\n\nconst number = 1;\nallowsFirstFiveNumbers(number);\n\n// const obj = { num: 1 };\n// allowsFirstFiveNumbers(obj.num);\n\nconst obj = { num: 1 } as const;\nallowsFirstFiveNumbers(obj.num);\n\n// \"as const\" is a great tool for fixtured data, and places\n// where you treat code as literals inline. \"as const\" also\n// works with arrays:\n```\n\n## Union and Intersection Types\n\n```ts\ninterface ErrorHandling {\n  success: boolean;\n  error?: { message: string };\n}\ninterface ArtworksData {\n  artworks: { title: string }[];\n}\ntype ArtworksResponse = ArtworksData & ErrorHandling;\n\nconst handleArtistsResponse = (response: ArtworksResponse) => {\n  if (response.error) {\n    console.error(response.error.message);\n    return;\n  }\n  console.log(response.artworks);\n};\n```\n\n## Unknown and Never\n\n**Unknown**\n\nWhere any allows for ambiguity - unknown requires specifics.\n\n```ts\n// 리턴값이 unknown이므로 타입을 명시하기 전까지는 반환값을 사용할 수 없다.\nconst jsonParserUnknown = (jsonString: string): unknown => JSON.parse(jsonString);\ntype User = { name: string };\nconst myUserAccount = jsonParserUnknown(`{ \"name\": \"Samuel\" }`) as User;\nmyUserAccount.name;\n```\n\nAPI 사용자가 타입을 신경쓰도록 강제할 수 있다.\n\n**Never**\n\nBecause TypeScript supports code flow analysis, the language needs to be able to represent when code logically cannot happen.\n\nA very popular use for never, is to ensure that a switch is exhaustive. E.g., that every path is covered.\n\n```ts\nenum Flower {\n  Rose,\n  Rhododendron,\n  Violet,\n  Daisy,\n  Tulip,\n}\n\nconst flowerLatinName = (flower: Flower) => {\n  switch (flower) {\n    case Flower.Rose:\n      return 'Rosa rubiginosa';\n    case Flower.Rhododendron:\n      return 'Rhododendron ferrugineum';\n    case Flower.Violet:\n      return 'Viola reichenbachiana';\n    case Flower.Daisy:\n      return 'Bellis perennis';\n\n    default:\n      // 'Flower' 형식은 'never' 형식에 할당할 수 없습니다.\n      const _exhaustiveCheck: never = flower;\n      return _exhaustiveCheck;\n  }\n};\n```\n","path":"language/typescript/primitives/index.md"}