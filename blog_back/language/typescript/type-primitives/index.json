{"pathArr":[],"metaData":{"title":"Type Primitives"},"content":"\n## Tuples\n\n> TypeScript has special analysis around arrays which contain multiple types, and where the order in which they are indexed is important. These are called tuples.\n\nA tuple can feel like a good pattern for short bits of connected data or for fixtures.\n\n```ts\nconst notTuple = ['Not Found', 404];\n// const notTuple: (string | number)[]\n\nconst tuple: [string, number] = ['{}', 200];\n// const tuple: [string, number]\n\nconst tuple2: [number, number] = [1, 2];\n// 아래 둘 다 가능,,, 근데 쓸까?\n// const unknownLengthTuple: [string, ...[...number[]][]] = ['Hello', tuple2, tuple2];\nconst unknownLengthTuple: [string, ...number[][]] = ['Hello', tuple2, tuple2];\n```\n\n## Built-in Utility Types\n\n```ts\ninterface Person {\n  name: string;\n  age: number;\n}\n\n// 모두 optional로 변경\ntype PersonUpdateParam = Partial<Person>;\nconst param: PersonUpdateParam = {};\n\n// 프로퍼티를 read-only로\ntype PersonFromAPI = Readonly<Person>;\n\n// Record<KeysFrom, Type>\n// KeysFrom를 키 값으로 각각에게 Type인 값을 부여\ntype NavigationPages = 'name' | 'age';\ninterface PageInfo {\n  title: string;\n}\nconst navigationInfo: Record<NavigationPages, PageInfo> = {\n  name: { title: 'name' },\n  age: { title: 'age' },\n};\n\n// Pick<Type, Keys>\n// 타입에서 선택된 프로퍼티만 남김\ntype PersonSortPreview = Pick<Person, 'name'>;\n\n// Omit<Type, Keys>\n\n// Exclude<Type, RemoveUnion>\n// Extract<Type, MatchUnion>\n\ntype PersonLookupResult = Person | undefined | null;\ntype ValidatedResult = NonNullable<PersonLookupResult>;\n\nfunction getPersonByID(id: number): Promise<Person> | void {}\ntype PersonResponse = ReturnType<typeof getPersonByID>;\n\n// Converts all optional properties to required ones.\ntype AccessiblePageInfo = Required<PageInfo>;\n\n// ThisType<Type>, InstanceType<Type> 생략\n```\n\n[omit vs exclude](https://stackoverflow.com/questions/56916532/difference-b-w-only-exclude-and-omit-pick-exclude-typescript)\n\n## Nullable Types\n\nUndefined is when something cannot be found or set.\n\nNull is meant to be used when there is a conscious lack of a value.\n\n2.0버전 이전까지는 null과 undefined가 타입 시스템에서 무시되었다. Version 2.0 added a compiler flag called \"strictNullChecks\" and this flag required people to treat undefined and null as types which needs to be handled via code-flow analysis.\n\n```ts\ntype PotentialString = string | null | undefined;\n// strict mode가 켜져있다면 string으로 보인다.\n```\n","path":"language/typescript/type-primitives/index.md"}