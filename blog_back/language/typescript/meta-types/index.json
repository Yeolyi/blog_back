{"pathArr":[],"metaData":{"title":"Meta-Types"},"content":"\n## Conditional Types\n\nConditional Types provide a way to do simple logic in the TypeScript type system.\n\nnormal day to day code에서 사용할 일 없다고 하니 일단 생략.\n\n## Discriminate Types\n\n> A discriminated type union is where you use code flow analysis to reduce a set of potential objects down to one specific object.\n\n```ts\ntype APIResponses =\n  | { version: 0; msg: string }\n  | { version: 1; message: string; status: number }\n  | { error: string };\n\nconst handleResponse = (response: APIResponses) => {\n  if ('error' in response) {\n    console.error(response.error);\n    return;\n  }\n\n  if (response.version === 0) {\n    console.log(response.msg);\n  } else if (response.version === 1) {\n    console.log(response.status, response.message);\n  }\n};\n```\n\n## Indexed Types\n\n```ts\ninterface ArtworkSearchResponse {\n  artists: {\n    name: string;\n    artworks: {\n      name: string;\n      deathdate: string | null;\n      bio: string;\n    }[];\n  }[];\n}\n// artworks 부분을 수동으로 빼오면 out of sync할 위험성이 있다.\n// 0 첨자 접근은 반드시 있어야 하네\ntype InferredArtwork = ArtworkSearchResponse['artists'][0]['artworks'][0];\n```\n\n## Mapped Types\n\n> Mapped types are a way to create new types based on another type. Effectively a transformational type.\n\n```ts\ninterface Artist {\n  id: number;\n  name: string;\n  bio: string;\n}\n\ntype MyPartialType<Type> = {\n  [Property in keyof Type]?: Type[Property];\n} & { id: number };\n\ntype MappedArtistForEdit = MyPartialType<Artist>;\n\n// const artistForEdit: MappedArtistForEdit = {}\n// 'id' 속성이 '{}' 형식에 없지만 '{ id: number; }' 형식에서 필수입니다.\n```\n","path":"language/typescript/meta-types/index.md"}