{"pathArr":[],"metaData":{"title":"The TypeScript Handbook"},"content":"\n다음에서 발췌 TypeScript Handbook TypeScript Team and Open Source Contributors 이 자료는 저작권에 의해 보호됩니다.\n\n## The Basics\n\n> Step one in learning TypeScript: The basic types\n\nJavaScript only truly provides dynamic typing - running the code to see what happens.\n\nStatic types systems describe the shapes and behaviors of what our values will be when we run our programs.\n\n> tsc: Typescript compiler\n\nThe compiler tries to emit clean readable code that looks like something a person would write.\n\n```js\nfunction greet(person, date) {\n  console.log(`Hello ${person}, today is ${date}!`);\n}\ngreet('Brendan');\n// tsx hello.js\n// 에러가 나지만 js 파일이 생기기는 함\n// --noEmitOnError면 에러 있으면 파일을 만들지 않음.\nfunction greet(person, date) {\n  // --target es2015 옵션을 주면 concat을 사용 안함\n  console.log('Hello '.concat(person, ', today is ').concat(date, '!'));\n}\ngreet('Brendan');\n```\n\nOne of TypeScript's core values: much of the time, you will know better than TypeScript.\n\nIt's best not to add annotations when the type system would end up inferring the same type anyway.\n\n**Type annotations never change the runtime behavior of your program.**\n\n> This process of moving from a newer or \"higher\" version of ECMAScript down to an older or \"lower\" one is sometimes called downleveling. (기본값 ES3)\n\nstrict 세팅 관련되어 가장 눈에 띄는? 플래그로 noImplicitAny와 strictNullChecks가있다. 전자는 implicit하게 any로 추론된 변수에 에러를 뿜고, 후자는 원래는 그냥 대입 가능한 null/undefined의 체크를확실히 한다.\n\n[billion dollar mistake](https://www.youtube.com/watch?v=ybrQvs4x0Ps)\n\n## Everyday Types\n\n> The language primitives.\n\nString, Number, Boolean 대문자는 쓰기 말기.\n\nThe any type is useful when you don't want to write out a long type just to convince TypeScript that a particular line of code is okay.\n\n> Conceptual typing: 함수가 사용되는 맥락이 함수(패러미터)가 가져야 하는 타입을알려준다.\n\nWhen you read from an optional property, you'll have to check for undefined before using it.\n\n> A union type is a type formed from two or more other types, representing values that may be any one of those types. We refer to each of these types as the union's members.\n\n> A type alias is exactly that - a name for any type.\n\n```ts\ntype Point = {\n  x: number;\n  y: number;\n};\n```\n\nNote that aliases are only aliases - you cannot use type aliases to create different/distinct \"versions\" of the same type.\n\nAlmost all features of an interface are available in type, the key distinction is that a type cannot be re-opened to add new properties vs an interface which is always extendable.\n\nBy combining literals into unions, you can express a much more useful concept - for example, functions that only accept a certain set of known values.\n\n```\nconst req = { url: \"https://example.com\", method: \"GET\" };handleRequest(req.url, req.method); // 'string'을 \"GET\" | \"POST\"에 대입할 수 없음.\n\n// \"GET\" as \"GET\"으로 type assertion을 사용하거나,\n// as const를 붙여 객체 전체를 type literal로 변환할 수 있다.\n\n```\n\n[DeepReadonly](https://stackoverflow.com/questions/41879327/deepreadonly-object-typescript)\n\n## Narrowing\n\n> Understanding how TypeScript uses JavaScript knowledge to reduce the amount of type syntax in your projects.\n\n> It looks at these special checks (called type guards) and assignments, and the process of refining types to more specific types than declared is called narrowing.\n\n```ts\nBoolean('hello'); // type: boolean\n!!'Hello'; // type: true\n```\n\nTo define a user-defined type guard, we simply need to define a function whose return type is a type predicate:\n\n```ts\ntype Fish = { swim: () => void };\ntype Bird = { fly: () => void };\n\nfunction isFish(pet: Fish | Bird): pet is Fish {\n  return (pet as Fish).swim !== undefined;\n}\n```\n\n```js\nfunction isFish(pet) {\n  return pet.swim !== undefined;\n}\n```\n\n> When every type in a union contains a common property with literal types, TypeScript considers that to be a **discriminated union**, and can narrow out the members of the union.\n\n```ts\ninterface Circle {\n  kind: 'circle';\n  radius: number;\n}\n\ninterface Square {\n  kind: 'square';\n  sideLength: number;\n}\n\ntype Shape = Circle | Square;\n\nfunction getArea(shape: Shape) {\n  if (shape.kind === 'circle') {\n    // shape: Circle\n    return Math.PI * shape.radius ** 2;\n  }\n}\n```\n\n```js\nfunction getArea(shape) {\n  if (shape.kind === 'circle') {\n    // shape: Circle\n    return Math.PI * Math.pow(shape.radius, 2);\n  }\n}\n```\n\nThey’re good for representing any sort of messaging scheme in JavaScript, like when sending messages over the network (client/server communication), or encoding mutations in a state management framework.\n\nWhen narrowing, you can reduce the options of a union to a point where you have removed all possibilities and have nothing left. In those cases, TypeScript will use a never type to represent a state which shouldn’t exist.\n\nThe never type is assignable to every type; however, no type is assignable to never (except never itself). This means you can use narrowing and rely on never turning up to do exhaustive checking in a switch statement.\n\n```ts\nfunction getArea2(shape: Shape) {\n  switch (shape.kind) {\n    case 'circle':\n      return Math.PI * shape.radius ** 2;\n    case 'square':\n      return shape.sideLength ** 2;\n    default:\n      const _exhaustiveCheck: never = shape;\n      return _exhaustiveCheck;\n  }\n}\n\ninterface Triangle {\n  kind: 'triangle';\n  sideLength: number;\n}\n\n// type Shape = Circle | Square | Triangle;\n// 위와 같이 바꾸면 switch문에서 에러난다\n```\n\n## More on Functions\n\n> Learn about how Functions work in TypeScript.\n\n```ts\n// Call signiture\ntype DescribableFunction = {\n  description: string;\n  (someArg: number): boolean;\n};\n// Construct signiture\ntype SomeConstructor = {\n  new (s: string): SomeObject;\n};\n// Generics are used when we want to describe a correspondence between two values.\nfunction firstElement<Type>(arr: Type[]): Type | undefined {\n  return arr[0];\n}\n// Constraints\nfunction longest<Type extends { length: number }>(a: Type, b: Type) {\n  if (a.length >= b.length) {\n    return a;\n  } else {\n    return b;\n  }\n}\n```\n\n```ts\nfunction minimumLength<Type extends { length: number }>(\n  obj: Type,\n  minimum: number\n): Type {\n  if (obj.length >= minimum) {\n    return obj;\n  } else {\n    // 형식은 같지만 입력으로 받은 obj와 같은 종류인지를 보장할 수 없다.\n    // The problem is that the function promises to return the same kind of object as was passed in, not just some object matching the constraint.\n    return { length: minimum };\n}\n```\n\nRule: When possible, use the type parameter itself rather than constraining it Rule: Always use as few type parameters as possible Rule: If a type parameter only appears in one location, strongly reconsider if you actually need it\n\nWhen writing a function type for a callback, never write an optional parameter unless you intend to call the function without passing that argument. 어차피 패러미터 적은 함수가 많은 함수 자리에 무조건갈 수 있으니 그냥 정의하면? 된다.\n\n```ts\nfunction myForEach(arr: any[], callback: (arg: any, index?: number) => void) {\n  for (let i = 0; i < arr.length; i++) {\n    callback(arr[i], i);\n  }\n}\nmyForEach([1, 2, 3], (a, i) => {\n  console.log(i.toFixed()); // Object is possibly 'undefined'.\n});\n```\n\n```ts\nfunction makeDate(timestamp: number): Date;\nfunction makeDate(m: number, d: number, y: number): Date;\nfunction makeDate(mOrTimestamp: number, d?: number, y?: number): Date {\n  // function implementation with a compatible signature.\n  if (d !== undefined && y !== undefined) {\n    return new Date(y, mOrTimestamp, d);\n  } else {\n    return new Date(mOrTimestamp);\n  }\n}\nconst d1 = makeDate(12345678);\nconst d2 = makeDate(5, 5, 5);\n// const d3 = makeDate(1, 3); 안됨\n```\n\nAlways prefer parameters with union types instead of overloads when possible\n\nvoid is not the same as undefined.\n\nobject is not Object. Always use object!\n\nThe unknown type represents any value. This is similar to the any type, but is safer because it’s not legal to do anything with an unknown value.\n\n```ts\nfunction doSomething(f: Function) {\n  return f(1, 2, 3);\n}\n```\n\nThis is an untyped function call and is generally best avoided because of the unsafe any return type.\n\nIf you need to accept an arbitrary function but don’t intend to call it, the type () => void is generally safer.\n\n## Object Types\n\n> How TypeScript describes the shapes of Javascript objects.\n\nreadonly인 프로퍼티는 바꿀 수 없지만 객체같은건 totally immutable하지는 않다.\n\nTypeScript doesn’t factor in whether properties on two types are readonly when checking whether those types are compatible, so readonly properties can also change via aliasing.\n\n```ts\n// Index Signatures\ninterface StringArray {\n  [index: number]: string;\n}\n// 문자열과 숫자 둘 다 가능하지만, but the type returned from a numeric indexer must be a subtype of the type returned from the string indexer.\n```\n\nThe extends keyword on an interface allows us to effectively copy members from other named types, and add whatever new members we want.\n\nTypeScript provides another construct called intersection types that is mainly used to combine existing object types.\n\n[interface extend vs type intersection?](https://stackoverflow.com/questions/52681316/difference-between-extending-and-intersecting-interfaces-in-typescript)\n\nSince type aliases, unlike interfaces, can describe more than just object types, we can also use them to write other kinds of generic helper types.\n\n```ts\ntype OrNull<Type> = Type | null;\ntype OneOrMany<Type> = Type | Type[];\n```\n\nThe ReadonlyArray is a special type that describes arrays that shouldn’t be changed.\n\nWhen we see a function that consumes ReadonlyArrays, it tells us that we can pass any array into that function without worrying that it will change its contents.\n\n```ts\nlet x: readonly string[] = [];\nlet y: string[] = [];\n\nx = y;\ny = x;\n// The type 'readonly string[]' is 'readonly' and cannot be assigned to the mutable type 'string[]'.\n```\n\n> A tuple type is another sort of Array type that knows exactly how many elements it contains, and exactly which types it contains at specific positions.\n\nTuple types are useful in heavily convention-based APIs, where each element’s meaning is “obvious”. However, since not every user holds the same view of what’s obvious, it may be worth reconsidering whether using objects with descriptive property names may be better for your API.\n\nTuples can have optional properties\n\n## Type Manipulation\n\n### Creating Types from Types\n\n> An overview of the ways in which you can create more types from existing types.\n\n### Generics\n\n> Types which take paremeters.\n\n```ts\ninterface GenericIdentityFn {\n  <Type>(arg: Type): Type;\n}\n\nfunction identity<Type>(arg: Type): Type {\n  return arg;\n}\n\nlet myIdentity: GenericIdentityFn = identity;\n```\n\nUnderstanding when to put the type parameter directly on the call signature and when to put it on the interface itself will be helpful in describing what aspects of a type are generic.\n\nWhen working with classes, static members can not use the class’s type parameter.\n\nYou can declare a type parameter that is constrained by another type parameter.\n\n```ts\nfunction getProperty<Type, Key extends keyof Type>(obj: Type, key: Key) {\n  return obj[key];\n}\n\nlet x = { a: 1, b: 2, c: 3, d: 4 };\n\ngetProperty(x, 'a');\n```\n\n아래는 제너릭에서 클래스 타입을 사용하는 방법. mixin 디자인 패턴에서 사용된다.\n\n```ts\nfunction create<Type>(c: { new (): Type }): Type {\n  return new c();\n}\n```\n\n### Keyof Type Operator\n\nThe keyof operator takes an object type and produces a string or numeric literal union of its keys.\n\n### Typeof Type Operator\n\n여러 predefined type이 있다.\n\n```ts\ntype Predicate = (x: unknown) => boolean;\ntype K = ReturnType<Predicate>;\n```\n\n### Indexed Access Types\n\nWe can use an indexed access type to look up a specific property on another type.\n\n```ts\ntype Person = { age: number; name: string; alive: boolean };\ntype Age = Person['age'];\n```\n\n### Conditional Types\n\n> Types which act like if statements in the type system\n\nThe power of conditional types comes from using them with generics.\n\n```ts\ninterface IdLabel {\n  id: number /* some fields */;\n}\ninterface NameLabel {\n  name: string /* other fields */;\n}\n\nfunction createLabel(id: number): IdLabel;\nfunction createLabel(name: string): NameLabel;\nfunction createLabel(nameOrId: string | number): IdLabel | NameLabel;\nfunction createLabel(nameOrId: string | number): IdLabel | NameLabel {\n  throw 'unimplemented';\n}\n```\n\n```ts\ntype NameOrId<T extends number | string> = T extends number ? IdLabel : NameLabel;\n\nfunction createLabel<T extends number | string>(idOrName: T): NameOrId<T> {\n  throw 'unimplemented';\n}\n```\n\n### Mapped Types\n\n> Creating types by mapping each property in an existing type\n\n### Template Literal Types\n\n> Mapped types which change properties via template literal strings\n\n## Classes\n\n## Modules\n","path":"language/typescript/handbook/index.md"}