{"pathArr":[],"metaData":{"title":"Language Extensions"},"content":"\n## Enums\n\n```ts\nenum StatusCodes {\n  OK = 200,\n  BadRequest = 400,\n  Unauthorized,\n  PaymentRequired,\n  Forbidden,\n  NotFound,\n}\n\nconst okNumber = StatusCodes.OK;\nconst stringBadRequest = StatusCodes[400]; // BadRequest\n\n// A const enum's value is replaced by TypeScript during\n// transpilation of your code, instead of being looked up\n// via an object at runtime.\n\nconst enum MouseAction {\n  MouseDown,\n  MouseUpOutside,\n  MouseUpInside,\n}\n```\n\n## Nominal Typing\n\nStructural Typing은 단점이 있다. For example there are cases where a string or number can have special context and you don't want to ever make the values transferrable. For example:\n\n- User Input Strings (unsafe)\n- Translation Strings\n- User Identification Numbers\n- Access Tokens\n\n```ts\n// __brand는 관례\ntype ValidatedInputString = string & { __brand: 'User Input Post Validation' };\n\n// We're just _telling_ TypeScript that it's true.\nconst validateUserInput = (input: string) => {\n  const simpleValidatedInput = input.replace(/\\</g, '≤');\n  return simpleValidatedInput as ValidatedInputString;\n};\n\nconst printName = (name: ValidatedInputString) => {\n  console.log(name);\n};\n\nconst input = \"alert('bobby tables')\";\nconst validatedInput = validateUserInput(input);\nprintName(validatedInput);\n```\n\n## Types vs Interfaces\n\nThat said, we recommend you use interfaces over type aliases. Specifically, because you will get better error messages.\n\nOne major difference between type aliases vs interfaces are that interfaces are open and type aliases are closed. This means you can extend an interface by declaring it a second time.\n\n[Interfaces vs Types](https://stackoverflow.com/questions/37233735/interfaces-vs-types-in-typescript/52682220#52682220)\n","path":"language/typescript/language-extensions/index.md"}