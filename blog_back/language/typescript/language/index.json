{"pathArr":[],"metaData":{"title":"Language"},"content":"\n## Soundness\n\n> Soundness is the idea that the compiler can make guarantees about the type a value has at runtime, and not just during compilation.\n\nSimplicity, Usability and Soundness에서 타입스크립트는 모든 JS 코드를 수용하기위해 Soundness에서 타협함.\n\n```ts\n// Type Assertion은 개발자에게 모든 것을 맡긴다.\nconst usersAge = '23' as any as number;\nconsole.log(typeof usersAge); // string\n\n// Function Parameter Bi-variance\n// 여기는 무슨 소린지 모르겠어서 나중에 다시 보기\n\n// Rest parameters are assumed to all be optional\n\n// Void Functions Can Match to a Function With a Return Value\n```\n\n## Structural Typing\n\nTypeScript is a Structural Type System.\n\n> A structural type system means that when comparing types, TypeScript only takes into account the members on the type.\n\n> This is in contrast to nominal type systems, where you could create two types but could not assign them to each other.\n\n```ts\nlet createBall = (diameter: number) => ({ diameter });\nlet createSphere = (diameter: number, useInches: boolean) => {\n  return { diameter: useInches ? diameter * 0.39 : diameter };\n};\n\ncreateSphere = createBall;\n// createBall = createSphere; 할당 불가\n\n// TypeScript will discard the boolean in the first assignment because it's very common for JavaScript code to skip passing params when they're not needed.\n\n// 리턴 타입도 유사한 규칙이 적용\nlet createRedBall = (diameter: number) => ({ diameter, color: 'red' });\n\ncreateBall = createRedBall;\n// createRedBall = createBall; 할당 불가\n```\n\n## Type Guards\n\n> Type Guarding is the term where you influence the code flow analysis via code.\n\n> A type predicate function is a function where the return type offers information to the code flow analysis when the function returns true.\n\n```ts\ninterface A {\n  aProp: string;\n}\ninterface B {\n  bProp: string;\n}\ntype AorB = A | B;\n\ndeclare function getAorB(): AorB;\nconst aOrB = getAorB();\n\nfunction notTypePredicateFunction(aOrB: AorB): boolean {\n  return 'aProp' in aOrB;\n}\nif (notTypePredicateFunction(aOrB)) {\n  // console.log(aOrB.aProp); 에러\n}\n\nfunction typePredicateFunction(aOrB: AorB): aOrB is A {\n  return 'aProp' in aOrB;\n}\nif (typePredicateFunction(aOrB)) {\n  console.log(aOrB.aProp);\n}\n```\n\n## Type Widening and Narrowing\n\n> Widening and Narrowing types is about expanding and reducing the possibilities which a type could represent.\n","path":"language/typescript/language/index.md"}