{"pathArr":[],"metaData":{"title":"Javascript"},"content":"\n## 모던 자바스크립트 Deep Dive\n\n[yes24](http://www.yes24.com/Product/Goods/92742567) [교보](http://www.kyobobook.co.kr/product/detailViewKor.laf?mallGb=KOR&ejkGb=KOR&barcode=9791158392239)\n\n## 1. 프로그래밍\n\n### 3. 구문과 의미\n\n```js\nconst number = 'string';\nconsole.log(number * number);\n```\n\n문법적(syntax)으로 문제가 없지만 의미적(semantics)으로는 옳지 않다. 언어와 마찬가지로 코드는 문법에맞는 문장을 구성하고 의미를 가져야한다.\n\n> 결국 프로그래밍은 요구사항의 집합을 분석해서 적절한 자료구조와 함수의 집합으로변환한 후, 그 흐름을제어하는 것이다.\n\n## 2. 자바스크립트란?\n\n### 3. 자바스크립트 성장의 역사\n\n**Ajax**는 XMLHttpRequest라는 이름으로 등장, 서버와 브라우저가 비동기로 데이터를교환할 수 있다. 기존에는 화면 전환시 전체를 렌더링하기에 깜빡거렸다. Ajax 이후에는 필요한 부분만 렌더링하는 방식이 가능해졌다.\n\n**jQuery**는 DOM을 쉽게 제어할 수 있게 했고 크로스 브라우징 이슈를 어느정도 해결했다.\n\n구글의 **V8 자바스크립트 엔진**으로 서버의 몇몇 로직이 클라이언트로 이동하여 프론트엔드가 주목받았다 .\n\n**Node.js**는 자바스크립트를 브라우저 이외의 환경에서도 동작하게하며, 서버 개발에 주로 사용되며 이에필요한 모듈, 파일 시스템, HTTP등 빌트인 API를 제공한다. 비동기 I/O를 지원하며 단일 스레드 이벤트 루프 기반으로 동작해 request 처리 성능이좋다. 이에 I/O가 빈번한 SPA에 적합하며 CPU 사용률이 높은 부분에는 권장하지 않는다.\n\n이후 복잡해진 개발 과정에 대응하기 위해 패턴과 라이브러리가 출현했지만, 리액트와같은 프레임워크가 등장했다.\n\n### 4. 자바스크립트와 ECMAScript\n\n자바스크립트는 core인 ECMAScript와 브라우저가 별도 지원하는 클라이언트 사이즈 Web API(DOM, BOM, Canvas, XMLHttpRequest, fetch, requestAnimationFrame...)등을아우르는 개념이다.\n\n클라이언트사이즈는 ECMAScript와는 별개로 W3C에서 별도의 사양으로 관리하고 있다.\n\n### 5. 자바스크립트의 특징\n\n웹 브라우저에서 동작하는 유일한 프로그래밍 언어이다. 인터프리터 언어. 명령형, 함수형, 프로토타입 기반 객체지향 프로그래밍을 지원하는 멀티 패러다임 프로그래밍 언어.\n\n## 3. 자바스크립트 개발 환경과 실행 방법\n\n### 3. Node.js\n\n> npm(node package manager)은 자바스크립트 패키지 매니저이다. Node.js에서 사용할수 있는 모듈들을 패키지화해서 모아둔 저장소 역할과 패키지 설치 및 관리를 위한 CLI를 제공한다.\n\n## 4. 변수\n\n변수에 저장된 값을 읽어들이는 것을 **참조**(reference)라 한다.\n\n변수 이름을 **식별자**(identifier)라고도 한다.\n\n### 3. 변수 선언\n\n**변수 선언**(declaration)이란 값을 저장하기 위한 메모리 공간을 확보(allocate)하고 변수 이름과 확보된 메모리 공간의 주소를 연결(name binding)해서 값을 저장할 수있게 준비하는 것이다.\n\nES6은 ES5의 superset이다.\n\n**키워드**란 자바스크립트 엔진이 수행할 동작을 규정한 일종의 명령어다.\n\n자바스크립트 엔진은 변수 선언을 선언 단계와 초기화 단계 2단계에 걸쳐 수행한다.\n\n**실행 컨텍스트**는 자바스크립트 엔진이 소스코드를 평가하고 실행하기 위해 필요한환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역이다. 자바스크립트 엔진은실행 컨텍스트를 통해 식별자와 스코프를관리한다.\n\n**초기화**(initialization)란 변수가 선언된 이후 최초로 값을 할당하는 것을 말한다 .\n\n### 4. 변수 선언의 실행 시점과 변수 호이스팅\n\n자바스크립트에서 변수, 함수, 클래스등의 식별자는 호이스팅되어 런타임 단계에서 선언문들이(할당문 x) 먼저 실행된다.\n\n```js\nconsole.log(x); // undefined\nconsole.log(f);\n// console.log(f()); TypeError: f is not a function\n\nvar x = 10;\nvar f = () => {\n  return 20;\n};\n\nconsole.log(x); // 10\nconsole.log(f); // [Function: f]\nconsole.log(f()); // 20\n```\n\n### 5. 값의 할당\n\n> 변수 선언은 런타임 이전에 먼저 실행되지만 값의 할당은 런타임에 실행된다.\n\n```js\nconsole.log(x); // undefined\nx = 10;\nvar x;\nconsole.log(x); // 10\n```\n\n### 6. 값의 재할당\n\n변수에 값을 재할당하면 기존 공간을 지우고 그 메모리 공간에 새롭게 저장하는 것이아니라 새로운 메모리공간을 확보하고 그곳에 값을 저장한다.\n\n**Unmanaged language / Managed language**는 저수준 메모리 제어 기능의 유무로 구분된다.\n\n### 7. 식별자 네이밍 규칙\n\n특수문자를 제외한 문자, 숫자, 언더스코어, 달러 기호를 포함할 수 있으며, 숫자로시작할 수 없으며, 예약어는 사용할 수 없다.\n\n```js\nvar async = 10;\nconsole.log(async);\n\n// var first-name = \"Hello\"; // SyntaxError: Unexpected token '-'\n\nvar camelCase;\nvar snake_case;\nvar PascalCase;\n\nvar typeHungarianCase;\nvar strFirstName;\nvar $elem = document.getElementById('myId'); //DOM 노드\nvar observable$ = fromEvent(document, 'click'); // RxJS observable\n```\n\n## 5. 표현식과 문\n\n### 1. 값\n\n> 값(value)은 표현식(expression)이 평가(evaluation)되어 생성된 결과이다.\n\n> 변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을식별하기 위해 붙인이름이다.\n\n### 2. 리터럴\n\n> **리터럴**(literal)은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법을말한다. JS 엔진은 런타임에 리터럴을 평가해 값을 생성한다.\n\n```js\nconsole.log(0b11); // 3\nconsole.log(0o11); // 9\nconsole.log(0x11); // 17\nconsole.log(/[A-Z]+/g);\n```\n\n### 3. 표현식\n\n> **표현식**(expression)은 값으로 평가될 수 있는 문(statement)이다.\n\n> 식별자 참조는 값을 생성하지는 않지만 값으로 평가되므로 표현식이다.\n\n리터럴 표현식, 식별자 표현식, 연산자 표현식, 함수/메서드 호출 표현식...\n\n문법적으로 값이 위치할 수 있는 자리에는 표현식도 위치할 수 있다.\n\n### 4. 문\n\n> **문**(statement)은 프로그램을 구성하는 기본 단위이자 최소 실행 단위이다.\n\n> **토큰**이란 문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소를 의미한다.\n\n```js\n// 변수 선언문\nvar x;\n// 할당문\nx = 5;\n// 함수 선언문\nfunction foo() {}\n// 조건문\nif (x > 1) {\n  console.log(x);\n}\n// 반복문\nfor (var i = 0; i < 2; i++) {\n  console.log(i);\n}\n```\n\n### 5. 세미콜론과 세미콜론 자동 삽입 기능\n\n문을 끝낼 때에는 세미콜론을 붙여야 한다.\n\n코드 블록은 self closing의 성격을 가지기 때문에 세미콜론을 뒤에 붙이지 않아도 좋다.\n\nASI(Automatic semicolon insertion)으로 인해 사실 세미콜론을 붙이지 않아도 되긴한다.\n\n```js\n/* ASI가 실패하는 경우들 */\n\nfunction foo() {\n  return;\n  {\n  }\n}\nconsole.log(foo()); // undefined\n\nvar bar = (function () {})(function () {})(); // TypeError: (intermediate value)(...) is not a function\n```\n\n### 6. 표현식인 문과 표현식이 아닌 문\n\n```js\nvar x;\n// 할당문은 표현식인 문이다.\nconsole.log((x = 10)); // 10\nconsole.log(x); // 10\n```\n\n## 6. 데이터 타입\n\n**원시 타입**(primitive type): number, string, boolean, undefined, null, Symbol\n\n**객체 타입**(object/reference type): 객체, 함수, 배열\n\n```js\n// ECMAScript2020(ES11)\nconsole.log(2 ** 100); // 1.2676506002282294e+30\nconsole.log(BigInt(2 ** 100)); // 1267650600228229401496703205376n\n// console.log(10n + 1); // TypeError: Cannot mix BigInt and other types, use explicit conversions\nconsole.log(10n + 1n);\n```\n\n### 1. 숫자 타입\n\n```js\n// 진수별 데이터 타입이 없기에 모두 10진수로 해석된다.\n// 모두 double precision 64bit floating point binary data\nconsole.log(1 === 1.0); // true\nconsole.log(3 / 2); // 1.5\n// number 타입의 세가지 특별한 값\nconsole.log(1 / 0); // Infinity\nconsole.log(1 / -0); // -Infinity\nconsole.log(1 * 'Hello'); // NaN\n```\n\n### 2. 문자열 타입\n\n> 0개 이상의 16비트 유니코드 문자(UTF-16)의 집합\n\n일반적으로 작음따옴표를 사용.\n\n배열인 C와 객체인 Java와 다르게 JS에서 문자열은 원시 타입이며 immutable하다.\n\n### 3. 템플릿 리터럴\n\nES6부터 추가된 새로운 문자열 표기법. 백틱(`)을 사용하며 multiline string, expression interpolation, tagged template등의 기능을 제공한다. [참고](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Template_literals)\n\n```js\n// Escape seqeunce는 백슬래시로 시작하는 이것저것\n\nconsole.log('One\\vTwo\\vThree');\n// One\n//    Two\n//       Three\n\nconsole.log('\\u{1F600}');\n// 😀\n```\n\n\\n은 LF(Line Feed), \\r은 CR(Carriage Return). 과거 타자기에서 전자는 종이를 한줄올리고 후자는 커서를맨 앞줄로 이동시켰다. 요즘은 기능은 같지만 전자를 사용한다.\n\n```js\nconsole.log(`<li>\n    <p>Hello, World!</p>\n</li>`);\n/* <li>\n    <p>Hello, World!</p>\n</li> */\nconsole.log(`\na`);\n/*\n\na\n*/\nconsole.log(`\na\n`);\n/*\n\na\n\n*/\n```\n\n> \\+ 연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작한다.\n\n### 5. undefined 타입\n\nundefined 타입의 값은 undefined가 유일하다.\n\n> 자바스크립트 엔진이 변수를 초기화하는데 사용하는 undefined를 개발자가 의도적으로 변수에 할당한다면 undefined의 본래 취지와 어긋날뿐더러 혼란을 줄 수 있으므로 권장하지 않는다. ... 대신에 null을 사용\n\n> 자바스크립트에서는 변수를 선언하면 암묵적으로 정의가 이뤄지기 때문에 선언과 정의의 구분이 모호하다 . ... ECMAScript 사양을 따라 변수는 선언하고 함수는 정의한다고 표현하자.\n\n### 6. null 타입\n\nnull타입의 값은 null이 유일하다. 변수 값의 의도적 부재(intentional absence)를 명시할 때 사용한다. 함수가 유효한 값을 반환할 수 없는 경우 명시적으로 null을 반환하기도 한다.\n\n### 9. 데이터 타입의 필요성\n\n> 컴파일러 또는 인터프리터는 **심벌 테이블**이라고 부르는 자료 구조를 통해 식별자를 키로 바인딩된 값의 메모리 주소, 데이터 타입, 스코프 등을 관리한다.\n\n> 자바스크립트에서의 변수는 선언이 아닌 할당에 의해 타입이 결정(type inference) 된다. 그리고 재할당에 의해 변수의 타입은 바뀔 수 있다(dynamic typing).\n\n## 7. 연산자\n\n> 피연산자가 '값'이라는 명사의 역할을 한다면 연산자는 '피연산자를 연산하여 새로운 값을 만들다'라는동사의 역할을 한다고 볼 수 있다.\n\n### 1. 산술 연산자\n\n**implicit coersion, type coercion**\n\n```js\nvar x = '12';\nconsole.log(+x); // 12\nconsole.log(-x); // -12\nx = 'hello';\nconsole.log(+x); // NaN\nx = true;\nconsole.log(+x); // 1\n```\n\n```js\nconsole.log('abc' + 12); // abc12\n```\n\n### 2. 할당 연산자\n\n```js\nvar a, b, c;\na = b = c = 10;\nconsole.log('result: ' + a + b + c); // result: 101010\n```\n\n### 3. 비교 연산자\n\n**동등 비교**(loose equality) 연산자는 암묵적 타입 변환을 통해 타입을 일치시킨후비교한다.\n\n```js\nconsole.log(5 == '5'); // true\nconsole.log('0' == ''); // false\nconsole.log(0 == ''); // true\nconsole.log(0 == '0'); // true\nconsole.log(false == 'false'); // false\nconsole.log(false == '0'); // true\nconsole.log(false == null); // false\nconsole.log(false == undefined); // false\n```\n\n**일치 비교**(strict equality) 연산자는 타입또한 비교한다.\n\n```js\nconsole.log(NaN == NaN); // false\nconsole.log(Number.isNaN(NaN)); // true\nconsole.log(Number.isNaN(1 + undefined)); // true\n// ES6\nconsole.log(Object.is(0, -0)); // false\nconsole.log(Object.is(NaN, NaN)); // true\n```\n\n### 6. 쉼표 연산자\n\n> 왼쪽 피연산자부터 차례대로 평가하고 마지막 평가 결과를 반환한다.\n\n```js\nconsole.log(NaN == NaN); // false\nconsole.log(Number.isNaN(NaN)); // true\nconsole.log(Number.isNaN(1 + undefined)); // true\n// ES6\nconsole.log(Object.is(0, -0)); // false\nconsole.log(Object.is(NaN, NaN)); // true\n```\n\n### 7. typeof 연산자\n\n```js\nconsole.log(typeof null); // object\nconsole.log(typeof 가나다); // undefined\n\nconsole.log(typeof function () {}); // function\nconsole.log(typeof /abc/); // object\nconsole.log(typeof Symbol()); // symbol\nconsole.log(typeof []); // object\n```\n\n### 11. 연산자의 부수 효과\n\n> 부수 효과가 있는 연산자는 =, ++/--, delete 연산자다.\n\n### 13. 연산자 결합 순서\n\n> 연산자의 어느 쪽(좌항 또는 우항)부터 평가를 수행할 것인지\n\n## 8. 제어문\n\n> 고차함수를 사용한 함수형 프로그래밍 기법에서는 제어문의 사용을 억제하여 복잡성을 해결하려고 노력한다.\n\n### 1. 블록문\n\n> 0개 이상의 문을 중괄호로 묶은 것으로, 코드 블록 또는 블록이라고 부르기도 한다.\n\n### 2. 조건문\n\nswitch문에서 default문은 선택사항. if/else문은 논리적 참, 거짓으로 실행할 코드블록을 결정하고, switch문은 다양한 상황(case)에 따라 결정한다. break문이 없으면 case문의 실행 흐름이 다음으로 넘어간다.\n\n```js\nvar value = '10';\n\nswitch (value) {\n  case true:\n    console.log('bool');\n    break;\n  case '10':\n    console.log('string');\n    break;\n  case 10:\n    console.log('number');\n    break;\n}\n// string\n```\n\nfor문은 반복 횟수가 명확할 때 사용하고, while문은 불명확할 때 사용한다.\n\n### 4. break문\n\n```js\nfoo: {\n  console.log('start');\n  break foo;\n  console.log('end');\n}\n```\n\n## 9. 타입 변환과 단축 평가\n\n명시적 타입 변환(explicit coercion) / 타입 캐스팅(type casting)\n\n암묵적 타입 변환(implicit coercion) / 타입 강제 변환(type coercion)\n\n위 두 타입 변환이 기존 원시 값을 변경하는 것은 아니다. 원시 값은 변경 불가능한값 (immutable value)이므로 변경할 수 없다.\n\n### 2. 암묵적 타입 변환\n\n```js\nconst printAll = (arr) => arr.forEach((x) => console.log(x));\n\nprintAll([\n  '문자열 타입으로 변환',\n  // 피연산자 중 하나 이상이 문자열이면 문자열 연결 연산자로 동작\n  1 + '2',\n  0 + '',\n  -0 + '',\n  -1 + '',\n  NaN + '',\n  -Infinity + '',\n  true + '',\n  null + '',\n  undefined + '',\n  // Symbol() + '', TypeError: Cannot convert a Symbol value to a string\n  Math + '', // [object Math]\n  Array + '', // function Array() { [native code] }\n  printAll + '', // arr => arr.forEach(x => console.log(x))\n  [1, 2].forEach, // [Function: forEach]\n\n  '숫자 타입으로 변환',\n  +'',\n  +'1',\n  +'hello',\n  +true,\n  +false,\n  +null,\n  +undefined,\n  // +Symbol(), TypeError: Cannot convert a Symbol value to a number\n  +{},\n  +[],\n  +[0], // 0??\n  +[3], // 3???\n  +[0, 1], // NaN????\n  +printAll, // NaN\n\n  '불리언 타입으로 변환',\n  !false,\n  !undefined,\n  !null,\n  !0,\n  !-0,\n  !NaN,\n  !'',\n  // 이외는 전부 true로 평가되는 Truty값\n]);\n```\n\n### 3. 명시적 타입 변환\n\n- 표준 빌트인 생성자 함수를 new 연산자 없이 호출\n- 빌트인 메서드 사용\n- 암묵적 타입 변환 이용\n\n```js\nconst printAll = (arr) => arr.forEach((x) => console.log(x));\n\nprintAll([\n  '문자열 타입으로 변환',\n  String(1),\n  String(NaN),\n\n  (-Infinity).toString(),\n  printAll.toString(),\n\n  1 + '',\n  true + '',\n\n  '숫자 타입으로 변환',\n  Number('hello'), // NaN\n\n  Number(true),\n  Number(false),\n\n  parseInt('-1'),\n\n  +'0',\n  +'3.14',\n\n  '123' * 1,\n  false * 1,\n\n  '불리언 타입으로 변환',\n  Boolean('hello'),\n  Boolean(0),\n  !![],\n  !!{},\n  !![1, 2],\n]);\n```\n\n### 4. 단축 평가\n\n> 논리합 또는 논리곱 연산자는 전에나 2개의 피연산자 중 어느 한쪽으로 평가된다.\n\n```js\nconsole.log('' && 'Hello'); // ''\nconsole.log(false && 'Hello'); // false\nconsole.log('' || 'Hello'); // Hello\nconsole.log('Hello' || false); // Hello\n\n// 객체의 존재를 확인하고 프로퍼티 참조\nvar object = null;\nvar value = object && object.value;\n\nvar emptyStr = '';\nconsole.log(emptyStr && emptyStr.length);\nconsole.log(emptyStr?.length);\n```\n\n위 방법은 0이나 ''가 Falsy값이기 때문에 이를 그대로 반환하지만, 이들은 객체일 수있기 때문에 아래의옵셔널 체이닝 방법이 낫다.\n\n```js\nvar object = null;\nconsole.log(object?.property);\n// console.log(object.property);\n// TypeError: Cannot read properties of null (reading 'property')\n```\n\nnull 병합 연산자(nullish coalescing) 연산자도 바찬가지로 ||를 사용할 단축 평가로대체할 수 있지만 Falsy값인 0과 ''도 유효한 기본값이라면 문제를 일으킬 수 있다.\n\n## 10. 객체 리터럴\n\n### 1. 객체란?\n\n원시 값을 제외한 나머지 값은 모두 객체다. 원시 값은 immutable value지만 객체는 mutable value이다.\n\n> 함수로 객체를 생성하기도 하며 함수 자체가 객체이기도 한다. 자바스크립트에서 함수와 객체는 분리해서생각할 수 없는 개념이다.\n\n### 2. 객체 리터럴에 의한 객체 생성\n\n> 객체 리터럴의 중괄호는 코드 블록을 의미하지 않는다는 데 주의하자. ... 따라서객체 리터럴의 닫는 중괄호 뒤에는 세미콜론을 붙인다.\n\n### 3. 프로퍼티\n\n프로퍼티 키에는 모든 문자열 또는 심벌 값이 사용될 수 있고, 프로퍼티 값으로는 모든 값이 가능하다.\n\n식별자 네이밍 규칙을 따르지 않는 키에는 반드시 따옴표를 사용해야 한다.\n\n```js\nconsole.log({ '': 'Hello' }['']);\nconsole.log({ a: 'A', a: 'B' }.a);\n```\n\n### 9. ES6에서 추가된 객체 리터럴의 확장 기능\n\n```js\n// property shorthand\nlet name = '이성열',\n  age = 24;\nconsole.log({ name, age }); // { name: '이성열', age: 24 }\n\n// computed property name\n// ES6에서는 객체 리터럴 내부에서도 계산된 프로퍼티 이름으로 프로퍼티 키를 동적 생성할 수 있다.\nconst id = 'ID';\nlet num = 0;\nconst obj = {\n  [`${id}-${num++}`]: num,\n  [`${id}-${num++}`]: num,\n  [`${id}-${num++}`]: num,\n};\nconsole.log(obj); // { 'ID-0': 1, 'ID-1': 2, 'ID-2': 3 }\n\n// 메서드 축약 표현\nconst obj2 = {\n  print: function () {\n    console.log('Hello');\n  },\n};\nobj2.print();\n```\n\n## 11. 원시 값과 객체의 비교\n\n- 원시값은 immutable, 객체는 mutable\n- 원시값이 할당된 변수에는 실제 값이 저장되고, 객체가 할당된 변수에는 참조값이저장된다.\n- 다른 변수에 할당시 원시 값은 복사되고(pass by value), 객체는 참조 값이 복사되어 전달된다(pass by reference).\n\n### 1. 원시 값\n\n한번 생성된 원시 값은 read only로 변경할 수 없다.\n\n원시 값을 할당한 변수에 다른 값을 재할당하면 새로운 메모리 공간을 확보하고 변수가 이곳을 가르키게 된다.\n\n> 원시 값을 할당한 변수는 재할당 이외에 변수 값을 변경할 수 있는 방법이 없다.\n\n근데 immutable하다고 같은 메모리 주소에 머물러야한다는건 아니지 않나??? 재할당안하고 그자리에서 바꾸는건 왜 안됨? 어차피 복사라서 상태 변경을 걱정할 필요는 없지않나.\n\n그림에서는 메모리 주소로 표현했는데 실제로는 레지스터고 암튼 설명용일 수 있으니일단 넘어가자.\n\n암튼 변수가 원시 값을 가리키는 한 변수를 재할당하지 않는 이상 그 변수 값이 유지될 것임이 보장된다.\n\n문자열도 원시값이므로 변경할 수 없다.\n\n```js\nvar str = 'string';\nstr[3] = 'o';\nconsole.log(str);\n```\n\n> 참고로 '값에 의한 전달'이라는 용어는 자바스크립트를 위한 용어가 아니므로 사실오해가 있을 수도 있다 . \\*\\*엄격하게 표현하면 변수에는 값이 전달되는 것이 아니라 메모리 주소가 전달되기 때문이다. 이는변수와 같은 식별자는 값이 아니라 메모리 주소를 기억하고 있기 때문이다.\n\n### 2. 객체\n\n객체는 원시 값과 같이 확보해야 할 메모리 공간의 크기를 사전에 정해 둘 수 없다.\n\n> 자바스크립트 객체는 프로퍼티 키를 인덱스로 사용하는 해시 테이블(연관 배열, map, dictionary, looup table)이라고 생각할 수 있다.\n\n클래스 기반 언어는 프로퍼티/메서드가 정해져 있지만 자바스크립트는 동적으로 변할수 있으므로 비효율적이다. 이에 V8 엔진에서는 동적 탐색(dynamic lookup) 대신 히든클래스(hidden class)라는 방식을 사용해성능을 높인다. (147p 참고)\n\n객체를 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 참조 값 (reference value)에접근할 수 있다. 참조값이 객체가 저장된 메모리 공간의 주소이다.\n\n왜 한번에 객체로 안가게 했지??\n\n[Understanding JavaScript Pass-By-Value](https://www.javascripttutorial.net/javascript-pass-by-value/) [Does javascript pass by reference?](https://stackoverflow.com/a/13104528) [Evaluation strategy](https://en.wikipedia.org/wiki/Evaluation_strategy)\n\n나중에 한번 더 정리해보면 좋을 듯.\n\n## 12. 함수\n\n### 1. 함수란?\n\n> 함수는 일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로정의한 것이다.\n\n매개변수(parameter), 인수(argument), 반환값(return value)\n\n### 3. 함수 리터럴\n\n함수 리터럴에서 함수 이름은 생략 가능하며, 만약 있다면 함수 몸체 내에서만 참조할수 있는 식별자이다.\n\n함수는 객체이며 일반 객체와 다르게 호출할 수 있다.\n\n### 4. 함수 정의\n\n**함수 선언문**\n\n함수 선언문은 표현식이 아닌 문이다. 다만 함수 이름이 있는 기명 함수 리터럴은 함수 선언문 또는 함수리터럴 표현식으로 해석될 가능성이 있다.\n\n```js\n// 그룹 연산자의 피연산자는 값으로 평가될 수 있는 표현식이어야 한다.\n(function bar() {\n  console.log('bar');\n});\n// bar(); ReferenceError: bar is not defined\n```\n\n> 자바스크립트 엔진은 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고, 거기에 함수 객체를 할당한다.\n\n> 자바스크립트의 함수는 일급 객체다.\n\n```js\nconsole.log(add); // [Function: add]\nconsole.log(sub); // undefined\n\nfunction add(x, y) {\n  return x + y;\n}\n\nvar sub = function (x, y) {\n  return x - y;\n};\n```\n\n> 함수 표현식으로 함수를 정의하면 함수 호이스팅이 발생하는 것이 아니라 변수 호이스팅이 발생한다.\n\n```js\n// Function 생성자 함수를 사용한 방식은 일반적이지 않고 바람직하지도 않다.\n// 클로저를 생성하지 않는 등 함수 선언문/표현식으로 생성한 함수와 다르다.\nvar add1 = (function () {\n  var a = 10;\n  return function (x, y) {\n    return x + y + a;\n  };\n})();\n\nvar add2 = (function () {\n  var a = 10;\n  return new Function('x', 'y', 'return x + y + a');\n})();\n\nconsole.log(add1(1, 2)); // 3\nconsole.log(add2(1, 2)); // ReferenceError: a is not defined\n```\n\n### 5. 함수 호출\n\n매개변수(parameter, 인자)를 통해 인수(argument)를 전달한다.\n\n```js\nfunction foo(x, y) {\n  console.log(x, y);\n  return x + y;\n}\n\nconsole.log(foo(1)); // 1 undefined, NaN\n\nfunction add(x, y) {\n  console.log(arguments);\n  return x + y;\n}\n\nadd(2, 5, 10); // [Arguments] { '0': 2, '1': 5, '2': 10 }\n```\n\n> 매개변수는 최대 3개 이상을 넘지 않는 것을 권장한다. 만약 그 이상의 매개변수가필요하다면 하나의 매개변수를 선언하고 객체를 인수로 전달하는 것이 유리하다.\n\n> 객체의 상태 변경을 원천봉쇄하고 객체의 상태 변경이 필요한 경우에는 객체의 방어적 복사(defensive copy)를 통해 원본 객체를 완전히 복제, 즉 깊은 복사(deep copy)를 통해 새로운 객체를 생성하고 재할당을 통해 교체한다.\n\n### 7. 다양한 함수의 형태\n\n즉시 실행 함수(IFE, Immediately Invoked Function Expression)\n\n> 일반적으로 중첩 함수는 외부 함수를 돕는 헬퍼 함수(helper function) 역할을 한다 .\n\n> 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 콜백 함수(callback function)라고 하며, 매개변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수를 고차 함수(higher-order function, HOF) 라고 한다.\n\n> 함수형 프로그래밍은 순수 함수와 보조 함수의 조합을 통해 외부 상태를 변경하는부수 효과를 최소화해서불변성 immutability 을 지향하는 프로그래밍 패러다임이다 . 로직 내에 존재하는 조건문과 반복문을 제거해서 복잡 성을 해결하며, 변수 사용을억제하거나 생명주기를 최소화해서 상태 변경을 피해 오류를 최소화하는 것을 목표로 한다. 조건문이나 반복문은 로직의 흐름을 이해하기 어렵게 해서 가독성을 해치고, 변수의 값은 누군 가에 의해 언제든지 변경될 수 있어 오류 발생의 근본적 원인이 될 수 있기 때문이다.\n\n## 13. 스코프\n\n### 1. 스코프란?\n\n> 스코프는 식별자가 유효한 범위, 혹은 식별자를 검색할 때 사용하는 규칙을 말한다.\n\n191p. 하나의 값은 유일한 식별자에 연결되어야 한다? pass by reference는 예외인건가? 여기서 값은 객체타입은 제외한건가.\n\nvar 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언이 허용된다.\n\n### 2. 스코프의 종류\n\n> 지역이란 함수 몸체 내부를 말한다.\n\n### 3. 스코프 체인\n\n함수 몸체 내부에서 정의한 함수를 **중첩 함수(nested function)**, 중첩 함수를 포함하는 함수를 **외부함수(outer function)**라고 한다.\n\n스코프가 계층적으로 연결된 것을 **스코프 체인(scope chain)**이라 한다.\n\n자바스크립트 엔진은 상위 스코프 방향으로 이동하며 선언된 변수를 검색(identifier resolution)한다.\n\n> 사실 함수는 식별자에 함수 객체가 할당된 것 외에는 일반 변수와 다를 바 없다. 따라서 스코프를 ‘변수를 검색할 때 사용하는 규칙’이라고 표현하기보다는 ‘식별자를검색하는 규칙’이라고 표현하는 편이 좀 더적합하다.\n\n### 4. 함수 레벨 스코프\n\n코드 블록이 아닌 함수에 의해서만 지역 스코프가 생성된다.\n\n블록 레벨 스코프(C, Java …) / 함수 레벨 스코프(JS var)\n\n### 5. 렉시컬 스코프\n\n```js\nvar x = 1;\n\nfunction foo() {\n  var x = 10;\n  bar();\n}\n\nfunction bar() {\n  console.log(x);\n}\n\nfoo(); // 1\nbar(); // 1\n```\n\n- 동적 스코프(dnamic scope): 함수가 호출되는 시점에 동적으로 상위 스코프를 결정한다.\n- 렉시컬 스코프(lexical scope/static scope): 함수 정의가 평가되는 시점에 상위 스코프가 정적으로 결정된다.\n\n자바스크립트와 대부분의 프로그래밍 언어는 렉시컬 스코프를 따른다.\n\n함수 정의가 실행되어 생성된 함수 객체는 결정된 상위 스코프를 기억한다. 렉시컬 스코프는 클로저와 깊은관계가 있다.\n\n## 14. 전역 변수의 문제점\n\n### 1. 변수의 생명 주기\n\n변수는 생명 주기(life cycle)가 있다.\n\n전역 변수의 생명 주기는 응용 프로그램의 생명 주기와 같다. 지역 변수의 생명 주기는 함수의 생명 주기와같다.\n\n```js\nfunction foo() {\n  console.log(x);\n  var x = 'local';\n  return x;\n}\n\nfoo();\n// console.log(x); ReferenceError: x is not defined\n```\n\n전역변수는 호이스팅으로 인해 런타임 이전 단계에 선언문이 실행되지만, 함수 내부의변수는 함수가 호출된직후와 함수 몸체의 코드가 실행되기 이전 자바스크립트 엔진에의해 선언문이 실행된다. 호이스팅은 스코프를 단위로 동작한다.\n\n변수는 자신이 등록된 스코프가 소멸(메모리 해제)될 때까지 유효하다. ... **누군가스코프를 참조하고 있으면 스코프는 소멸하지 않고 생존하게 된다.**\n\n### 2. 전역 변수의 문제점\n\n전역 변수는 스코프 체인의 종점의 존재하여 미미하지만 검색 속도가 가장 느리다.\n\n자바스크립트의 가장 큰 문제점 중 하나는 파일이 분리되어 있어도 하나의 전역 스코프를 공유한다는 것인데, 다른 파일에 같은 이름으로 명명된 전역 변수가 있다면 예상치 못한 결과가 발생할 수 있다.\n\n### 3. 전역 변수의 사용을 억제하는 방법\n\n즉시 실행 함수, 네임스페이스 객체, 모듈 패턴\n\n모듈 패턴은 클로저를 기반으로 동작하며, 전역 네임스페이스의 오염을 막는 동시에정보 은닉을 구현하기위해 사용된다.\n\n```js\nvar Counter = (function () {\n  var num = 0;\n  return {\n    increase() {\n      return ++num;\n    },\n    decrease() {\n      return --num;\n    },\n  };\n})();\n\nconsole.log(Counter.increase());\nconsole.log(Counter.increase());\nconsole.log(Counter.decrease());\nconsole.log(Counter.decrease());\n```\n\nES6 모듈을 파일 자체의 독자적인 모듈 스코프를 제공한다.\n\n## 15. let, const 키워드와 블록 레벨 스코프\n\n### 1. var 키워드로 선언한 변수의 문제점\n\nvar는 변수 중복 선언 허용, 함수 레벨 스코프, 변수 호이스팅이 발생한다는 단점을지닌다.\n\n### 2. let 키워드\n\nlet 키워드로 선언한 변수는 선언 단계가 런타임 이전에 실행되지만, 초기화 단계는변수 선언문에 도달했을때 실행된다.\n\n스코프의 시작 지점부터 초기화 단계 시작 지점까지의 구간을 일시적 사각지대 (Temporal Dead Zone; TDZ) 라고 부른다.\n\n```js\nlet foo = 1;\n{\n  console.log(foo); // ReferenceError: Cannot access 'foo' before initialization\n  let foo = 2;\n}\n```\n\nlet도 변수 호이스팅이 발생하기에 전역 변수에 접근하지는 않는다. 자바스크립트는모든 선언을 호이스팅한다.\n\n```js\n// 브라우저(window)와 node가 결과가 다른 듯\nvar x = 1;\ny = 2;\nfunction foo() {\n  console.log('hello');\n}\nconsole.log(global.x); // undefined?\nconsole.log(global.y); // 2\nconsole.log(global.foo); // undefined?\n```\n\nlet 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 아니다.\n\n### 3. const 키워드\n\n반드시 선언과 동시에 초기화해야 한다.\n\n보통 대문자와 언더스코어를 사용해 표현한다.\n\nconst 키워드는 재할당을 금지할 뿐 불변을 의미하지는 않는다.\n\n> Angular, React, Vue.js와 같은 SPA 프레임워크에서는 상태가 변경되었음을 명확히하기 위해 변경된 객체를 재할당하는 경우도 있다.\n\n## 16. 프로퍼티 어트리뷰트\n\n### 1. 내부 슬롯과 내부 메서드\n\ninternal slot/method\n\n자바스크립트 엔진의 구현 알고리즘을 설명하기 위해 ECMAScript 사양에서 사용하는 psudo property/method. 이름이 이중 대괄호로 감싸져있다.\n\n엔진 내부 로직이므로 원칙적으로 접근이 불가하지만, 일부에 한해 접근 수단을 제공하기는 한다.\n\n```js\nconst o = {};\n// o.[[Prototype]]; SyntaxError: Unexpected token '['\nconsole.log(o.__proto__); // [Object: null prototype] {}\n```\n\n### 2. 프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체\n\n자바스크립트 엔진은 프로퍼티를 생성할 때 프로퍼티의 상태를 나타내는 **프로퍼티어트리뷰트**를 기본값으로 자동 정의한다.\n\n```js\nconst person = {\n  name: 'YeolYi',\n};\n\nconsole.log(Object.getOwnPropertyDescriptor(person, 'name'));\n/*\nPropertyDescriptor 객체\n{\n  value: 'YeolYi',\n  writable: true,\n  enumerable: true,\n  configurable: true\n}\n*/\n\nperson.age = 24;\nconsole.log(Object.getOwnPropertyDescriptors(person));\n/*\n{\n  name: {\n    value: 'YeolYi',\n    writable: true,\n    enumerable: true,\n    configurable: true\n  },\n  age: { value: 24, writable: true, enumerable: true, configurable: true }\n}\n*/\n```\n\n### 3. 데이터 프로퍼티와 접근자 프로퍼티\n\n프로퍼티는 두가지로 구분할 수 있다.\n\n- data property: 키와 값으로 구성된 일반적인 프로퍼티\n- accessor property: 자체 값이 없고 접근자 함수(accessor function)으로 구성된 프로퍼티\n\n```js\nconst person = {\n  name: 'YeolYi',\n};\n\nlet name = Object.getOwnPropertyDescriptor(person, 'name');\nconsole.log(name.value); // YeolYi\nperson.name = 'YiYeol';\nconsole.log(name.value); // YeolYi\n// data property는 참조?느낌의 객체가 아닌 getOwnPropertyDescriptor를 사용했을 때 만들어지는 객체 같다.\n\nconsole.log(name.writable); // true\nname.writable = false;\nperson.name = 'ASD';\nconsole.log(person.name); // ASD\n```\n\n[[Value]]: 프로퍼티 값 [[Writable]]: 값 변경 가능 여부 [[Enumerable]]: 열거 가능여부 [[Configurable]]: false이면 프로퍼티 삭제 및 어트리뷰트 값 변경 불가, 단 [[Writable]]이 true면 value 의 변경과 [[Writable]]을 false로 변경하는 것이 가능.\n\n아래 세개의 기본값은 true이다.\n\n접근자 프로퍼티는 [[Get]], [[Set]], [[Enumerable]], [[Configurable]]을 가지며 getter/setter는 둘 중하나만 가질 수도 있다.\n\n```js\nconst person = {\n  firstName: 'Yi',\n  lastName: 'Yeol',\n  get fullName() {\n    return `${this.firstName} ${this.lastName}`;\n  },\n  set fullName(name) {\n    [this.firstName, this.lastName] = name.split(' ');\n  },\n};\n\nconsole.log(person.fullName);\nperson.fullName = 'foo bar'; // setter가 없으면 무시됨\nconsole.log(person.firstName, person.lastName);\n\nconsole.log(Object.getOwnPropertyDescriptor(person, 'fullName'));\n/*\n{\n  get: [Function: get fullName],\n  set: [Function: set fullName], // 없다면 undefined\n  enumerable: true,\n  configurable: true\n}\n*/\n```\n\n### 4. 프로퍼티 정의\n\n```js\nconst person = {};\nObject.defineProperty(person, 'age', {\n  value: 10,\n  writable: true,\n  enumerable: true,\n  configurable: true,\n});\nObject.defineProperty(person, 'name', {\n  value: 'yeolyi',\n  writable: false,\n  enumerable: false,\n  configurable: true,\n});\nperson.name = 'ABC';\nconsole.log(person.name); // yeolyi\nconsole.log(Object.keys(person)); // [ 'age' ]\ndelete person.name;\nconsole.log(person.name); // undefined\n\nObject.defineProperty(person, 'school', {\n  value: 'snu',\n  writable: true,\n  enumerable: true,\n  configurable: false,\n});\ndelete person.school;\nconsole.log(person.school); // snu\nperson.school = 'uns';\nconsole.log(person.school); // uns\n/*\nObject.defineProperty(person, 'school', {\n    value: 'snu',\n    writable: true,\n    enumerable: true,\n    configurable: true\n}); Cannot redefine property: school\n*/\n```\n\n### 5. 객체 변경 방지\n\n프로퍼티 추가, 삭제, 읽기, 쓰기, 어트리뷰트 재정의 중 Object.preventExtensions는추가 외 허용, .seal 은 읽기 쓰기 외 비허용, .freeze는 읽기만 허용한다.\n\n이들은 얕은 변경 방지(shallow only)로 직속 프로퍼티만 변경이 방지된다.\n\n## 17. 생성자 함수에 의한 객체 생성\n\n### 1. Object 생성자 함수\n\n> 생성자 함수(constructor)란 new 연산자와 함께 호출하여 객체(인스턴스)를 생성하는 함수를 말한다.\n\n> 생성자 함수에 의해 생성된 객체를 인스턴스(instance)라고 한다.\n\n```js\nconst person = new Object();\nperson.name = 'YeolYi';\nconsole.log(person); // { name: 'YeolYi' }\n\nconst strObj = new String('YeolYi');\nconsole.log(typeof strObj); // object\nconsole.log(strObj); // [String: 'YeolYi']\n```\n\n### 2. 생성자 함수\n\n생성자 함수를 사용하면 객체 리터럴을 사용한 방법과 달리 프로퍼티 구조가 동일한객체 여러 개를 간편하게 생성할 수 있다.\n\n```js\nfunction Circle(radius) {\n  this.radius = radius;\n  this.getSize = function () {\n    return (Math.PI * this.radius * this.radius) / 2;\n  };\n}\n\nconst circle1 = new Circle(5);\nconsole.log(circle1.getSize()); // 39.27...\nconst circle2 = new Circle(10); // 157.08...\nconsole.log(circle2.getSize());\n```\n\nnew 연산자와 함께 호출하면 해당 함수는 생성자 함수로 동작한다.\n\n```js\nfunction Circle(radius) {\n  this.radius = radius;\n}\n\nconst wrongCircle = Circle(14);\n// 일반함수로 호출된 Circle 내의 this는 전역 객체를 가리킨다.\nconsole.log(radius); // 14\n```\n\n인스턴스 생성, this에 이를 바인딩 -> 생성자 함수 내의 코드로 인스턴스 초기화 -> this 암묵적 반환\n\n함수는 객체이지만 일반 객체와 다르게 호출할 수 있다.\n\n함수가 일반 함수로 호출되면 함수 객체의 내부 메서드 [[Call]]이 호출되고, 생성자함수로 호출되면 [[Construct]]가 호출된다.\n\n- constructor: 함수 선언문/표현식, 클래스\n- non-constructor: ES6 메서드 축약 표현, 화살표 함수\n\n```js\nconst bar = {\n  x: function () {}, // 메서드 x\n};\nconsole.log(new bar.x());\n\nconst foo = {\n  x() {}, // 메서드 o\n};\n// console.log(new foo.x()); TypeError: foo.x is not a constructor\n```\n\n생성자 함수는 파스칼 케이스로 명명하여 일반 함수와 구별할 수 있도록 노력한다. 그럼에도 실수의 위험성을 회피하기 위해 ES6에서는 new.target을 지원한다.\n\n```js\nfunction Circle(radius) {\n  if (!new.target) {\n    return new Circle(radius);\n  }\n  this.radius = radius;\n}\n\nconsole.log(Circle(10).radius); // 10\n```\n\n대부분의 빌트인 생성자 함수는 new 연산자 유무에 상관없이 적절한 값을 반환하지만, String, Number, Boolean은 new가 있으면 객체, 없으면 값을 반환한다.\n\n## 18. 함수와 일급 객체\n\n### 1. 일급 객체\n\n- 무명의 리터럴로 생성할 수 있다. 즉, 런타임에 생성이 가능하다.\n- 변수나 자료구조(객체, 배열 등)에 저장할 수 있다.\n- 함수의 매개변수에 전달할 수 있다.\n- 함수의 반환값으로 사용할 수 있다.\n\n[Why are functions not considered first class citizens in c?](https://stackoverflow.com/questions/48092176/why-are-functions-not-considered-first-class-citizens-in-c?answertab=trending#tab-top)\n\n### 2. 함수 객체의 프로퍼티\n\n```js\nfunction square(number) {\n  return number * number;\n}\nconsole.log(Object.getOwnPropertyDescriptors(square));\n// 여기는 함수 고유의 프로퍼티.\n// {\n//   length: { value: 1, writable: false, enumerable: false, configurable: true },\n//   name: {\n//     value: 'square',\n//     writable: false,\n//     enumerable: false,\n//     configurable: true\n//   },\n//   arguments: {\n//     value: null,\n//     writable: false,\n//     enumerable: false,\n//     configurable: false\n//   },\n//   caller: {\n//     value: null,\n//     writable: false,\n//     enumerable: false,\n//     configurable: false\n//   },\n//   prototype: { value: {}, writable: true, enumerable: false, configurable: false }\n// }\n\n// 얘는 'own'이 아니라 아래의 Object.prototype으로부터 상속받는다.\nconsole.log(square.__proto__); // {},\nconsole.log(Object.getOwnPropertyDescriptor(square, '__proto__')); // undefined\nconsole.log(Object.getOwnPropertyDescriptor(Object.prototype, '__proto__'));\n// {\n//   get: [Function: get __proto__], // 접근자 프로퍼티\n//   set: [Function: set __proto__],\n//   enumerable: false,\n//   configurable: true\n// }\n\n// argument 객체는 순회 가능한 유사 배열 객체. 함수 내부에서 지역 변수처럼 사용한다.\n// 유사 배열 객체란 length 프로퍼티를 가진 객체로 for문으로 순회할 수 있는 객체를 말한다.\nfunction multiply(x, y) {\n  console.log(arguments);\n  console.log(arguments.length);\n  return x * y;\n}\nmultiply(1, 2, 3, 4, 5);\n// [Arguments] { '0': 1, '1': 2, '2': 3, '3': 4, '4': 5 }\n// 5\n\nconsole.log(multiply.length); // 위에는 인자, 얘는 매개변수의 개수\n```\n\n**proto** 프로퍼티는 [[Prototype]] 내부 슬롯이 가리키는 프로토타입 객체에 접근하기 위해 사용하는 접근자 프로퍼티이다.\n\nprototype 프로퍼티는 constructor만 소유하는 프로퍼티이다. 생성자 함수로 함수가호출될 때 생성되는 인스턴스의 프로토타입 객체를 가리킨다.\n\n## 19. 프로토타입\n\n### 1. 객체지향 프로그래밍\n\n> 속성을 통해 여러 개의 값을 하나의 단위로 구성한 복합적인 자료구조를 객체라 한다.\n\n> 객체지향 프로그래밍은 독립적인 객체의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임이다.\n\n### 2. 상속과 프로토타입\n\n```js\nfunction Circle(radius) {\n  this.radius = radius;\n  this.getArea = function () {\n    return Math.PI * this.radius ** 2;\n  };\n}\n\nconst circle1 = new Circle(10);\nconst circle2 = new Circle(12);\nconsole.log(circle1.getArea === circle2.getArea);\n// false\n\nfunction BetterCircle(radius) {\n  this.radius = radius;\n}\n\nBetterCircle.prototype.getArea = function () {\n  return Math.PI * this.radius ** 2;\n};\n\nconst circle3 = new BetterCircle(10);\nconst circle4 = new BetterCircle(12);\nconsole.log(circle3.getArea === circle4.getArea);\n// true\n```\n\nCircle 생성자 함수가 생성한 모든 인스턴스는 자신의 프로토타입, 즉 상위 객체 역할을 하는 Circle.prototype의 모든 프로퍼티와 메서드를 상속받는다.\n\n### 3. 프로토타입 객체\n\n모든 객체는 하나의 프로토타입을 갖고, 모든 프로토타입은 생성자 함수와 연결되어있다.\n\n```js\nfunction A() {}\nconst a = new A();\nconsole.log(a.__proto__ === A.prototype); // true\nconsole.log(A.prototype.constructor === A); // true\nconsole.log(a.__proto__.__proto__.__proto__); // null?\n```\n\n**proto** 접근자 프로퍼티는 객체가 직접 소유하지 않고 Object.prototype의 프로퍼티를 상속을 통해 사용된다.\n\n```js\nconst parent = {};\nconst child = {};\nchild.__proto__ = parent;\nparent.__proto__ = child;\n// TypeError: Cyclic __proto__ value\n// 프로토타입 체인을 단방향 연결 리스트로 유지시키기 위해 __proto__ 접근자 프로퍼티를 통한 접근을 강제한다.\n```\n\n**proto** 대신 getPrototypeOf와 setPrototypeOf가 권장된다. 왜??\n\n### 4. 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입\n\n객체 리터럴에 의해 생성된 객체는 Object 생성자 함수가 생성한 객체가 아니다.\n\n프로토타입의 constructor 프로퍼티를 통해 연결되어 있는 생성자 함수를 리터럴 표기법으로 생성한 객체를생성한 생성자 함수로 생각해도 크게 무리는 없다.\n\n이 부분은 추후 다시 읽어보기.\n\n> 추상 연산(abstract operation)은 ECMAScript 사양에서 내부 동작의 구현 알고리즘을 표현한 것이다.\n\n### 5. 프로토타입의 생성 시점\n\n프로토타입은 생성자 함수가 생성되는 시점에 더불어 생성된다.\n\n함수 선언문은 런타임 이전에 자바스크립트 엔진에 의해 먼저 실행되며, 이때 프로토타입도 더불어 생성된다. 이 프로토타입의 프로토타입은 언제나 Object.prototype이다 .\n\n모든 빌트인 생성자 함수는 전역 객체가 생성되는 시점에 생성된다.\n\n### 6. 객체 생성 방식과 프로토타입의 결정\n\n객체는 어떤 방식으로 생성되든지 OrdinaryObjectCreate 추상 연산에 의해 생성된다는공통점이 있다. 이 추상 연산에 결정되는 인수에 따라 생성되는 객체의 프로토타입이결정된다.\n\n```js\nfunction Person() {}\nPerson.prototype.hello = () => {\n  console.log('hello');\n};\nconsole.log(Person.hello); // undefined. 여기는 체인 따라 검색을 안하네?\nconsole.log(Object.getPrototypeOf(Person) === Function.prototype); // true, 아 자기 프로토타입은 prototype이 아니라 __proto__...\nconsole.log(Object.getPrototypeOf(Person.prototype) === Object.prototype); // true\n```\n\n### 7. 프로토타입 체인\n\n> 자바스크립트는 해당 객체에 찾고자하는 프로퍼티가 없다면 [[Prototype]] 내부 슬롯의 참조를 따라 자신의 부모 역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색한다. 이를 프로토타입 체인이라 하며, 자바스크립트가 객체지향 프로그래밍의 상속을 구현하는 매커니즘이다.\n\n모든 객체는 Object.prototype을 상속받으며 이는 프로토타입 체인의 종점이다.\n\n프로토타입 체인은 상속과 프로퍼티 검색을 위한, 스코프 체인은 식별자 검색을 위한매커니즘이다.\n\n### 8. 오버라이딩과 프로퍼티 섀도잉\n\n> 상속 관계에 의해 프로퍼티가 가려지는 현상을 프로퍼티 섀도잉이라 한다.\n\n> 오버라이딩이란 상위 클래스가 가지고 있는 메서드를 하위 클래스가 재정의하여 사용하는 방식이다.\n\n하위 객체를 통해 프로토타입의 프로퍼티를 변경 또는 삭제하는 것은 불가능하다.\n\n### 9. 프로토타입의 교체\n\n객체 간의 상속 관계를 동적으로 변경할 수 있다.\n\n프로토타입을 교체하면 constructor 프로퍼티와 생성자 함수 간의 연결이 파괴된다.\n\n프로토타입은 직접 교체하지 않는 것이 좋다.\n\n상속 관계를 인위적으로 설정하려면 번거로운 프로토타입 교체보다 직접 상속이나 클래스를 사용하는 편이좋다.\n\n### 10. instanceof 연산자\n\n좌변에 객체, 우변에 생성자 함수\n\n생성자 함수의 prototype 프로퍼티가 객체의 프로토타입 체인에 존재하는지 확인한다.\n\ninstanceof 연산자는 constructor 프로퍼티가 아닌 생성자 함수의 prototype에 바인딩된 객체가 체인에 존재하는지 확인한다.\n\n```js\nconst Person = (function () {\n  function Person(name) {\n    this.name = name;\n  }\n  Person.prototype = {};\n  return Person;\n})();\n\nconst me = new Person('YeolYi');\nconsole.log(me.constructor === Person); // fals e\nconsole.log(me instanceof Person); // true\n```\n\n### 11. 직접 상속\n\nnew 연산자가 필요 없고, 프로토타입을 지정하며 객체를 생성할 수 있으며, 객체 리터럴에 의해 생성된 객체도 상속받을 수 있다.\n\n프로토타입 체인의 종점에 위치한 객체를 생성할 수 있으므로, Object.prototype의 빌트인 메서드를 직접호출하는 것은 권장하지 않는다. call 등의 메서드로 간접 호출을권함.\n\n```js\nlet obj = Object.create(null);\nconsole.log(Object.__proto__);\n\nfunction Person(name) {\n  this.name = name;\n}\nobj = Object.create(Person.prototype);\nconsole.log(obj.constructor);\n```\n\nES6에서는 객체 리터럴 내부에서 **proto** 접근자 프로퍼티를 사용해 직접 상속을 구현할 수 있다.\n\n```js\nobj = {\n  name: 'YeolYi',\n  __proto__: myProto,\n};\n```\n\n### 12. 정적 프로퍼티/메서드\n\n> 생성자 함수 객체가 소유한 프로퍼티/메서드를 정적 프로퍼티/메서드라고 한다.\n\nprototype을 #으로 표기하는 경우도 있으니 알아두자. Object#isPrototypeOf.\n\n### 13. 프로퍼티 존재 확인\n\n```js\nconst person = { age: 13 };\nconsole.log('age' in person); // true\nconsole.log('isPrototypeOf' in person); // true\nconsole.log(Reflect.has(person, 'age')); // in 연산자와 동일\nconsole.log(person.hasOwnProperty('isPrototypeOf')); // false\n```\n\n### 14. 프로퍼티 열거\n\n```js\nconst person = { __proto__: { temp: null }, age: 24, name: 'YeolYi' };\n\n// for...in은 상속받은 프로토타입의 프로퍼티까지 열거한다.\n// [[Enumerable]]이 true이고 키가 심볼이 아닌 값만 열거된다.\nfor (const key in person) {\n  console.log(key); // age, temp, name\n}\n\nconst arr = ['a', 'b', 'c'];\nfor (const key in arr) {\n  console.log(key); // 0 1 2\n}\n\nconsole.log(Object.keys(person)); // age, name\nconsole.log(Object.values(person)); // 24, 'YeolYi'\nconsole.log(Object.entries(person)); // [ [ 'age', 24 ], [ 'name', 'YeolYi' ] ]\n```\n\n## 20. strict mode\n\n린트 도구는 strict mode가 제한하는 오류는 물론 코딩 컨벤션을 설정 파일 형태로 저으이하고 강제할 수있기 때문에 더욱 강력한 효과를 얻을 수 있다.\n\n전역과 함수단위로 strict mode를 적용하는 것은 피하고, 즉시 실행함수로 스코프를구분하고 즉시 실행 함수의 선두에 strict mode를 적용한다.\n\n암묵적 전역, 변수/함수/매개변수의 삭제, 매개변수의 중복, with문의 사용에 대해 에러가 발생한다.\n\n[with 명령에 대하여](https://unikys.tistory.com/304)\n\n일반함수에서 this에 undefined가 바인딩되며, 매개변수에 전달된 인수를 재할당해도 arguments 객체에 반영되지 않는다.\n\n```js\n(function (x) {\n  x = 10;\n  console.log(arguments); // [Arguments] { '0': 10 }\n})(1);\n```\n\n## 21. 빌트인 객체\n\n### 1. 자바스크립트 객체의 분류\n\nECMAScript 사양에 정의된 표준 빌트인 객체(standard built-in objects, natice objects, global objects), 자바스크립트 실행 환경에 따라 추가로 제공하는 호스트객체, 사용자 정의 객체가 있다.\n\n### 2. 표준 빌트인 객체\n\nMath, Reflect, JSON을 제외하고 모두 생성자 함수 객체이다.\n\n### 3. 원시값과 래퍼 객체\n\n> 문자열, 숫자, 불리언 값에 대해 객체처럼 접근하면 생성되는 임시 객체를 래퍼 객체라 한다.\n\n래퍼 객체의 처리가 종료되면 식별자가 원시값을 갖도록 되돌리고 래퍼 객체는 가비지컬렉션의 대상이 된다 .\n\n```js\nconst a = 10;\nconsole.log(a.toString()); // 10\na.name = 'hello';\nconsole.log(a.name); // undefined\n```\n\n### 4. 전역 객체\n\n> 전역 객체는 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체이며, 어떤 객체에도 속하지 않은 최상위 객체이다.\n\n표준 빌트인 객체, 호스트 객체, 전역 변수/함수를 프로퍼티로 가진다.\n\nlet이나 const 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 아니다.\n\n브라우저 환경의 모든 자바스크립트 코드는 하나의 전역 객체 window를 공유한다.\n\nInfinity, NaN, undefined는 빌트인 전역 프로퍼티다.\n\n```js\n// 빌트인 전역 함수\n\n// eval\n\nconsole.log(isFinite(NaN)); // false, 인수가 NaN으로 평가되는 값이면 false를 반환\nconsole.log(isFinite(null)); // true\nconsole.log(isFinite(-Infinity)); // false\n\nconsole.log(isNaN(NaN)); // true\nconsole.log(isNaN('Hello')); // true\nconsole.log(isNaN('')); // false\n\nconsole.log(parseFloat('3.1415')); // 3.1415\n\nconsole.log(parseInt('100', 2)); // 4\nconsole.log(parseInt('100', 5)); // 25\nconsole.log(parseInt('0xff')); // 255, 2진수와 8진수 리터럴은 해석하지 못한다.\n```\n\n> URI(Uniform Resource Identifier)는 인터넷에 있는 자원을 나타내는 유일한 주소로 , 하위개념으로 URL, URN이 있다.\n\n인코딩이한 URI의 문자들을 이스케이프 처리(아스키 문자 셋으로 변환)하는 것이다.\n\n```js\nconst uri = 'https://yeolyi.dev/언어/모던 자바스크립트';\nconst encoded = encodeURI(uri);\nconsole.log(encoded);\n// https://yeolyi.dev/%EC%96%B8%EC%96%B4/%EB%AA%A8%EB%8D%98%20%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8\nconst decoded = decodeURI(encoded);\nconsole.log(decoded);\n// https://yeolyi.dev/언어/모던 자바스크립트\nconsole.log(decodeURI(decoded)); // 그대로\nconsole.log(encodeURI(encoded));\n// https://yeolyi.dev/%25EC%2596%25B8%25EC%2596%25B4/%25EB%25AA%25A8%25EB%258D%2598%2520%25EC%259E%2590%25EB%25B0%2594%25EC%258A%25A4%25ED%2581%25AC%25EB%25A6%25BD%25ED%258A%25B8\n\n// encodeURIComponent는 쿼리 스트링 구분자까지 인코딩한다.\n```\n\n암묵적 전역 현상에서는 변수가 아닌 프로퍼티가 생성되고, 따라서 변수 호이스팅이발생하지 않고 delete 연산자로 삭제할 수 있다.\n\n## 22. this\n\n### 1. this 키워드\n\n> this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수 (self-referencing variable)이다.\n\nthis는 일반함수에서 전역 객체, 메서드에서 메서드를 호출한 객체, 생성자 함수 내부에서는 생성될 인스턴스를 가리킨다.\n\n### 2. 함수 호출 방식과 this 바인딩\n\n렉시컬 스코프는 평가 시점, this 바인딩은 호출 시점에 결정된다. 동일한 함수도 다양하게 호출하여 다른 this가 바인딩될 수 있다.\n\n어떠한 함수(중첩 함수, 콜백 함수..)라도 일반 함수로 호출되면 this 객체에 전역 객체가 바인딩된다.\n\n이는 중첩 함수가 헬퍼함수로서 동작하기 힘들게하므로 this 바인딩을 특정 변수에 할당하여 헬퍼 함수에서사용하거나, apply/call/binding 메서드를 사용하거나, 화살표함수를 사용할 수 있다.\n\n메서드 내의 this도 호출한 함수에 따라 달라진다.\n\n```js\nfunction Person(name) {\n  this.name = name;\n}\nPerson.prototype.getName = function () {\n  console.log(this.name);\n};\nPerson.prototype.name = 'Prototype';\n\nlet me = new Person('YeolYi');\nme.getName(); // 'YeolYi'\nPerson.prototype.getName();\n('Prototype');\n```\n\napply/call/binding 메서드는 Function.prototype의 메서드다.\n\n```js\nfunction foo(a, b) {\n  console.log(a, b, this);\n}\n\nconst thisArg = { x: 1 };\n\nfoo.apply(thisArg); // undefined undefined { x: 1}\nfoo.call(thisArg); // undefined undefined { x: 1 }\nfoo.apply(thisArg, [1, 2]); // 1 2 { x: 1 }\nfoo.call(thisArg, 1, 2); // 1 2 { x: 1 }\n\n// bind는 this가 교체된 함수를 새롭게 생성해 반환한다.\n\nconst bar = foo.bind(thisArg);\nbar(3, 4); // 3 4 { x: 1 }\n\nconst timer = {\n  message: 'bibibib',\n  foo(callback) {\n    // setTimeout(callback.bind, 1000);\n    setTimeout(callback.bind(this), 1000);\n  },\n};\n\ntimer.foo(function () {\n  console.log(this.message);\n});\n```\n\n## 23. 실행 컨텍스트\n\n### 1. 소스코드의 타입\n\n각 타입은 실행 컨텍스트를 생성한다. 타입에 따라 실행 컨텍스트의 생성 과정과 관리내용이 다르다.\n\n전역 코드: 최상위 스코프인 전역 스코프 생성. var, 전역에 선언된 함수 선언문함수코드: 지역 스코프 생성, 스코프 체인에 연결. 지역변수, 매개변수, argument 객체모듈 코드: 모듈별로 독립적인 모듈 스코프\n\n### 2. 소스코드의 평가와 실행\n\n소스코드 평가 과정에서 컨텍스트를 생성하고 선언문들을 실행하여 식별자를 실행 컨텍스트가 관리하는 스코프에 등록한다.\n\n이후 실행, 런타임이 시작되어 필요한 값을 스코프에서 얻어오고 실행 결과를 스코프에 등록하는 과정.\n\n### 3. 실행 컨텍스트의 역할\n\n전역 코드 평가 -> 전역 코드 평가 -> 함수 코드 평가 -> 함수 코드 실행\n\n코드가 실행되려면 스코프, 식별자, 코드 실행 순서의 관리가 필요하다.\n\n1. 선언에 의해 생성된 식별자를 스코프를 구분해 등록하고 상태 변화를 관리해야한다 .\n2. 스코프는 중첩 관계에 의한 스코프 체인을 형성해야한다.\n3. 현재 실행중인 코드의 실행 순서를 변경할 수 있어야 한다?\n\n> 실행 컨텍스트는 소스코드를 실행하는데 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역이다.\n\n이거는 JS가 인터프리터 언어이기 때문인가? 컴파일하는 언어는 이 작업을 컴파일 중에 하는건가?\n\n렉시컬 환경과 실행 컨텍스트 스택으로 구성?된다.\n\n### 4. 실행 컨텍스트 스택\n\n혹은 콜 스택. 코드 실행 순서를 관리한다.\n\n전역 코드가 평가되고, 함수 코드가 평가되면 실행 컨텍스트가 생기는데 이들을 스택형태로 관리한다. C에서의 스택/힙에서 스택과 유사한듯.\n\n최상단의 컨텍스트를 실행 중인 실행 컨텍스트(running execution context)라 한다.\n\n### 5. 렉시컬 환경\n\nLexical environment. 식별자와 그에 바인딩 된 값(환경 레코드, environment record), 상위 스코프에 대한참조(외부 렉시컬 환경에 대한 참조, outer lexical environment reference)를 기록하는 자료구조. 렉시컬스코프의 실체. LexicalEnvironment와 VariableEnvironment로 구성되지만 대부분 비슷하다.\n\n환경 레코드는 소스코드의 타입에 따라 관리하는 내용에 차이가 있다. 외부 렉시컬 어쩌구를 통해 스코프체인을 구현한다.\n\n### 6. 실행 컨텍스트의 생성과 식별자 검색 과정\n\n**전역 객체 생성**\n\n- 전역 코드 평가 이전에 생성\n- 전역 객체도 Object.prototype을 상속받는다.\n\n**전역 코드 평가**\n\n- 전역 실행 컨텍스트 생성, 스택에 push\n- 전역 렉시컬 환경 생성, 위의 컨텍스트에 바인딩\n- 전역 환경 레코드 생성. var 및 나머지는 객체 환경 레코드(Object Environment Record), let/const는 선언적 환경 레코드(Declarative Environment Record)에서 관리.\n- 객체 환경 레코드 생성. 객체 환경 레코드는 BindingObject라는 객체와 연결, 이는전역 객체 생성에서 생성된 전역 객체. var와 전역 변수, 함수 선언문은 BindingObject를 통해 연결된 전역 객체의 프로퍼티와메서드가 된다.\n- 선언적 환경 레코드 생성. 이곳의 변수들은 일시적 사각지대(Temporal Dead Zone, TDZ)에 빠진다.\n- this 바인딩. 전역 환경 레코드의 [[GlobalThisValue]]에 this(보통 전역객체)가 바인딩된다.\n- 외부 렉시컬 환경에 대한 참조 결정: 전역이므로 전역 렉시컬 환경의 OuterLexicalEnvironmentReference 에 null이 할당.\n\nlet은 블록 레벨 스코프인데, 블록에 들어가면 새로운 컨텍스트가 생기는건가? -> 챕터 7 참조\n\n**전역 코드 실행** pass\n\n**함수 코드 평가**\n\n- 힘수 실행 컨텍스트 생성: 스택에 push\n- 함수 렉시컬 환경 생성\n  - 함수 환경 레코드 생성: 매개변수, arguments 객체, 지역 변수, 중첩 함수 등록및관리\n  - this 바인딩: 함수 호출 방식에 따라 this 결정.\n  - 외부 렉시컬 환경에 대한 참조 결정: 현재 실행 중인 실행 컨텍스트의 렉시컬 환경을 [[Environment]]에 할당한다. 이는 클로저와 연관된다.\n\n**함수 코드 실행** 이후 실행이 완료된 함수의 컨텍스트를 pop. 다만 컨텍스트가 소멸되었더라도 그에 바인딩된 렉시컬 환경을 누군가 참조한다면 이는 소멸하지 않는다.\n\n### 7. 실행 컨텍스트와 블록 레벨 스코프\n\n코드 블록에 들어가면 새로운 선언적 환경 레코드를 가진 렉시컬 환경을 만들어 기존것을 대체. 대신 새로운 환경 내 외부 렉시컬 환경에 대한 참조는 기존 것을 가리킨다 .\n\n변수 선언문에 let을 사용한 for문은 코드 블록이 실행될 때마다 새로운 렉시컬 환경을 생성한다?? 이에 대해서는 클로저에서 자세히...\n\n## 24. 클로저\n\n> A closure is the combination of a function and the lexical environment within which that function was declared.\n\n### 1. 렉시컬 스코프\n\n> 렉시컬 환경의 '외부 렉시컬 환경에 대한 참조'에 저장할 참조값, 즉 상위 스코프에대한 참조는 함수 사용 시점이 아닌 정의가 평가되는 시점에 함수가 정의된 환경(위치)에 의해 결정된다. 이것이 바로 렉시컬스코프다.\n\n### 2. 함수 객체의 내부 슬롯 [[Environment]]\n\n함수가 호출되었을 때 생성될 '외부 렉시컬 환경에 대한 참조'에 저장될 참조값과 같다. 함수는 여기에 저장되는 상위 스코프를 자신이 존재하는 한 기억한다.\n\n```js\nfunction foo() {\n  let x = 0;\n  setTimeout(function () {\n    x += 1;\n  }, 100);\n  function bar() {\n    return x;\n  }\n  return bar;\n}\n\nconst bar = foo();\nconsole.log(bar()); // 0\nsetTimeout(function () {\n  console.log('result: ' + bar());\n}, 200); // 1\n```\n\n### 3. 클로저와 렉시컬 환경\n\n> 외부 함수보다 중첩 함수가 더 오래 유지되는 경우 중첩 함수는 이미 생명 주기가종료된 외부 함수의 변수를 참조할 수 있다. 이러한 중첩 함수를 클로저(closure)라고부른다.\n\n자바스크립트의 모든 함수가 상위 스코프를 기억하므로 이론적으로는 모든 함수가 클로저이지만, 상위 스코프의 어떠한 식별자도 참조하지 않는 경우 대부분의 모던 브라우저는 최적화를 통해 상위 스코프를 기억하지 않기 때문에 클로저라고 부르기 어렵다 . 일부만 참조하는 경우에도 다른 식별자는 기억하지 않는다.\n\n또한 상위 함수보다 수명이 짧아도 클로저라 부르기 어렵다.\n\ndebugger 구문 입력하고 브라우저에서 실행하면 스코프 정보를 볼 수 있다.\n\n> 클로저에 의해 참조되는 상위 스코프의 변수를 자유 변수(free variable)라고 부른다.\n\n### 4. 클로저의 활용\n\n상태를 은닉하고 특성 함수에게만 변경을 허용하기 위해 사용한다.\n\n```js\nconst counter = (function () {\n  let num = 0;\n  // 객체 리터럴의 코드 중괄호는 코드 블록이 아니므로 별도의 스코프를 생성하지 않는다.\n  return {\n    increase() {\n      return ++num;\n    },\n    decrease() {\n      return --num;\n    },\n  };\n})();\n\nconsole.log(counter.increase()); // 1\nconsole.log(counter.decrease()); // 0\nconsole.log(counter.decrease()); // -1\n```\n\n한 함수에서 여러 스코프에 접근한다면 [[Environment]]의 참조는?\n\n함수를 호출할 때마다 새로운 렉시컬 환경이 생김을 기억하자.\n\n### 5. 캡슐화와 정보 은닉\n\n자바스크립트는 접근 제한자를 제공하지 않는다. [최신 버전에는 있기는 한듯?](https://stackoverflow.com/questions/38243329/classes-access-modifiers-in-javascript) -> private 필드에 대해서는 25.7.4에서.\n\n[이런](https://medium.com/@weberino/you-can-create-truly-private-properties-in-js-without-es6-7d770f55fbc3) 방법도 있다.\n\n### 6. 자주 발생하는 실수\n\n!chapter24/@commonMistake.js@!\n\n## 25. 클래스\n\n### 1. 클래스는 프로토타입의 문법적 설탕인가?\n\n클래스는 생성자 함수보다 엄격하며 생성자 함수에서는 제공하지 않는 기능도 제공한다.\n\n- 클래스를 new 연산자 없이 호출하면 에러가 발생한다.\n- 클래스는 extends와 super 키워드를 제공한다.\n- 클래스는 호이스팅이 발생하지 않는 것처럼 동작한다.\n- 클래스 내의 모든 코드에는 strict mode가 암묵적으로 적용된다.\n- 클래스의 constructor, 프로토타입 메서드, 정적 메서드는 [[Enumerable]]이 false 이다.\n\n클래스는 새로운 객체 생성 매커니즘이다.\n\n### 2. 클래스 정의\n\n클래스는 함수며 일급 객체이다.\n\n### 3. 클래스 호이스팅\n\n클래스 선언문으로 정의한 클래스는 런타임 이전에 평가되지만 클래스 정의 이전에 참조할 수 없다.\n\n```js\nconsole.log(Temp1); // undefined\n// console.log(Temp2); Cannot access 'Temp2' before initialization\n\nvar Temp1 = class {};\nclass Temp2 {}\n\nconst Person = '';\n{\n  // console.log(Person); ReferenceError: Cannot access 'Person' before initialization. 호이스팅 발생 중\n  class Person {}\n}\n```\n\n### 5. 메서드\n\nconstructor는 메서드로 해석되지 않고 클래스가 평가되어 생성된 함수 객체 코드의일부가 된다. 이에 클래스가 평가된 함수 객체를 봐도 constructor 메서드가 따로 있지않다.\n\nconstructor는 0개 혹은 1개 존재해야한다. constructor 내에서는 인스턴스의 생성과프로퍼티 추가를 통한인스턴스 초기화를 실행한다.\n\n메서드에 static 키워드를 붙이면 정적 메서드가 된다.\n\n프로토타입 메서드에서 this는 인스턴스, 정적 메서드의 this는 클래스를 가리킨다.\n\n정적 메서드는 애플리케이션 전역에서 사용할 유틸리티 함수를 전역 함수로 정의하지않고 메서드로 구조화할 때 유용하다.\n\n- function 키워드를 생략한 축약 표현\n- 콤마 필요 없음\n- 암묵적 strict mode\n- 열거 불가\n- non-constructor\n\n### 6. 클래스의 인스턴스 생성 과정\n\nconstructor 에서의 this는 내부 코드가 실행될 시점에 이미 클래스의 prototype 프로퍼티가 가리키는 객체가 프로토타입으로 설정되어있다.\n\n### 7. 프로퍼티\n\n```js\nclass Rectangle {\n  constructor(width, height) {\n    this.width = width;\n    this.height = height;\n  }\n  get size() {\n    return this.width * this.height;\n  }\n  set size(size) {\n    let ratio = Math.sqrt(size / this.size);\n    this.width *= ratio;\n    this.height *= ratio;\n  }\n}\n\nconst rect = new Rectangle(2, 3);\nconsole.log(rect.size);\nrect.size = 24;\nconsole.log(rect.width, rect.height);\n\nconsole.log(Object.getOwnPropertyNames(rect)); // width, height\nconsole.log(Object.getOwnPropertyNames(Rectangle.prototype)); // constructor, size\n```\n\n인스턴스 프로퍼티를 자바처럼 정의할 수 있는 Class field declarations가 최신 브라우저에 구현되어 있다 . 메소드도 이를 통해 정의할 수 있지만 프로토타입 메서드가 아닌 인스턴스 메서드가 되므로 권장하지 않는다.\n\n[선언, 정의, 초기화](https://salkuma.wordpress.com/2014/02/05/선언-정의-초기화-기본생성자-그리고-시그너처/)\n\n```js\nclass Person {\n  #age; // 반드시 함수 몸체에 정의해야 한다.\n  constructor(age) {\n    this.#age = age;\n  }\n}\n\nconst person = new Person(24);\n// console.log(person.#age); SyntaxError: Private field '#age' must be declared in an enclosing class\n// 에러 메시지가 요상하네??\n// new 빼먹었었는데 이거보다 위 에러가 우선적으로 뜨는게 신기.\n```\n\nstatic을 사용한 정적 필드도 최신 브라우저에 구현되어 있다.\n\n### 8. 상속에 의한 클래스 확장\n\n프로토타입 기반은 다른 객체의 자산을 상속받는 개념이지만 상속에 의한 클래스 확장은 새로운 클래스를확장하여 정의하는 것이다.\n\n인스턴스끼리뿐만 아니라 수퍼클래스와 서브클래스는 둘 간 프로토타입 체인도 생성한다.\n\n동적 상속이 가능하다.\n\n서브클래스에 constructor를 생략하면 다음과 같은 constructor가 암묵적으로 정의된다.\n\n```js\nconstructor(...args) { super(...args); }\n```\n\nsuper를 호출하면 수퍼클래스의 constructor를 호출한다.\n\n- 서브클래스에서 constructor를 생략하지 않았다면 그 constructor에서는 super를 반드시 호출해야한다.\n- super 호출 전에는 this를 참조할 수 없다. this를 super에서 만들기 때문이다.\n- super는 서브클래스의 constructor 내부에서만 호출할 수 있다.\n\nsuper를 참조해 수퍼클래스의 메서드를 호출할 수 있다. super는 자신을 참조하는 메서드가 바인딩된 객체의 프로토타입을 가리킨다.\n\n```js\nclass Phone {\n  constructor(number) {\n    this.number = number;\n  }\n  call() {\n    return `calling ${this.number}...`;\n  }\n}\n\nclass iPhone extends Phone {\n  call() {\n    // return `${super.call()} by iPhone`;\n    const __super = Object.getPrototypeOf(iPhone.prototype);\n    return `${__super.call.call(this)} by iPhone`;\n    // 어떤 call인지 잘 찾아서 불러주네?\n    // 그냥 실행하면 this에 Phone.prototype이 바인딩 됨.\n  }\n}\n\nconst phone = new iPhone('010-1234-5678');\nconsole.log(phone.call());\n```\n\nsuper를 위해 메서드는 내부 슬롯 [[HomeObject]]를 가지며 의사 코드는 다음과 같다. 이 슬롯은 ES6 메서드 축약 표현으로 정의된 함수만 지닌다. 이 슬롯을 가져야 super 를 참조할 수 있다.\n\n[[HomeObject]]는 메서드가 바인딩 된 객체를 가리킨다.\n\n```js\nsuper = Object.getPrototypeOf([[HomeObject]])\n```\n\n[[ConstructorKind]]의 base/derived 구분을 통해 new 연산자로 호출되었을 때 동작을구분한다. 서브클래스는 수퍼클래스에게 인스턴스 생성을 위임한다. 이때 수퍼클래스의 constructor의 this의 프로토타입은 서브클래스의 prototype 프로퍼티이다.\n\n```js\n// Number를 반환하는 Number의 인스턴스 메서드가 없어서 예시 코드 실패,,\nclass MyNumber extends Number {\n  get numberOfDigits() {\n    // https://stackoverflow.com/questions/14879691/get-number-of-digits-with-javascript\n    return Math.max(Math.floor(Math.log10(Math.abs(this))), 0) + 1; // 다형성?\n  }\n}\n\nconst myNumber = new MyNumber(12345);\n// new 없으면 에러. Number가 없어도 되는 것과는 상관 없는 듯.\nconsole.log(myNumber.numberOfDigits);\n\nclass MyArray extends Array {\n  // static get [Symbol.species]() { return Array } 이게 있으면 addOne에서 Array를 반환한다.\n  addOne() {\n    return this.map((x) => x + 1);\n  }\n}\n\nconst myArr = new MyArray(1, 2, 3);\nconsole.log(myArr.addOne() instanceof MyArray); // true. 덕분에 메서드 체이닝이 가능하다.\n```\n\n## 26. ES6 함수의 추가 기능\n\n### 1. 함수의 구분\n\n객체에 바인딩된 함수(콜백 함수도 마찬가지)가 생성자 함수로 호출할 수 있다는 것은해당 함수가 prototype 프로퍼티를 가지며 프로토타입 객체도 생성한다는 것이므로 성능상의 문제또한 있다.\n\nES6 이전의 함수는 명확한 구분이 없었는데, ES6에서부터 함수를 사용 목적에 따라 분류한다.\n\n- Normal: constructor/prototype/arguments\n- Method: super/arguments\n- Arrow: -\n\n세 가지 이외에도 제너레이터 함수와 async 함수가 있으며 46장에서 살펴본다.\n\n### 2. 메서드\n\n> ES6 사양에서 메서드는 메서드 축약 표현으로 정의된 함수만을 의미한다.\n\n[[HomeObject]]를 가지기에 super 키워드를 사용할 수 있다.\n\n### 3. 화살표 함수\n\n화살표 함수는 콜백 함수 내부에서 this가 전역 객체를 가리키는 문제를 해결하기 위한 대안으로 유용하다.\n\n객체 리터럴을 반환하는 경우 리터럴을 소괄호로 감싸주어야한다. 아니면 객체 리터럴의 중괄호가 함수 몸체를 감싸는 중괄호로 잘못 해석된다.\n\n화살표 함수는 함수 자체의 this, arguments, super, new.target 바인딩을 갖지 않으며 스코프 체인 상에서가장 가까운 상위 함수 중 화살표 함수가 아닌 함수의 것들을참조한다.\n\n> 화살표 함수는 자체의 this가 없기에 상위 스코프의 this를 그대로 참조한다. 이를 lexical this라 한다.\n\nES6이전에는 this를 스코프 체인을 따라 탐색할 이유가 없었지만, 화살표 함수 이후탐색이 필요해졌다.\n\n```js\nconst counter = {\n  num: 1,\n  increase: () => ++this.num,\n};\n\nconsole.log(counter.increase()); // NaN\n// increase 프로퍼티에 할당된 화살표 함수의 상위 스코프는 전역이다,,,,!\n\nclass Person {\n  constructor() {\n    this.name = 'Lee';\n    // 클래스가 생성한 인스턴스(this)의 sayHi 프로퍼티에 화살표 함수를 할당한다.\n    // 따라서 sayHi 프로퍼티는 인스턴스 프로퍼티다.\n    this.sayHi = () => console.log(`Hi ${this.name}`);\n    // sayHi의 상위 스코프는 클래스 외부이지만, 여기서 화살표 함수의 this는 constructor 내부의 this와 같다??\n  }\n}\n```\n\n이처럼 메서드(ES6이 아닌 일반적인 의미)를 화살표 함수로 정의하는 것은 피해야 한다.\n\n스코프에 대해서는 다시 공부해봐야할 듯^^; class도 결국엔 함수라는 것을 체화시켜야 할 듯. 486페이지다시 읽어보기. [실행 컨텍스트와 자바스크립트의 동작 원리](https://poiemaweb.com/js-execution-context)\n\n### 4. Rest 파라미터\n\n화살표 함수는 자신의 argument 객체를 가지지 않고, 접근한다해도 자신과 상관없는상위 함수에 전달된 인수 목록을 알게 되므로 쓸모가 없다. 화살표 함수로 가변 인자함수를 구현하기 위해서는 반드시 Rest 파라미터를 사용해야 한다.\n\n> Rest 파라미터는 함수에 전달된 인수들의 목록을 배열로 전달받는다.\n\n함수의 length 프로퍼티에 영향을 주지 않는다.\n\n유사 배열 객체인 arguments를 사용하는 번거로움을 피할 수 있다.\n\n## 27. 배열\n\n### 1. 배열이란?\n\n```js\nconst arr1 = [1, 2, 3];\nconsole.log(arr1.length); // 3\nconsole.log(arr1.constructor === Array); // true\nconsole.log(Object.getPrototypeOf(arr1) === Array.prototype); // true\n```\n\n배열은 일반 객체와 달리 값의 순서가 존재한다.\n\n### 2. 자바스크립트 배열은 배열이 아니다.\n\n> 자료구조에서 말하는 배열, 즉 밀집 배열(dense array)은 동일한 크기의 메모리 공간이 빈틈없이 연속적으로 나열된 자료구조이다.\n\n> 자바스크립트의 배열은 배열의 구조가 연속적으로 이어져있지 않은 희소 배열 (sparse array)이다.?\n\n자바스크립트의 배열은 일반적인 배열의 동작을 흉내 낸 특수한 객체다. 해시 테이블로 구현되어 인덱스 접근은 느리지만 요소의 삽입과 삭제는 빠르다.\n\n```js\nconst arr = [];\nconsole.time('Array Performance Test');\nfor (let i = 0; i < 10000000; i++) arr1[i] = i;\nconsole.timeEnd('Array Performance Test'); // 363.789ms\n\nconst obj = {};\nconsole.time('Object Performance Test');\nfor (let i = 0; i < 10000000; i++) obj[i] = i;\nconsole.timeEnd('Object Performance Test'); // 533.267ms\n```\n\n### 3. length 프로퍼티와 희소 배열\n\nlength 프로퍼티에 그 값보다 작은 값을 할당하면 배열의 길이가 줄어든다.\n\n```js\nconst arr1 = [1];\narr1.length = 3;\nconsole.log(arr1); // [ 1, <2 empty items> ]\nconsole.log(Object.keys(arr1)); // [ '0' ]\n```\n\n그보다 큰 값을 할당하면 변화가 없다. 자바스크립트는 배열의 요소가 일부가 비어있는 희소 배열을 허용한다.\n\n최적화 측면에서 희소 배열은 사용하지 않는 것이 좋다.\n\n### 4. 배열 생성\n\n```js\nlet arr1 = [1, , , 3];\nconsole.log(arr1.length); // 4\nconsole.log(arr1); // [ 1, <2 empty items>, 3 ]\nconsole.log(arr1[1]); // undefined\n\n// 전달된 인수가 1개고 숫자면 length프로퍼티 값이 인수인 배열을 생성\nconsole.log(new Array(10)); // [ <10 empty items> ]\nconsole.log(Array.of(10)); // [ 10 ]\n\n// 유사 배열 객체\nconst arrayLikeObject = { length: 2, 0: 'a', 1: 'b' };\nconsole.log(Array.from(arrayLikeObject)); // [ 'a', 'b' ]\n// 이터러블\nconsole.log(Array.from('Hello')); // [ 'H', 'e', 'l', 'l', 'o' ]\n```\n\n### 6. 배열 요소의 추가와 갱신\n\n현재 배열의 length 값보다 큰 인덱스로 요소(element)를 추가하면 희소 배열이 된다.\n\n0 이상의 정수를 사용하지 않으면 프로퍼티가 생성되고 lenght 값에 영향을 주지 않는다.\n\n### 7. 배열 요소의 삭제\n\ndelete로 프로퍼티를 삭제할 수 있지만 희소 배열이 되므로 추천하지 않는다.\n\n### 8. 배열 메서드\n\nmutator method(원본 변경)와 accessor method(새로운 객체 반환)로 구분된다. 부수효과 방지를 위해 후자가 권장된다.\n\n```js\nconst printAll = (x) => x.forEach((x) => console.log(x));\n\nprintAll([\n  Array.isArray({ length: 1, 0: 1 }), // false\n  [3, 1, 4].indexOf(4), // 2\n  [3, 1, 4].indexOf(9), // -1\n  [3, 1, 4].includes(9), // false\n  [1, 2, 3, 4].join('&'), // 1&2&3&4\n  [NaN].indexOf(NaN), // -1\n  [NaN].includes(NaN), // true\n  [1, 2, 3, 4].includes(1, 1), // false\n  [1, [2, [3, [4]]]].flat(1), // [ 1, 2, [ 3, [ 4 ] ] ]\n]);\n\nconst arr1 = [];\n// push 메서드는 성능 면에서 좋지 않다.\n// 스프레드 문법을 사용하면 표현식만으로 같은 작업을 부수효과 없이 할 수 있다.\nconsole.log(arr1.push(1, 2)); // 2, 변경된 length\nconsole.log(arr1); // [ 1, 2 ]\nconsole.log(arr1.pop()); // 2\nconsole.log(arr1); // [ 1 ]\n\nconsole.log(arr1.unshift('a')); // 2\nconsole.log(arr1); // [ 'a', 1 ]\nconsole.log(arr1.shift()); // a\nconsole.log(arr1); // [ 1 ]\n\n// 배열인 경우 배열을 해체. push/unshift와 다르다.\nconsole.log(arr1.concat([4])); // [ 1, 4 ]\nconsole.log(arr1.concat(4, 5)); // [ 1, 4, 5 ]\nconsole.log(arr1); // [ 1 ]\n\n// push/unshift, concat 대신 스프레드 문법을 일관성 있게 사용하는 것이 권장된다.\nconst arr2 = [1, 2, 3, 4, 5];\nconsole.log(arr2.splice(-2)); // [4, 5]\nconsole.log(arr2); // [1, 2, 3]\n// start, deleteCount, items\nconsole.log(arr2.splice(1, 1, 10, 11, 12)); // [2]\nconsole.log(arr2); // [1, 10, 11, 12, 3]\n\nconst arr3 = [1, 2, 3];\nconsole.log(arr3.slice(-2)); // [ 2, 3 ]\n// start, end\nconsole.log(arr3.slice(1, 2)); // [2]\n// 얕은 복사\nconst arr4 = [{ foo: 0 }];\nconst temp = arr4.slice();\nconsole.log(arr4 === temp); // false\nconsole.log(arr4[0] === temp[0]); // true\n\nconst arr5 = [1, 2, 3, 4];\nconsole.log(arr5.reverse()); // [4, 3, 2, 1]\nconsole.log(arr5); // [4, 3, 2, 1]\n\nconsole.log(arr5.fill(0, 1, 3)); // [4, 0, 0, 1]\nconsole.log(arr5); // [4, 0, 0, 1]\nconsole.log(Array.from({ length: 5 }, (_, i) => i)); // [0, 1, 2, 3, 4]\n```\n\nslice, 스프레드 문법, Object.assign 메서드는 모두 얕은 복사를 수행한다. 깊은 복사를 위해서는 [참고](https://lodash.com/docs/4.17.15#cloneDeep)\n\n### 9. 배열 고차 함수\n\n고차 함수(Highter-Order Function, HOF)\n\n고차 함수는 외부 상태의 변경이나 가변(mutable) 데이터를 피하고 불변성 (immutability)을 지향하는 함수형 프로그래밍에 기반을 두고 있다.\n\n> 함수형 프로그래밍은 순수 함수(pure function)와 보조 함수의 조합을 통해 로직 내에 존재하는 조건문과반복문을 제거하여 복잡성을 해결하고 변수의 사용을 억제하여 상태 변경을 피하려는 프로그래밍 패러다임이다.\n\n```js\nconst alphabets = Array.from('alphabets');\nalphabets.sort();\nconsole.log(alphabets);\n/*\n[\n  'a', 'a', 'b',\n  'e', 'h', 'l',\n  'p', 's', 't'\n]\n*/\n// sort 메서드의 기본 정렬은 유니코드 코드 포인트를 따른다.\nconsole.log([30, 40, 1, 3, 25].sort()); // [ 1, 25, 3, 30, 40 ]\n// 0보다 작으면 첫번째 인수가 우선\nconsole.log([30, 40, 1, 3, 25].sort((a, b) => a - b)); // [ 1, 3, 25, 30, 40 ]\n// ES10이전에는 퀵 소트, 이후에는 timsort를 사용한다.\n\n[1, 2, 3].forEach((item, index, arr) => {\n  console.log(item, index, arr);\n});\n/*\n1 0 [ 1, 2, 3 ]\n2 1 [ 1, 2, 3 ]\n3 2 [ 1, 2, 3 ]\n*/\n// 희소 배열에서 존재하지 않는 요소는 순회하지 않는다.\n// for문보다 성능이 좋지는 않다.\n\nconsole.log([1, 2, 3].map((item, index, arr) => ({ item, index, arr })));\n/*\n[\n  { item: 1, index: 0, arr: [ 1, 2, 3 ] },\n  { item: 2, index: 1, arr: [ 1, 2, 3 ] },\n  { item: 3, index: 2, arr: [ 1, 2, 3 ] }\n]\n*/\n\n// 책에서와 VSCode 팝업?의 변수 이름이 다름.\n// 책에서는 accumulator, 여기서는 previousValue\nconsole.log(\n  [1, 2, 3, 4].reduce((previousValue, currentValue, currentIndex, array) => {\n    console.log(previousValue, currentValue, currentIndex, array);\n    return previousValue + currentValue;\n  })\n);\n/*\n1 2 1 [ 1, 2, 3, 4 ]\n3 3 2 [ 1, 2, 3, 4 ]\n6 4 3 [ 1, 2, 3, 4 ]\n10\n*/\n// reduce 메서드를 호출할 때는 초기값을 생략하지 않고 언제나 전달하는 것이 안전하다.\n\nconsole.log([1, 3, 5, 7].some((x) => x % 2 == 0)); // false\nconsole.log([1, 3, 5, 7].every((x) => x % 2)); // true\nconsole.log([].some((x) => x)); // false\nconsole.log([].every(() => false)); // true\n\nconsole.log(Array.from({ length: 5 }, (_, i) => ({ id: i * 2 })).find((x) => x.id == 8)); // { id: 8 }\n\nconsole.log(Array.from({ length: 5 }, (_, i) => ({ id: i * 2 })).findIndex((x) => x.id == 8)); // 4\n\nconst arr = ['hello', 'world'];\n// map에서 생성된 배열을 평탄화한다\nconsole.log(arr.flatMap((x) => Array.from(x).reverse()));\n/*\n[\n  'o', 'l', 'l', 'e',\n  'h', 'd', 'l', 'r',\n  'o', 'w'\n]\n*/\n```\n\n> 최신 사양의 기능을 지원하지 않는 브라우저를 위해 누락된 최신 사양의 기능을 구현하여 추가하는 것을폴리필(polyfill)이라 한다.\n\n## 28. Number\n\nMAX_SAFE_INTEGER: 자바스크립트는 Number에서 부동소수점을 사용하기 때문. [참고](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER)\n\n## 31. RegExp\n\n### 1. 정규 표현식이란?\n\n> 정규표현식은(regular expression)은 일정한 패턴을 가진 문자열의 집합을 표현하기위해 사용하는 형식언어(formal language)다.\n\n### 2. 정규 표현식의 생성\n\n```js\nconst target = 'regexConstruct';\nconst regexp = /co/i;\nconsole.log(regexp.test(target)); // true\n```\n\nRegex 생성자 함수로 동적인 Regex 객체를 만들 수 있다.\n\n### 3. Regex 메서드\n\n```js\nconst target = 'onetwothreetwo';\n\nconsole.log(/two/g.exec(target));\n// [ 'two', index: 3, input: 'onetwothree', groups: undefined ]\n// g가 있어도 첫번째 매칭 결과만 반환한다.\n\nconsole.log(/two/.test(target)); // true\n\nconsole.log(target.match(/two/));\n// [ 'two', index: 3, input: 'onetwothreetwo', groups: undefined ]\nconsole.log(target.match(/two/g));\n// [ 'two', 'two' ]\n```\n\n### 4. 플래그\n\ni: ignore case g: global m: multiline\n\n### 5. 패턴\n\n여기 이후는 저 자세히 설명되어있는 EloquentJavascript에서 다시 읽어보기.\n\n```txt\n(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|\"(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21-\\x5a\\x53-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\])\n```\n\n[이메일 regex...](https://emailregex.com)\n\n## 32. String\n\n### 1. String 생성자 함수\n\nnew 연산자를 사용하지 않고 String 생성자 함수를 호출하면 String 인스턴스가 아닌문자열을 반환한다.\n\n### 2. length 프로퍼티\n\nString은 length 프로퍼티를 갖기에 유사 배열 객체다.\n\n### 3. String 메서드\n\nString 래퍼 객체도 읽기 전용 객체로 제공된다.\n\n```js\nconsole.log('ABCDE'.indexOf('C')); // 2\nconsole.log('ABCDE'.indexOf('C', 3)); // -1\nconsole.log('ABCDE'.includes('C')); // true\nconsole.log('AB010CD010'.search(/010/)); // 2\n\nconsole.log('ABCDE'.startsWith('ABC')); // true\n// 인덱스 2로부터 시작하는 문자열이 'CD'로 시작하는지 확인\nconsole.log('ABCDE'.startsWith('CD', 2)); // true\n\nconsole.log('ABCDE'.endsWith('DE')); // true\n// 처음부터 3자리까지가 BC로 끝나는지 확인\nconsole.log('ABCDE'.endsWith('BC', 3)); // true\n\n// charAt, charCodeAt, codePointAt 생략\n\nconsole.log('ABCDE'.substring(1, 3)); // BC\nconsole.log('ABCDE'.slice(-2)); // DE\n\nconsole.log('abcde'.toUpperCase()); // ABCDE\n// Swift에서도 uppercase 관련을 계산 프로퍼티가 아니라 [메소드](https://developer.apple.com/documentation/swift/string/uppercased())로 제공하는데 O(n)이라는 긴 시간을 가져서 그런듯.\nconsole.log('ABCDE'.toLowerCase()); // abcde\nconsole.log('   foo   '.trim()); // foo, trimStart와 trimEnd도 있음.\nconsole.log('blah'.repeat(5)); // blahblahblahblahblah\n\nconsole.log('blahblah'.replace('blah', 'bleh')); // blehblah\nconsole.log('blahblah'.replace(/blah/, 'bleh')); // blehblah\nconsole.log('blahblah'.replace(/blah/g, 'bleh')); // blehbleh\nconsole.log('blahblah'.replace(/blah/g, '!$&!')); // !blah!!blah!\n\nconsole.log('A B C D E'.split(' ')); // [ 'A', 'B', 'C', 'D', 'E' ]\n```\n\n## 33. 7번째 데이터 타입 Symbol\n\n### 2. 심벌 값의 생성\n\nSymbol 함수는 new 연산자와 함께 호출하지 않는다. 심벌 값은 객체가 아닌 변경 불가능한 원시 값이다.\n\n```js\n// 전역 심벌 레지스트리(global symbol registry)에서 검색\nconst s1 = Symbol.for('ABC');\nconst s2 = Symbol.for('ABC');\nconsole.log(s1 === s2); // true\nconsole.log(Symbol.keyFor(s1)); // ABC\n```\n\n### 3. 심벌과 상수\n\n```js\n// JS에서 enum 흉내내기\nconst Direction = Object.freeze({\n  UP: Symbol('up'),\n  DOWN: Symbol('down'),\n  LEFT: Symbol('left'),\n  Right: Symbol('right'),\n});\n```\n\n### 7. Well-known Symbol\n\n> 자바스크립트가 기본 제공하는 빌트인 심벌 값을 ECMAScript 사양에서는 Well-known Symbol이라 부른다.\n\nSymbol.iterator 등등\n\n이처럼 심벌은 중복되지 않는 상수 값을 생성하는 것은 물론 기존에 작성된 코드에 영향을 주지 않고 새로운 프로퍼티를 추가하기 위해, 즉 하위 호환성을 보장하기 위해도입되었다.\n\n## 34. 이터러블\n\n### 1. 이터레이션 프로토콜\n\n> ES6에서 도입된 iteration protocol은 순회 가능한(iterable) 데이터 컬렉션(자료구조)을 만들기 위해 ECMAScript 사양에 정의하여 미리 약속한 규칙이다.\n\n이터레이션 프로토콜에는 이터러블 프로토콜과 이터레이터 프로토콜이 있다.\n\n- 이터러블 프로토콜: 이터레이터를 반환. for...of, 스프레드 문법, 배열 디스트럭처링 할당.\n- 이터레이터 프로토콜: next 메서드 소유, iterator result object를 반환.\n\n스프레드 프로퍼티 제안은 일반 객체에 스프레드 문법의 사용을 허용한다.\n\n```js\nconst arr = [1, 2, 3];\nconst iterator = arr[Symbol.iterator]();\nconsole.log(iterator.next());\nconsole.log(iterator.next());\nconsole.log(iterator.next());\nconsole.log(iterator.next());\nconsole.log(iterator.next());\n/*\n{ value: 1, done: false }\n{ value: 2, done: false }\n{ value: 3, done: false }\n{ value: undefined, done: true }\n{ value: undefined, done: true }\n*/\n```\n\n### 3. for...of문\n\n```js\nconst iterable = [1, 2, 3];\nconst iterator = iterable[Symbol.iterator]();\nwhile (true) {\n  const res = iterator.next();\n  if (res.done) break;\n  console.log(res.value);\n}\n// 1 2 3\n```\n\n### 4. 이터러블과 유사 배열 객체\n\n유사 배열 객체는 for...of로 순회할 수 없다. Array.from으로 배열로 변환할 수 있다 .\n\n```js\nconst obj = { x: 1 };\nobj[Symbol.iterator] = () => ({\n  next() {\n    return {};\n  },\n});\n\nfor (let x of obj) {\n  console.log(x);\n}\n\n// 위 상황에서는 undefined가 계속 불리고, (done이 undefined라서 false로 평가?)\n// next가 없으면 undefined를 호출할 수 없다고 하며,\n// next가 아무것도 반환하지 않으면 TypeError: Iterator result undefined is not an object\n```\n\n### 6. 사용자 정의 이터러블\n\n이터러블이면서 이터레이터인 객체를 생성하는 함수\n\n```js\nconst fibo = function (max) {\n  let [pre, cur] = [0, 1];\n  return {\n    [Symbol.iterator]() {\n      return this;\n    },\n    next() {\n      [pre, cur] = [cur, pre + cur];\n      return { value: cur, done: cur >= max };\n    },\n  };\n};\n\nlet iter = fibo(10);\nfor (const x of iter) {\n  console.log(x); // 1 2 3 5 8\n}\n\niter = fibo(10);\nconsole.log(iter.next());\nconsole.log(iter.next());\nconsole.log(iter.next());\n```\n\n무한 이터러블을 생성하는 함수를 통해 무한 수열을 구현할 수 있다.\n\n> 지연 평가는 데이터가 필요한 시점 이전까지는 미리 데이터를 생성하지 않다가 필요한 시점이 되면 그때야 데이터를 생성하는 기법이다.\n\n무한 이터러블을 통해 지연 평가를 사용한 데이터 생성이 가능하다.\n\n## 35. 스프레드 문법\n\n> ES6에서 도입된 스프레드 문법은 하나로 뭉쳐있는 여러 값들의 집합을 펼쳐서 개별적인 값들의 목록으로만든다.\n\n스프레드 문법의 결과는 값이 아니고, 따라서 ... 은 연산자가 아니다. 쉼표로 구분한값의 목록을 사용하는문백에서만 사용할 수 있다.\n\nRest 파라미터와 스프레드 문법은 서로 반대의 개념이다.\n\n```js\n// Rest parameter\nfunction foo(...rest) {\n  console.log(rest);\n}\n// Spread syntax\nfoo(...[1, 2, 3]);\n```\n\n```js\nconst arr = [1, 2, 3];\narr.splice(1, 0, ...['a', 'b']);\nconsole.log(arr); // [ 1, 'a', 'b', 2, 3 ]\n\nconst a = [1, 2];\nconst b = [...a];\nconsole.log(a === b); // false\n\n// 이터러블을 배열로 변환\nconst sum = (...args) => args.reduce((a, b) => a + b);\n// 이터러블이 아닌 유사 배열 객체는 Array.from을 사용한다.\n\n// 스프레드 프로퍼티 제안은 일반 객체를 상대로도 스프레드 문법의 사용을 허용한다.\nconst obj = { x: 1, y: 2 };\nconst copy = { ...obj };\nconsole.log(copy); // { x: 1, y: 2 }\n```\n\n## 36. 디스트럭처링 할당\n\n> 디스트럭처링 할당(destructuring assignment)은 구조화된 배열과 같은 이터러블 또는 객체를 destructuring하여 1개 이상의 변수에 개별적으로 할당하는 것을 말한다.\n\n```js\nconst arr = [1, 2];\nconst [one, two] = arr;\n\nconst [, dul, set = 3] = arr;\nconsole.log(dul, set); // 2 3\n\n// Rest 요소. rest element\nconst [x, ...y] = [1, 2, 3];\nconsole.log(x, y); // 1 [2, 3]\n\n// ES6 객체 디스트럭처링 할당\nconst obj = { a: 1, b: 2 };\nconst { c = 3, a, b } = obj;\nconsole.log(a, b, c); // 1 2 3\nconst { a: aa, b: bb, c: cc } = obj;\nconsole.log(aa, bb, cc); // 1 2 undefined\n\nfunction foo({ a, b, c }) {\n  console.log(a, b, c);\n}\n\nfoo(obj); // 1 2 undefined\n\n// 배열 디스트럭처링 할당과 객체 디스트렁처링 할당의 혼용\nconst d = [{ id: 1 }, { id: 2 }, { id: 3 }];\nconst [, { id }] = d;\nconsole.log(id); // 2\n\n// Rest 프로퍼티 ...\nconst { xx, ...rest } = { xx: 1, yy: 2, zz: 3 };\nconsole.log(xx, rest); // 1 { yy: 2, zz: 3 }\n```\n\n## 37. Set과 Map\n\n### 1. Set\n\n```js\n// 이터러블을 인수로 전달받는다.\nconst set1 = new Set([3, 2, 1, 2]);\nconsole.log(set1); // Set(3) { 3, 2, 1 }\n\n// size 프로퍼티는 getter 함수만 존재한다.\nconsole.log(set1.size); // 3\n\n// add 메서드는 method chaining이 가능하다.\nconst set2 = new Set();\nset2.add(1).add(2);\nconsole.log(set2); // Set(2) { 1, 2 }\n\nconsole.log(set2.has(3)); // false\n\nconsole.log(set2.delete(2)); // true\nconsole.log(set2.has(2)); // false\n\nset2.clear();\n\n// const set3 = Set([1, 2, 3]); TypeError: Constructor Set requires 'new'\n\nconst set3 = new Set([1, 2, 3]);\nset3.forEach((v, v2, set) => console.log(v, v2, set));\n/*\n첫번째 인수과 두번째 인수가 같은데 이는 Array.prototype.forEach 메서드와 인터페이스를 통일하기 위함이며 다른 의미는 없다. \n1 1 Set(3) { 1, 2, 3 }\n2 2 Set(3) { 1, 2, 3 }\n3 3 Set(3) { 1, 2, 3 }\n*/\n\nconsole.log(Symbol.iterator in set3); // true\n\n// 교집합 구현\nSet.prototype.intersection = function (set) {\n  return new Set([...this].filter((x) => set.has(x)));\n};\n\n// 합집합 구현\nSet.prototype.union = function (set) {\n  return new Set([...this, ...set]);\n};\n```\n\n### 2. Map\n\n> Map 객체는 키와 값의 쌍으로 이루어진 컬렉션이다.\n\n```js\n// const map1 = new Map(['key1', 'value1'], ['key2', 'value2']);\n// TypeError: Iterator value key1 is not an entry object\n\nconst map1 = new Map([\n  ['key1', 'value1'],\n  ['key2', 'value2'],\n]);\nconsole.log(map1); // Map(2) { 'key1' => 'value1', 'key2' => 'value2' }\n\nconsole.log(map1.size); // 2\n\nmap1.set('key3', 'value3');\n\n// 키 타입에 제한이 없다.\nconst key = { id: 1 };\nmap1.set(key, 'One');\n\nconsole.log(map1.get(key)); // One\nconsole.log(map1.get({ id: 1 })); // undefined\n\nconsole.log(map1.has('key1')); // true\n\nconsole.log(map1.delete('key4')); // false\n\nmap1.clear();\n\nconst map2 = new Map([\n  ['key1', 'value1'],\n  ['key2', 'value2'],\n]);\nmap2.forEach((v, k, map) => console.log(v, k, map));\n/*\nvalue1 key1 Map(2) { 'key1' => 'value1', 'key2' => 'value2' }\nvalue2 key2 Map(2) { 'key1' => 'value1', 'key2' => 'value2' }\n*/\n\nconsole.log(Symbol.iterator in map2); // true\n\nconsole.log(map2.keys()); // [Map Iterator] { 'key1', 'key2' }\nconsole.log(map2.values()); // [Map Iterator] { 'value1', 'value2' }\nconsole.log(map2.entries()); // [Map Entries] { [ 'key1', 'value1' ], [ 'key2', 'value2' ] }\n```\n\nSet과 Map 모두 요소의 순서에 의미를 갖지 않지만 다른 이터러블의 순회와 호환성을유지하기 위해 객체 순회 순서가 요소 추가 순서에 따른다.\n\n## 38. 브라우저의 렌더링 과정\n\n> 파싱(구문 분석, syntax analysis)은 프로그래밍 언어의 문법에 맞게 작성된 텍스트문서를 읽어 들여 실행하기 위해 텍스트 문서의 문자열을 토큰으로 분해(어휘 분석, lexical analysis)하고, 토큰에 문법적의미와 구조를 반영하여 트리 구조의 자료구조인 parse tree/syntax tree를 생성하는 일련의 과정을 말한다 . 일반적으로 파싱이완료된 이후에는 parse tree를 기반으로 중간언어(intermediate code)인 바이트 코드 (byte code)를 생성하고 실행한다.\n\n> 렌더링(renderind)은 HTML, CSS, JS로 작성된 문서를 파싱하여 브라우저에 시각적으로 출력하는 것을 말한다.\n\n1. 렌더링에 필요한 리소스 요청, 서버로부터 응답\n2. HTML -> DOM / CSS -> CSSOM. 둘을 결합하여 렌더 트리 생성\n3. 서버로부터 온 JS를 파싱해 AST(Abstract Syntax Tree) 생성, 바이트코드로 변환해실행. JS를 통해 DOM/CSSOM을 변경할 수 있다.\n4. 렌더 트리를 기반으로 HTML 요소의 레이아웃을 계산하고 화면에 페인팅\n\n### 1. 요청과 응답\n\nURI, URL, URN, Scheme(Protocol), Host(Domain), Port, Path, Query(Query String), Fragment...\n\n브라우저의 렌더링 엔진은 HTML을 파싱하는 도중에 외부 리소스를 로드하는 태그를 만나면 파싱을 일시중지하고 해당 리소스 파일을 서버로 요청한다.\n\n### 2. HTTP 1.1과 HTTP 2.0\n\nHTTP/1.1은 커넥션당 하나의 요청과 응답만 처리한다. 리소스들에 대한 요청들이 개별적으로 전송되고 응답또한 개별적으로 전송된다. 리소스의 개수에 비례해 응답 시간이 증가한다.\n\nHTTP/2는 다중 요청/응답이 가능하다.\n\n[Introduction to HTTP/2](https://web.dev/performance-http2/)\n\n### 3. HTML 파싱과 DOM 생성\n\nDOM(Document Object Model)\n\n1. 서버로부터 응답된 HTML 문서는 meta 태그의 charset 어트리뷰트에 따라 문자열로변화된다. 이 정보는 content-type: text/html; charset=utf-8과 같이 응답 헤더 (response header)에 담겨 응답된다.\n2. 문자열로 변환된 HTML 문서는 토큰들로 분해된다.\n3. 각 토큰을 객체로 변환하여 노드(node)를 생성한다. 이 노드는 DOM을 구성하는 기본 요소가 된다.\n4. 노드들을 트리 자료구조로 구성한 DOM을 생성한다.\n\n### 4. CSS 파싱과 CSSOM 생성\n\nHTML과 동일한 파싱 과정으로 CSSOM(CSS Object Model)을 생성한다. CSSOM은 CSS의 상속을 반영하여 생성된다.\n\n### 5. 렌더 트리 생성\n\nDOM과 CSSOM은 렌더 트리(render tree)로 결합된다. 화면에 렌더링되지 않는 노드와 CSS에 의해 숨겨지는노드들은 포함되지 않는다. 렌더 트리는 HTML 요소의 레이아웃계산에 사용되며 브라우저 화면에 픽셀을 렌더링하는 페인팅(painting) 처리에 입력된다 .\n\nRender tree -> Layout -> Paint. 리렌더링이 빈번하지 않도록 주의해야한다.\n\n### 6. 자바스크립트 파싱과 실행\n\nDOM API를 통해 이미 생성된 얘ㅡ을 동적으로 조작할 수 있다.\n\n렌더링 엔진은 HTML을 파싱하다 JS 파일을 만나면 DOM 생성을 일시 중단하고 자바스크립트 엔진에 제어권을넘긴다. 엔진은 코드를 해석하여 AST(Abstract Syntax Tree, 추상적 구문 트리)를 생성하고, 인터프리터가실행 가능한 중간 코드(intermeditate code)인 바이트 코드를 생성해 실행한다.\n\n- 토크나이징: 코드를 어휘 분석(lexical analysis)하여 문법적 의미를 가지는 최소단위인 토큰(token)들로분해한다.\n- 파싱: 토큰들의 집합을 구문 분석(syntactic analysis)하여 AST를 생성한다. AST는토큰에 문법적 의미와구조를 반영한 트리 구조의 자료구조다. AST를 통해 TypeScript, Babel, Prettier같은 transpiler를 구현할 수도 있다.\n- 바이트코드 생성과 실행: V8은 터보팬(TurboFan)이라는 컴파일러에 의해 최적화된머신 코드로 컴파일되어성능을 최적화한다. 코드의 사용 빈도가 적어지면 다시 디옵티마이징(deoptimizing)하기도 한다.\n\n### 7. 리플로우와 리페인트\n\n> 변경된 DOM과 CSSOM은 다시 렌더 트리로 결합되고 변경된 렌더 트리를 기반으로 레이아웃과 페인트 과정을 거쳐 브라우저의 화면에 다시 렌더링한다. 이를 리플로우 (reflow), 리페인트(repaint)라 한다.\n\n리플로우는 레이아웃 변경이 발생한 경우에 한해 실행되고, 리페인트는 렌더 트리를기반으로 다시 페인트를하는 것을 말한다.\n\n### 8. 자바스크립트 파싱에 의한 HTML 파싱 중단\n\nbody 요소 가장 아래에 JS를 위치시키는 것은 좋은 아이디어다.\n\n- DOM 미완성일 때 DOM을 조작하면 에러가 발생할 수 있다.\n- JS 로딩/파싱/실행으로 인한 렌더링 지장이 없다.\n\n### 9. script 태그의 async/defer 어트리뷰트\n\n앞선 blocking 문제 때문에 HTML5부터 async와 defer 어트리뷰트가 추가되었다.\n\naync는 HTML 파싱과 JS 로드가 동시에 일어나고, JS 파싱과 실행이 로드 완료 직후 HTML 파싱을 중단시키고진행된다. 여러 async 끼리의 순서가 보장되지 않는다.\n\ndefer는 JS 파싱과 실행이 DOM 생성 직후에 진행된다.\n\n## 39. DOM\n\n> DOM(Document Object Model)은 HTML 문서의 계층적 구조와 정보를 표현하며 이를 제어할 수 있는 API, 즉프로퍼티와 메서드를 제공하는 트리 자료구조다.\n\n### 1. 노드\n\n> HTML 요소는 HTML 문서를 구성하는 개별적인 요소를 의미한다. 시작 태그, 어트리뷰트 이름, 어트리뷰트값, 콘텐츠, 종료 태그로 구성된다.\n\nHTML 요소는 파싱되어 요소 노드 객체로 변환된다. HTML 요소간에는 계층적인 부자 관계가 있기에 트리 자료구조로 구성된다.\n\n노드 객체들로 구성된 트리 자료구조를 DOM이라 한다. 총 12종류가 있고 중요한 4종류는 아래와 같다.\n\n- 문서 노드: 최상위 루트 노드. window.document. entry point 역할\n- 요소 노드: HTML 요소. 부자 관계를 가짐.\n- 어트리뷰트 노드: 부모 노드 없이 요소 노드와 연결되어 요소의 어트리뷰트 가리킴.\n- 텍스트 노드: 텍스트, 문서의 정보를 표현. leaf node.\n\n모든 노드 객체는 Object, EventTarget(이벤트를 발생시키는 객체), Node(트리 자료구조의 노드 객체) 인터페이스를 상속받는다.\n\n프런트엔드 개발자에게 HTML은 단순히 태그와 어트리뷰트를 선언적으로 배치하여 뷰를구성하는 것 이상의의미를 갖는다. 즉, HTML을 DOM과 연관 지어 바라보아야 한다.\n\n### 2. 요소 노드 취득\n\n```html\n<!DOCTYPE html>\n<html>\n  <body>\n    <ul>\n      <!-- id는 class와 달리 공백 문자로 구분하여 여러 값을 가질 수 없다 -->\n      <li id=\"apple\" class=\"temp\">Apple</li>\n      <li id=\"banana\" class=\"temp\">Banana</li>\n      <li id=\"orange\">Orange</li>\n      <li id=\"banana\">Banana</li>\n    </ul>\n    <script>\n      let $elem = document.getElementById('banana');\n      $elem.style.color = 'red';\n\n      // 반환값인 HTMLCollection 객체는 유사 배열 객체이면서 이터러블이다.\n      // Element.prototype.getElementsByClassName은 요소 노드의 자손 노드를 탐색한다.\n      let $elems = document.getElementsByTagName('li');\n      for (let elem of $elems) {\n        console.log(elem.innerText);\n      }\n\n      $elems = document.getElementsByClassName('temp');\n      for (let elem of $elems) {\n        console.log(elem.innerText);\n      }\n\n      // 인수로 전달한 CSS 선택자를 만족시키는 하나의 요소 노드를 탐색하여 반환\n      // querSelectorAll은 여러 요소 노드 객체를 갖는 DOM 컬렉션 객체인 NodeList를 반환\n      // getElementBy어쩌구보다 느리지만 구체적인 조건을 입력할 수 있기에 id가 있으면 전자, 그 외에는 후자를 사용하는 것을 권장\n      console.log(document.querySelector('#apple'));\n    </script>\n  </body>\n</html>\n```\n\n**HTMLCollection**\n\n- 객체의 상태 변화를 실시간으로 반영하는 live object이다.\n\n**NodeList**\n\n- 대부분 변화 반영 안하고 정적\n- NodeList.prototype.forEach를 상속받아 사용할 수 있다.\n- childNodes 프로퍼티가 반환하는 NodeList 객체는 live object이다.\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <style>\n      .blue {\n        color: blue;\n      }\n    </style>\n  </head>\n  <body>\n    <ul>\n      <!-- id는 class와 달리 공백 문자로 구분하여 여러 값을 가질 수 없다 -->\n      <li class=\"temp\">Apple</li>\n      <li class=\"temp\">Banana</li>\n      <li class=\"temp\">Orange</li>\n    </ul>\n    <script>\n      const $elems = document.getElementsByClassName('temp');\n      for (let i = 0; i < $elems.length; i++) {\n        $elems[i].className = 'blue';\n      }\n\n      // 더 나은 방법. 객체로 변환하여 사용.\n      // 바로 forEach 안된다는 점 주의\n      // [...$elems].forEach(x => x.className = 'blue');\n      console.log($elems); // 길이 0인 HTMLCollection\n    </script>\n  </body>\n</html>\n```\n\n노드 객체의 상태 변경과 상관없이 안전하게 DOM 컬렉션을 사용하려면 HTMLCollection 이나 NodeList 객체를 배열로 변환하여 사용하는 것을 권장한다.\n\n### 3. 노드 탐색\n\nNode.prototype: parentNode, previousSibling, firstChild, childNodes Element.prototype: previousElementSibling, nextElementSibling\n\nhtml 요소 사이의 white space는 텍스트 노드를 생성한다.\n\n```html\n<!DOCTYPE html>\n<html>\n  <body>\n    <ul id=\"fruits\">\n      <!-- id는 class와 달리 공백 문자로 구분하여 여러 값을 가질 수 없다 -->\n      <li id=\"apple\" class=\"temp\">Apple</li>\n      <li id=\"banana\" class=\"temp\">Banana</li>\n      <li id=\"orange\">Orange</li>\n    </ul>\n    <script>\n      const $fruits = document.getElementById('fruits');\n      // 텍스트 노드 포함\n      console.log($fruits.childNodes); // NodeList(9). comment도 포함!\n      // 요소 노드만\n      console.log($fruits.children); // HTMLCollection(3)\n      // firstChild, lastChild는 텍스트 노드 포함\n      // firstElementChild, lastElementChild는 요소 노드만\n      console.log($fruits.hasChildNodes()); // true. 텍스트 노드 포함\n\n      // 요소 노드만\n      console.log($fruits.children.length); // 3\n      console.log($fruits.childElementCount); // 3\n\n      // 텍스트 노드 접근\n      // 텍스트 노드나 요소 노드를 반환\n      const $apple = document.getElementById('apple');\n      console.log($apple.firstChild); // #text\n\n      console.log($apple.parentNode); // ul#fruits\n\n      // previousSibling, nextSibling은 텍스트 노드 포함\n      // previousElementSibling, nextElementSibling은 요소 노드만\n    </script>\n  </body>\n</html>\n```\n\n### 4. 노드 정보 취득\n\n```html\n<!DOCTYPE html>\n<html>\n  <body>\n    <div id=\"foo\">Hello</div>\n  </body>\n  <script>\n    // ELEMENT_NODE 1, TEXT_NODE 3, DOCUMENT_NODE 9\n    console.log(document.nodeType == Node.DOCUMENT_NODE); // true\n    // UL/LI..., #text, #document\n    console.log(document.nodeName); // #document\n  </script>\n</html>\n```\n\n### 5. 요소 노드의 텍스트 조작\n\n```html\n<body>\n  <div id=\"foo\">Hello</div>\n  <div id=\"bar\">Hello <span>World!</span></div>\n</body>\n<script>\n  // nodeValue는 노드 객체의 값, 즉 텍스트 노드의 텍스트를 반환한다.\n  document.getElementById('foo').firstChild.nodeValue = 'Bye';\n\n  // textContent는 childNodes 프로퍼티가 반환한 모든 노드들의 텍스트 노드의 값을 반환한다.\n  // nodeValue보다 간편하다.\n  const $bar = document.getElementById('bar');\n  console.log($bar.textContent); // Hello World!\n  console.log($bar.childNodes.length); // 2\n  $bar.textContent = 'Hello World!';\n  console.log($bar.childNodes.length); // 1\n</script>\n```\n\ninnerText는 CSS에 순종적(visibility등에 영향)이고 느리므로 사용하지 않는 것이 좋다.\n\n### 6. DOM 조작\n\n```html\n<body>\n  <div id=\"bar\">Hello <span>World!</span></div>\n</body>\n<script>\n  // Element.prototype.innerHTML\n  console.log(document.getElementById('bar').innerHTML); // Hello <span>World!</span>\n  document.getElementById('bar').innerHTML = '<strong>Hello!<strong>';\n\n  // untrusted input data를 innerHTML에 할당하는 것은 XSS(Cross-site Scripting Attacks)에 취약하다.\n  // HTML sanitization은 잠재적 위험을 제거할 수 있다.\n\n  // insertAdjacentHTML도 HTML 문자열을 파싱하므로 위험하다.\n\n  // const textNode = document.createTextNode('Banana');\n  // $li.textContent = 'banana'; 안에 아무것도 없는게 맞으면 이게 간단\n\n  const $bar = document.getElementById('bar');\n\n  // DOM 변경이 3번 발생한다.\n  // ['Apple', 'Banana', 'Orange'].forEach(x => {\n  //     const $li = document.createElement('li');\n  //     $li.textContent = x;\n  //     $bar.appendChild($li);\n  // })\n\n  // 불필요한 컨테이너 요소(div)가 추가된다.\n  // const $container = document.createElement('div');\n  // ['Apple', 'Banana', 'Orange'].forEach(x => {\n  //     const $li = document.createElement('li');\n  //     $li.textContent = x;\n  //     $container.appendChild($li);\n  // })\n  // $bar.appendChild($container);\n\n  // DocumentFragment 노드는 별도의 서브 DOM을 구성하여 기존 DOM에 추가하기 위한 용도로 사용된다.\n  const $fragment = document.createDocumentFragment();\n  ['Apple', 'Banana', 'Orange'].forEach((x) => {\n    const $li = document.createElement('li');\n    $li.textContent = x;\n    $fragment.appendChild($li);\n  });\n  $bar.appendChild($fragment);\n\n  const $childNode = $bar.children[2];\n  $bar.insertBefore(document.createTextNode('New'), $childNode);\n\n  const [, , $banana] = $bar.children;\n  // 이미 존재하는 노드를 추가하면 현재 위치에서 제거하고 추가한다.\n  $bar.append($banana);\n\n  $banana.append($banana.cloneNode()); // 자손이 복사되지 않으므로 텍스트 없음\n  $banana.append($banana.cloneNode(true));\n\n  $bar.replaceChild(document.createTextNode('NewBanana'), $bar.firstChild);\n\n  $bar.removeChild($bar.lastChild);\n</script>\n```\n\n### 7. 어트리뷰트\n\nHTML 요소가 파싱될 때 어트리뷰트는 어트리뷰트 노드로 변환되어 요소 노드와 연결된다. 어트리뷰트당 하나의 노드가 생성된다.\n\n```html\n<body>\n  <input id=\"user\" type=\"text\" value=\"yeolyi\" />\n  <script>\n    const $input = document.getElementById('user');\n\n    console.log($input.attributes);\n    // NamedNodeMap {0: id, 1: type, 2: value, id: id, type: type, value: value, length: 3}\n    // getter만 존재\n    console.log($input.attributes.type); // type=\"text\"\n\n    $input.setAttribute('value', 'foo');\n    console.log($input.getAttribute('value')); // foo\n\n    // hasAttribute, removeAttribute\n  </script>\n</body>\n```\n\nHTML 어트리뷰트는 1. 요소 노드의 attributes 프로퍼티 2. 각 어트리뷰트에 대응되는요소 노드의 프로퍼티 (이하 DOM 프로퍼티) 로 중복 관리되는 것 같지만 다르다.\n\n요소 노드의 초기 상태(새로고침 등 상황에서 사용)는 어트리뷰트 노드가, 최신 상태는 DOM 프로퍼티가 관리한다.\n\n사용자 입력과 관계있는 DOM 프로퍼티만 최신 상태 값을 관리하고, 그 이외에는 어트리뷰트와 DOM 프로퍼티가 동일한 값으로 연동된다.\n\n```html\n<body>\n  <ul class=\"fruits\">\n    <li data-original-cost=\"100\">Apple</li>\n    <li data-original-cost=\"1200\">Banana</li>\n    <li data-original-cost=\"3000\">Watermelon</li>\n  </ul>\n</body>\n<script>\n  const fruits = document.querySelector('.fruits').children;\n  [...fruits].forEach((x) => {\n    // 케밥케이스와 카멜케이스 간 변환이 이루어짐\n    console.log(x.dataset.originalCost); // 100 1200 3000\n    x.dataset.camelCase = true;\n    console.log(x);\n    // <li data-original-cost=\"3000\" data-camel-case=\"true\">Watermelon</li>...\n  });\n</script>\n```\n\n### 8. 스타일\n\n```html\n<style>\n  .box {\n    width: 100px;\n    height: 100px;\n    background-color: antiquewhite;\n  }\n  .red {\n    color: red;\n  }\n  .blue {\n    color: blue;\n  }\n</style>\n<body>\n  <div style=\"color: red\">Hello World</div>\n  <div class=\"box red\">Hello World</div>\n</body>\n<script>\n  const $div = document.querySelector('div');\n  console.log($div.style); // CSSStyleDeclaration 반환\n  $div.style.backgroundColor = 'royalBlue'; // 인라인 스타일로 HTML에 반영\n\n  const $box = document.querySelector('.box');\n  console.log($box.className); // 여러 클래스면 불편하다.\n\n  $box.classList.replace('red', 'blue');\n  // DOMTokenList를 반환한다.\n  // DOMTokenList는 add, remove, item, contains, replace, toggle 등등을 가진다.\n\n  // style 프로퍼티는 인라인 스타일만 반환. 모든 CSS 스타일이 필요하면 getComoputedStyle 사용.\n  console.log(window.getComputedStyle($box)); // CSSStyleDeclaration 반환\n  console.log(window.getComputedStyle($box), ':before'); // :before의 스타일 취득\n</script>\n<body>\n  <div style=\"color: red\">Hello World</div>\n</body>\n<script>\n  const $div = document.querySelector('div');\n  console.log($div.style);\n  $div.style.backgroundColor = 'royalBlue';\n</script>\n```\n\n### 9. DOM 표준\n\n구글, 애플, 마이크로소프트, 모질라로 구성된 WHATWG가 HTML과 DOM 단일 표준을 내놓는다.\n\n## 40. 이벤트\n\n### 1. 이벤트 드리븐 프로그래밍\n\n브라우저는 처리해야 할 특정 사건이 발생하면 이를 감지하여 이벤트를 발생시킨다.\n\n> 이벤트가 발생했을 때 호출될 함수를 event handler, 이벤트가 발생했을 때 브라우저에게 이벤트 핸들러의 호출을 위임하는 것을 이벤트 핸들러 등록이라 한다.\n\n프로그램의 흐름을 이벤트 중심으로 제어하는 프로그래밍 방식을 이벤트 드리븐 프로그래밍(event-driven programming)이라 한다.\n\n### 2. 이벤트 타입\n\n책에서 보기!\n\n### 3. 이벤트 핸들러 등록\n\n```html\n<body>\n  <!--이벤트 핸들러 어트리뷰트의 이름은 on 접두사와 이벤트 타입으로 구성된다.-->\n  <button onclick=\"sayHi('YeolYi')\">Button</button>\n  <script>\n    function sayHi(name) {\n      console.log(name, name);\n    }\n    // 위에서는 함수 호출문을 할당했지만, 이벤트 핸들러 어트리뷰트와 동일한 이름의 함수를 암묵적으로 생성한다.\n    // 함수 참조를 할당한다면 인수 전달이 곤란하기 떄문이다.\n    // HTML과 자바스크립트는 관심사가 다르므로 분리하는 것이 좋다.\n    // 다만 리액트 같은 모던 자바스크립트에서는 JS를 뷰 구성을 위한 구성 요소로 보기 때문에 관심사가 다르다고 생각하지 않는다.\n\n    // 하나 이상의 이벤트를 등록할 수 없다.\n    const $button = document.querySelector('button');\n    $button.onClick = function () {\n      console.log('button click');\n    };\n\n    // 하나 이상의 이벤트를 등록할 수 있다.\n    $button.addEventListener('click', () => console.log('button click!'));\n  </script>\n</body>\n```\n\n### 4. 이벤트 핸들러 제거\n\nremoveEventHandler에 add때와 같은 인수를 전달한다. 따라서 무명 함수를 전달했으면제거할 수 없다.\n\n### 5. 이벤트 객체\n\n이벤트 객체는 이벤트 핸들러의 첫번째 인수로 전달된다.\n\n이벤트 객체는 모두 Object, Event를 상속받는다.\n\n```html\n<script>\n  // load 이벤트가 발생하면 Event 타입의 이벤트 객체가 생성된다.\n  window.onload = console.log;\n</script>\n```\n\n이벤트 객체의 프로퍼티 관련은 나중에 사전처럼 읽어보기.\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <style>\n      .box {\n        width: 100px;\n        height: 100px;\n        background-color: royalblue;\n        border: 5px solid black;\n        cursor: pointer;\n      }\n    </style>\n  </head>\n  <body>\n    <div class=\"box\"></div>\n    <script>\n      const $box = document.querySelector('div');\n      const initialMousePos = { x: 0, y: 0 };\n      const offset = { x: 0, y: 0 };\n      const move = (e) => {\n        offset.x = e.clientX - initialMousePos.x;\n        offset.y = e.clientY - initialMousePos.y;\n\n        // translate3d는 GPU를 사용하므로 absolute의 top, left를 사용하는 것보다 빠르다.\n        // top, left는 레이아웃에 영향을 준다.\n        $box.style.transform = `translate3d(${offset.x}px, ${offset.y}px, 0)`;\n      };\n\n      $box.addEventListener('mousedown', (e) => {\n        initialMousePos.x = e.clientX - offset.x;\n        initialMousePos.y = e.clientY - offset.y;\n        document.addEventListener('mousemove', move);\n      });\n\n      document.addEventListener('mouseup', () => {\n        document.removeEventListener('mousemove', move);\n      });\n    </script>\n  </body>\n</html>\n```\n\n### 6. 이벤트 전파\n\n이벤트 전파(event propagation)\n\n생성된 이벤트 객체는 이벤트를 발생시킨 DOM 요소인 이벤트 타깃(event target)을 중심으로 DOM 트리를 통해 전파된다.\n\n- 캡처링 단계: 이벤트가 상위 요소에서 하위 요소 방향으로 전파\n- 타깃 단계: 이벤트가 이벤트 타깃에 도달\n- 버블링 단계: 이벤트가 하위 요소에서 상위 요소 방향으로 전파\n\n```html\n<body>\n  <ul id=\"fruits\">\n    <li id=\"apple\">Apple</li>\n    <li id=\"banana\">Banana</li>\n    <li id=\"orange\">Orange</li>\n  </ul>\n</body>\n<script>\n  // 이벤트 핸들러 어트리뷰트/프로퍼티 방식으로 등록한 핸들러는 타깃/버블링만 캡쳐할 수 있다.\n  // addEventListener는 캡처링 단계도 캐치할 수 있다. 3번째 인수로 true 전달.\n\n  const $fruits = document.getElementById('fruits');\n  $fruits.addEventListener(\n    'click',\n    (e) => {\n      console.log(e.eventPhase); // 1\n      console.log(e.target); // 클릭한 li\n      console.log(e.currentTarget); // ul\n    },\n    true\n  );\n\n  // 이벤트를 발생시킨 이벤트 타깃과 이벤트 핸들러가 바인딩된 커런트 타깃이 같은 요소면 타깃 단계의 이벤트 객체를 캐치한다.\n  const $banana = document.getElementById('banana');\n  $banana.addEventListener('click', (e) => {\n    console.log(e.eventPhase); // 2\n    console.log(e.target); // 클릭한 li\n    console.log(e.currentTarget); // 클릭한 li\n  });\n\n  $fruits.addEventListener('click', (e) => {\n    console.log(e.eventPhase); // 3\n    console.log(e.target); // 클릭한 li\n    console.log(e.currentTarget); // ul\n  });\n</script>\n```\n\n### 7. 이벤트 위임\n\n> 이벤트 위임(event delegation)은 여러 개의 하위 DOM 요소에 각각 이벤트 핸들러를등록하는 대신 하나의상위 DOM 요소에 이벤트 핸들러를 등록하는 방법을 말한다.\n\n```html\n<body>\n  <ul id=\"fruits\">\n    <li id=\"apple\">Apple</li>\n    <li id=\"banana\">Banana</li>\n    <li id=\"orange\">Orange</li>\n  </ul>\n</body>\n<script>\n  // 이벤트 핸들러 어트리뷰트/프로퍼티 방식으로 등록한 핸들러는 타깃/버블링만 캡쳐할 수 있다.\n  // addEventListener는 캡처링 단계도 캐치할 수 있다. 3번째 인수로 true 전달.\n\n  const $fruits = document.getElementById('fruits');\n  $fruits.addEventListener(\n    'click',\n    (e) => {\n      console.log(e.eventPhase); // 1\n      console.log(e.target); // 클릭한 li\n      console.log(e.currentTarget); // ul\n    },\n    true\n  );\n\n  // 이벤트를 발생시킨 이벤트 타깃과 이벤트 핸들러가 바인딩된 커런트 타깃이 같은 요소면 타깃 단계의 이벤트 객체를 캐치한다.\n  const $banana = document.getElementById('banana');\n  $banana.addEventListener('click', (e) => {\n    console.log(e.eventPhase); // 2\n    console.log(e.target); // 클릭한 li\n    console.log(e.currentTarget); // 클릭한 li\n  });\n\n  $fruits.addEventListener('click', (e) => {\n    console.log(e.eventPhase); // 3\n    console.log(e.target); // 클릭한 li\n    console.log(e.currentTarget); // ul\n  });\n</script>\n```\n\n### 8. DOM 요소의 기본 동작 조작\n\n이벤트 객체의 preventDefault 메서드는 요소 별 기본 동작을 중단시킨다.\n\nstopPropagation 메서드는 이벤트 전파를 중지시킨다.\n\n### 9. 이벤트 핸들러 내부의 this\n\n이벤트 핸들로 프로퍼티 방식과 addEventListener 내부에서 this는 currentTarget과같다.\n\n쓰지 말자,,,\n\n### 10. 이벤트 핸들러에 인수 전달\n\npass\n\n### 11. 커스텀 이벤트\n\npass\n\n## 41. 타이머\n\n### 1. 호출 스케줄링\n\n> 함수를 명시적으로 호출하지 않고 일정 시간 이후에 함수 호출을 예약하려면 타이머함수를 사용한다. 이를 호출 스케줄링(scheduling a call)이라 한다.\n\n타이머 함수는 호스트 객체다.\n\n자바스크립트 엔진은 단 하나의 실행 컨텍스트 스택을 갖기에 싱글 스레드로 동작한다 . 이에 타이머 함수들은 비동기 처리 방식으로 동작한다.\n\n### 2. 타이머 함수\n\nsetTimeout의 delay 매개변수는 그 시간 후 즉시 호출을 보장하지 않는다. 태스크 큐에 등록하는 시간일 뿐 .\n\n```js\nconst timerID = setTimeout((x) => console.log(x * 2), 1000, 2);\nconsole.log(timerID); // 브라우저에서는 숫자, Node.js에서는 객체\nclearTimeout(timerID); // 프로그램이 즉시 종료\n```\n\n```js\nlet cnt = 0;\nconst timeoutID = setInterval(() => {\n  console.log(cnt++);\n  if (cnt == 5) {\n    clearInterval(timeoutID);\n  }\n}, 1000);\n```\n\n### 3. 디바운스와 스로틀\n\n> 디바운스와 스로틀은 짧은 시간 간격으로 연속해서 발생하는 이벤트를 그룹화해서과도한 이벤트 핸들러의호출을 방지하는 프로그래밍 기법이다.\n\n```html\n<body>\n  <button>click me</button>\n  <pre>일반 클릭 이벤트 카운더<span class=\"normal-msg\">0</span></pre>\n  <pre>디바운스 클릭 이벤트 카운더<span class=\"debounce-msg\">0</span></pre>\n  <pre>스로틀 클릭 이벤트 카운더<span class=\"throttle-msg\">0</span></pre>\n  <script>\n    const $button = document.querySelector('button');\n    const $normalMsg = document.querySelector('.normal-msg');\n    const $debounceMsg = document.querySelector('.debounce-msg');\n    const $throttleMsg = document.querySelector('.throttle-msg');\n\n    const debounce = (callback, delay) => {\n      let timerID;\n      return (event) => {\n        if (timerID) clearTimeout(timerID);\n        timerID = setTimeout(callback, delay, event);\n      };\n    };\n\n    const throttle = (callback, delay) => {\n      let timerID;\n      return (event) => {\n        if (timerID) return;\n        timerID = setTimeout(\n          () => {\n            callback(event);\n            timerID = null;\n          },\n          delay,\n          event\n        );\n      };\n    };\n\n    $button.addEventListener('click', () => {\n      $normalMsg.textContent = +$normalMsg.textContent + 1;\n    });\n\n    $button.addEventListener(\n      'click',\n      debounce(() => {\n        $debounceMsg.textContent = +$debounceMsg.textContent + 1;\n      }, 500)\n    );\n\n    $button.addEventListener(\n      'click',\n      throttle(() => {\n        $throttleMsg.textContent = +$throttleMsg.textContent + 1;\n      }, 500)\n    );\n  </script>\n</body>\n```\n\n디바운스는 resize 이벤트 처리, 입력 필드 자동완성 UI 구현, 버튼 중복 클릭 방지처리 등에 유용하게 사용된다. 위 예제는 완전하기 않으므로 Underscore나 Lodash의 debounce 함수를 사용한다.\n\n스로틀은 scroll 이벤트 처리나 무한 스크롤 UI 구현에 사용된다. 마찬가리고 실무에서는 다른걸 사용한다.\n\n## 42. 비동기 프로그래밍\n\n### 1. 동기 처리와 비동기 처리\n\n자바스크립트 엔진은 단 하나의 실행 컨텍스트 스택을 가지며 싱글 스레드 방식으로동작한다. 이에 처리에시간이 걸리는 태스크를 실행하면 블로킹(작업 중단)이 발생한다 .\n\n> 현재 실행 중인 태스크가 종료할 떄까지 다음에 실행될 태스크가 대기하는 방식을동기(synchronous) 처리라고 한다.\n\n> 실행 중인 태스크가 종료되지 않은 상태라 해도 다음 태스크를 곧바로 실행하는 방식을 비동기 (asynchronous) 처리라고 한다.\n\n비동기 처리를 수행하는 비동기 함수는 전통적으로 콜백 패턴을 사용하지만, 콜백 헬을 발생시켜 가독성을나쁘게 하고 비동기 처리 중 발생한 에러의 예외 처리가 곤란하다.\n\n### 2. 이벤트 루프와 태스크 큐\n\n> JS의 동시성(concurrency)을 지원하는 것이 이벤트 루프다.\n\n비동기 처리에서 소스코드의 평가와 실행을 제외한 처리는 환경인 브라우저나 Node.js 에서 담당한다. 브라우저에서는 이를 위해 태스크 큐와 이벤트 루프를 제공한다.\n\n- 태스크 큐: 비동기 함수의 콜백 함수 또는 이벤트 핸들러가 일시적으로 보관되는 영역.\n- 이벤트 루프: 콜 스택에 실행중인 컨텍스트가 있는지, 태스크 큐에 대기 중인 함수가 있는지 반복해서 확인. 함수가 있고 자리가 비었다면 FIFO로 태스크 큐에 대기중인 함수를 콜 스택으로 이동.\n\nsetTimeout 등에서 타이머의 설정과 타이머가 만료되면 콜백 함수를 태스크 큐에 퓨시하는 것은 브라우저의역할이다.\n\n자바스크립트 엔진은 싱글 스레드지만 브라우저는 멀티 스레드이다.\n\n## 43. Ajax\n\n### 1. Ajax란?\n\n> Ajax(Asynchronous Javascript and XML)란 자바스크립트를 사용하여 브라우저가 서버에게 비동기 방식으로 데이터를 요청하고, 서버가 응답한 데이터를 수신하여 웹페이지를 동적으로 갱신하는 프로그래밍 방식을 말한다. [참고](https://www.w3schools.com/xml/ajax_intro.asp)\n\nWebAPI인 XMLHttpRequest 객체를 기반으로 동작한다.\n\n전통적인 방식은 화면 전환마다 HTML를 다시 렌더링하는 방식이여서 깜빡이고 느렸지만, Ajax를 통해 비동기 방식으로 필요한 데이터만 전송받아 한정적인 렌더링이 가능해졌다.\n\n### 2. JSON\n\n```js\nconst obj = {\n  a: 1,\n  b: true,\n  c: 'string',\n  d: ['a', 'r', 'r'],\n};\n\nconsole.log(JSON.stringify(obj));\n/*\n{\"a\":1,\"b\":true,\"c\":\"string\",\"d\":[\"a\",\"r\",\"r\"]}\n*/\n\n// param: value, replacer, string\n// replacer 함수가 undefined를 반환하면 변환하지 않는다.\nconst json = JSON.stringify(obj, null, 2);\nconsole.log(json);\n/*\n{\n  \"a\": 1,\n  \"b\": true,\n  \"c\": \"string\",\n  \"d\": [\n    \"a\",\n    \"r\",\n    \"r\"\n  ]\n}\n*/\n\nconsole.log(JSON.parse(json));\n// { a: 1, b: true, c: 'string', d: [ 'a', 'r', 'r' ] }\n```\n\n> 객체의 문자열화를 직렬화(serializing)라 한다. JSON 포맷의 문자열을 객체화하는것을 역직렬화 (deserializing)라 한다.\n\n### 3. XMLHttpRequest\n\nHTTP 요청 메서드는 클라이언트가 서버에게 요청의 종류와 목적(리소스에 대한 행위) 을 알리는 방법이다. 5가지 요청 메서드를 사용하여 [CRUD](https://ko.wikipedia.org/wiki/CRUD)를 구현한다.\n\n```html\n<script>\n  const xhr = new XMLHttpRequest();\n  // 프로토타입 프로퍼티등\n  ({ readyState, status, statusText, responseStyle, response } = xhr);\n  console.log(readyState === XMLHttpRequest.UNSENT); // true\n\n  // 이벤트 핸들러 프로퍼티: onreadystatechange, onerror, onload\n\n  // XMLHttpRequest 객체의 메서드: open, send, abort, setRequestHeader\n\n  // 정적 프로퍼티: Done\n\n  //** open으로 요청 초기화 -> 필요에 따라 헤더 설정 -> send로 요청 **\n  xhr.open('GET', 'https://jsonplaceholder.typicode.com/todos/1');\n  // setRequestHeader 메서드\n  // Content-type은 요청 몸체에 담아 전송할 데이터의 MIME 타입의 정보를 표현한다.\n  xhr.setRequestHeader('content-type', 'application/json');\n  // send 메소드\n  // get는 query string으로 데이터 전송, post는 페이로드를 request body에 담아 전송.\n  // 페이로드를 인수로 전달할 수 있다.\n  xhr.send();\n\n  // readyState가 변경될 때마다 이벤트 발생\n  xhr.onreadystatechange = () => {\n    console.log(xhr.readyState); // 2 3 4\n    if (xhr.readyState !== XMLHttpRequest.DONE) return;\n    if (xhr.status === 200) {\n      console.log(JSON.parse(xhr.response));\n    } else {\n      console.error('Error', xhr.status, xhr.statusText);\n    }\n  };\n\n  // 요청이 성공적으로 완료된 경우만 발생\n  xhr.load = () => {\n    if (xhr.status === 200) {\n      console.log(JSON.parse(xhr.response));\n    } else {\n      console.error('Error', xhr.status, xhr.statusText);\n    }\n  };\n</script>\n```\n\n## 44. REST API\n\n> Rest는 HTTP를 기반으로 클라이언트가 서버의 리소스에 접근하는 방식을 규정한 아키텍처고, REST API는 REST를 기반으로 서비스 API를 구현한 것을 의미한다.\n\n### 1. REST API의 구성\n\n- 자원(resource, URI로 표현)\n- 행위(verb, HTTP 요청 메서드로 표현)\n- 표현(representations, 자원에 대한 행위의 구체적 내용, 페이로드로 표현)\n\n자체 표현 구조(self-descriptiveness)로 구성된다.\n\n### 2. REST API 설계 원칙\n\nURI는 리소스를 표현하는데 집중하고, 행위에 대한 정의는 HTTP 요청 메서드를 통해한다.\n\n- GET: index/retrieve. 모든/특정 리소스 취득. 페이로드 없음\n- POST: create. 리소스 생성. 페이로드 있음\n- PUT: replace. 리소스의 전체 교체. 페이로드 있음. [멱등성](https://ko.wikipedia.org/wiki/%EB%A9%B1%EB%93%B1%EB%B2%95%EC%B9%99)\n- PATCH: modify. 리소스의 일부 수정. 페이로드 있음\n- Delete: delete. 모든/특정 리소스 삭제. 페이로드 없음\n\n### 3. JSON Server를 이용한 REST API 실습\n\njson-server-exam 폴더 참고.\n\ndb.json 파일은 리소스를 제공하는 데이터베이스 역할을 한다.\n\n```html\n<body>\n  <pre></pre>\n  <script>\n    const xhr = new XMLHttpRequest();\n    // 모든 todos를 취득(index)한다.\n    xhr.open('GET', '/todos');\n    xhr.send();\n    xhr.onload = () => {\n      // 200 확인 생략\n      document.querySelector('pre').textContent = xhr.response;\n    };\n  </script>\n</body>\n```\n\n```html\n<body>\n  <pre></pre>\n  <script>\n    const xhr = new XMLHttpRequest();\n    // 특정 todo를 취득(retrieve)한다.\n    xhr.open('GET', '/todos/1');\n    xhr.send();\n    xhr.onload = () => {\n      // 200 확인 생략\n      document.querySelector('pre').textContent = xhr.response;\n    };\n  </script>\n</body>\n```\n\n```html\n<body>\n  <pre></pre>\n  <script>\n    const xhr = new XMLHttpRequest();\n    // todos 리소스에 새로운 todo를 생성\n    xhr.open('POST', '/todos');\n\n    // POST는 페이로드의 MIME 타입을 지정해야한다.\n    xhr.setRequestHeader('content-type', 'application/json');\n\n    xhr.send(JSON.stringify({ id: 4, content: 'React', completed: false }));\n\n    xhr.onload = () => {\n      // 200 확인 생략\n      document.querySelector('pre').textContent = xhr.response;\n    };\n  </script>\n</body>\n```\n\n```html\n<body>\n  <pre></pre>\n  <script>\n    const xhr = new XMLHttpRequest();\n    // id로 todo를 특정하여 id를 제외한 리소스 전체를 교체\n    xhr.open('PUT', '/todos/3');\n    xhr.setRequestHeader('content-type', 'application/json');\n    // id는 바꾸고 싶어도 안바뀌는 듯?\n    xhr.send(JSON.stringify({ id: 3, content: 'JavaScript', completed: true }));\n    xhr.onload = () => {\n      // 200 확인 생략\n      document.querySelector('pre').textContent = xhr.response;\n    };\n  </script>\n</body>\n```\n\n```html\n<body>\n  <pre></pre>\n  <script>\n    const xhr = new XMLHttpRequest();\n    // id로 todo를 특정하여 completed만 수정\n    xhr.open('PATCH', '/todos/3');\n    xhr.setRequestHeader('content-type', 'application/json');\n    xhr.send(JSON.stringify({ newParam: true }));\n    xhr.onload = () => {\n      // 200 확인 생략\n      document.querySelector('pre').textContent = xhr.response;\n    };\n  </script>\n</body>\n```\n\n```html\n<body>\n  <pre></pre>\n  <script>\n    const xhr = new XMLHttpRequest();\n    // id로 todo를 특정하여 id를 제외한 리소스 전체를 교체\n    xhr.open('DELETE', '/todos/4');\n    xhr.send();\n    xhr.onload = () => {\n      // 200 확인 생략\n      document.querySelector('pre').textContent = xhr.response;\n    };\n  </script>\n</body>\n```\n\n## 45. 프로미스\n\n### 1. 비동기 처리를 위한 콜백 패턴의 단점\n\n```html\n<script>\n  const xhr = new XMLHttpRequest();\n  xhr.open('GET', 'https://jsonplaceholder.typicode.com/posts/1');\n  xhr.send();\n  xhr.onload = () => {\n    console.log(xhr.response);\n  };\n  // 위 구문이 실행되고 console.log가 곧바로 실행된다.\n  // xhr.onload에 바인딩된 이벤트 핸들러는 결코 console.log보다 먼저 실행되지 않는다.\n  for (let i of Array(100).keys()) {\n    console.log(i);\n  }\n\n  try {\n    setTimeout(() => {\n      throw new Error('Error!');\n    }, 1000);\n  } catch (e) {\n    // 에러를 캐치하지 못한다.\n    console.log(e);\n  }\n</script>\n```\n\n비동기로 동작하는 코드에서 처리 결과를 외부로 반환하거나 상위 스코프의 변수에 할당하면 기대한 대로동작하지 않는다.\n\n```html\n<script>\n  const xhr = new XMLHttpRequest();\n  xhr.open('GET', 'https://jsonplaceholder.typicode.com/posts/1');\n  xhr.send();\n  xhr.onload = () => {\n    console.log(xhr.response);\n  };\n  // 위 구문이 실행되고 console.log가 곧바로 실행된다.\n  // xhr.onload에 바인딩된 이벤트 핸들러는 결코 console.log보다 먼저 실행되지 않는다.\n  for (let i of Array(100).keys()) {\n    console.log(i);\n  }\n\n  try {\n    setTimeout(() => {\n      throw new Error('Error!');\n    }, 1000);\n  } catch (e) {\n    // 에러를 캐치하지 못한다.\n    console.log(e);\n  }\n</script>\n```\n\n비동기 함수의 처리 결과에 대한 후속 처리는 콜백 함수를 전달하여 수행한다.\n\n> 콜백 함수 호출이 중첩되어 복잡도가 높아지는 현상을 콜백 헬이라 한다.\n\n에러는 호출자 방향으로 전파되지만 setTimeout 함수의 콜백 함수를 호출한 것은 setTimeout이 아니므로 catch 블록에서 캐치되지 않는다.\n\n### 2. 프로미스의 생성\n\n표준 빌트인 객체다.\n\n생성자는 resolve와 reject를 인수로 전달받는 콜백 함수를 인수로 받는다.\n\n프로미스의 상태 정보 [[PromiseStatus]]는 pending, fulfilled, rejected로 나뉘며뒤두개를 묶어 settled 상태라 한다. settled 상태에서는 다른 상태로 변화할 수 없다.\n\n> 프로미스는 비동기 처리 상태와 처리 결과를 관리하는 객체다.\n\n### 3. 프로미스의 후속 처리 메서드\n\n프로미스의 비동기 처리 상태가 변화하면 후속 처리 메서드에 인수로 전달한 콜백 함수가 선택적으로 호출된다. 모든 후속 처리 메서드는 프로미스를 반환하며 비동기로동작한다.\n\n```js\n// then은 언제나 promise를 반환한다.\nconst a = new Promise((resolve) => resolve('fulfilled')).then(\n  (v) => console.log(v),\n  (e) => console.error(e)\n);\nconsole.log(a); // fulfilled\n\nconst b = new Promise((_, reject) => reject(new Error('rejected')))\n  .then(\n    (v) => console.log(v),\n    (e) => console.error(e)\n  ) // Error: rejected\n  .catch((e) => console.log(e)) // reject된 상태에만 실행된다. 여기서는 실행 안됨. then(undefined, onRejected)와 같다.\n  .finally(() => console.log('bye!')); // 프로미스 상태 상관없이 한번만 실행된다.\nconsole.log(b); // 실행 안됨\n```\n\n### 4. 프로미스의 에러 처리\n\nthen 메서드의 두번째 콜백 함수는 첫번째 콜백 함수에서의 에러를 채키하지 못하니 catch 메서드를 then 다음에 사용해서 해결하자.\n\n### 5. 프로미스 체이닝\n\n```html\n<script>\n  const promiseGet = (url) => {\n    return new Promise((resolve, reject) => {\n      const xhr = new HMLHttpRequest();\n      xhr.open('GET', url);\n      xhr.send();\n      xhr.onload = () => {\n        if (xhr.status === 200) {\n          resolve(JSON.parse(xhr.response));\n        } else {\n          reject(new Error(xhr.status));\n        }\n      };\n    });\n  };\n\n  promiseGet(`${url}/posts/1`)\n    .then(({ userID }) => promiseGet(`${url}/users/${userID}`))\n    .then((userInfo) => console.log(userInfo))\n    .catch((err) => console.error(err));\n</script>\n```\n\n### 6. 프로미스의 정적 메서드\n\n- Promise.resolve/reject는 이미 존재하는 값을 래핑하여 프로미스를 생성한다.\n- Promise.all은 여러 비동기 처리를 병렬 처리할 때 사용한다. 전달받은 프로미스 배열의 요소들의 상태가모두 fulfilled가 되면 처리 결과를 배열에 저장해 새로운 프로미스를 반환한다. 배열 순서는 유지?된다. 하나라도 reject되면 즉시 종료된다.\n- Promise.race는 가장 먼저 fulfilled된 프로미스의 처리 결과를 resolve하는 새로운프로미스를 반환한다.\n- Promise.allSettled는 프로미스가 모두 settled되면 결과를 빼열로 반환한다. fulfilled는 status, value 프로퍼티를, rejected는 status, reason 프로퍼티를 갖는다.\n\n```html\n<script>\n  const promiseGet = (url) => {\n    return new Promise((resolve, reject) => {\n      const xhr = new XMLHttpRequest();\n      xhr.open('GET', url);\n      xhr.send();\n      xhr.onload = () => {\n        if (xhr.status === 200) {\n          resolve(JSON.parse(xhr.response));\n        } else {\n          reject(new Error(xhr.status));\n        }\n      };\n    });\n  };\n\n  const githubIds = ['yeolyi', 'muscleup15', 'ungmo2'];\n  Promise.all(githubIds.map((id) => promiseGet(`https://api.github.com/users/${id}`)))\n    .then((users) => users.map((user) => user.name))\n    .then(console.log)\n    .catch(console.error);\n  // ['이성열', 'panghwi', 'Ungmo Lee']\n</script>\n```\n\n### 7. 마이크로태스크 큐\n\n```js\nsetTimeout(() => console.log(1), 0);\nPromise.resolve()\n  .then(() => console.log(2))\n  .then(() => console.log(3));\n\n// 2 3 1\n```\n\n프로미스의 후속 처리 메서드의 콜백 함수는 마이크로태스크 큐에 저장된다. 마이크로태스크 큐는 태스크큐보다 우선순위가 높다.\n\n### 8. fetch\n\nfetch 함수는 XMLHttpRequest 객체보다 사용법이 간단하고 프로미스를 지원하기 때문에 비동기 처리를 위한콜백 패턴의 단점에서 자유롭다.\n\nResponse 객체를 래핑한 프로미스를 반환한다.\n\n```js\n// GET\nfetch('https://jsonplaceholder.typicode.com/todos/1')\n  .then((x) => x.json()) // HTTP 응답 몸체를 취득하여 역직렬화\n  .then(console.log);\n\n// POST\nconst payload = {\n  userId: 1,\n  title: 'JavaScript',\n  completed: false,\n};\nfetch('https://jsonplaceholder.typicode.com/todos', {\n  method: 'POST',\n  headers: { 'content-Type': 'application/json' },\n  body: JSON.stringify(payload),\n})\n  .then((response) => response.json())\n  .then(console.log)\n  .catch(console.error);\n\n// PATCH\nconst payload2 = { completed: true };\nfetch('https://jsonplaceholder.typicode.com/todos/1', {\n  method: 'PATCH',\n  headers: { 'content-Type': 'application/json' },\n  body: JSON.stringify(payload),\n})\n  .then((response) => response.json())\n  .then(console.log)\n  .catch(console.error);\n\n// DELETE\nfetch('https://jsonplaceholder.typicode.com/todos/1', {\n  method: 'DELETE',\n})\n  .then((response) => response.json())\n  .then(console.log)\n  .catch(console.error);\n```\n\n## 46. 제너레이터와 async/await\n\n### 1. 제너레이처란?\n\n> ES6에서 도입된 제너레이터는 코드 블록의실행을 일시 중지했다가 필요한 시점에 재개할 수 있는 특수한함수다.\n\n- 함수의 제어권을 함수 호출자에게 양도(yield)할 수 있다.\n- 함수 호출자와 양방향으로 함수의 상태를 주고받을 수 있다.\n- 이터러블이면서 동시에 이터레이터인 제너레이터 객체를 반환한다.\n\n### 2. 제너레이터 함수의 정의\n\nfunction 키워드와 함수 이름 사이에 \\*를 넣는다.\n\n### 3. 제너레이터 객체\n\n```js\nfunction* getFunc() {\n  try {\n    yield 1;\n    yield 2;\n    yield 3;\n  } catch (e) {\n    console.error(e);\n  }\n}\n\nconst g = getFunc();\nconsole.log(g.next()); // { value: 1, done: false }\nconsole.log(g.return('End!')); // { value: 'End!', done: true }\nconsole.log(g.next()); // { value: undefined, done: true }\nconsole.log(g.throw('Error!')); // 책이랑 다르게 프린트 없이 터짐 왜?\n```\n\n### 4. 제너레이터의 일시 중지와 재게\n\n제너레이터 객체의 next 메서드를 호출하면 yield 표현식까지 실행되고 일시 중지된다 .\n\n제너레이터 함수가 끝까지 실행되면 반환된 객체의 value 프로퍼티에 함수의 반환값이할당된다.\n\n```js\nfunction* genFunc() {\n  const x = yield 1; // x 값은 두번째 next 호출 때 결정된다.\n  const y = yield x + 10;\n  // 일반적으로 제너레이터의 반환값은 의미가 없다.\n  return x + y;\n}\nconst g = genFunc(0);\n// 첫 next는 인수를 전달해도 무시된다.\nconsole.log(g.next()); // 1\nconsole.log(g.next(10)); // 20\nconsole.log(g.next(20)); // 30\n```\n\n### 5. 제너레이터의 활용\n\n이터레이션 프로토콜을 준수해 이터러블을 생성하는 방식보다 간단히 이터러블을 구현할 수 있다.\n\n비동기 처리를 동기 처리처럼 구현할 수 있지만 aync/await를 사용하자.\n\n```js\nconst async = (generatorFunc) => {\n  const generator = generatorFunc();\n  const onResolved = (arg) => {\n    const result = generator.next(arg);\n    return result.done ? result.value : result.value.then((res) => onResolved(res)); // 재귀 호출\n  };\n  return onResolved;\n};\n\nasync(function* fetchTodo() {\n  const url = 'https://jsonplaceholder.typicode.com/todos/1';\n  const response = yield fetch(url);\n  const todo = yield response.json();\n  console.log(todo);\n})();\n```\n\n코드에 대해서는 책 설명 다시 읽어보기.\n\n### 6. async/await\n\n> ES8에서는 제너레이터보다 간단하고 가독성 좋게 비동기 처리를 동기 처리처럼 동작하도록 구현할 수 있는 async/await가 도입되었다.\n\n```js\n// await는 반드시 async 함수 내부에서 사용해야한다.\n// async 함수는 반드시 프로미스를 반환한다. 반환값이 없으면 암시적으로라도 반환한다.\n// await 키워드는 반드시 프로미스 앞에서 사용해야 한다.\n\nconst getGithubUserName = async (id) => {\n  const res = await fetch(`https://api.github.com/users/${id}`);\n  const { name } = await res.json();\n  console.log(name);\n};\n\ngetGithubUserName('yeolyi');\n\nconst foo = async () => {\n  try {\n    const wrongUrl = 'https://wrong.url';\n    const response = await fetch(wrongUrl);\n    const data = await response.json();\n    console.log(data);\n  } catch (e) {\n    console.error(e); // TypeError: Fetch failed.\n  }\n};\n\nfoo();\n\n// async 함수 내에서 catch 문을 사용해 에러 처리를 하지 않으면 async 함수는 발생한 에러를 reject하는 프로미스를 반환한다.\n```\n\n## 47. 에러 처리\n\n### 1. 에러 처리의 필요성\n\n발생한 에러에 대해 대처하지 않고 방치하면 프로그램은 강제 종료된다.\n\n### 2. try...catch...finally 문\n\nfinally 코드 블록은 에러 발생과 상관없이 반드시 한 번 실행된다.\n\n### 3. Error 객체\n\nError 생성자 함수에 에러 메시지를 전달할 수 있고, 생성된 객체는 message와 stack 프로퍼티를 가진다.\n\nSyntaxError, ReferenceError, TypeError, RangeError, URIError, EvalError 가 있다.\n\n### 4. throw 문\n\n에러를 발생시키려면 try 코드 블록에서 throw 문으로 에러 객체를 던져야 한다.\n\n### 5. 에러의 전파\n\nthrow된 에러를 캐치하지 않으면 호출자 방향으로 전파된다. 비동기 함수인 setTimeout이나 프로미스 후속처리 메서드의 콜백 함수는 호출자가 없음을 주의한다.\n\n## 48. 모듈\n\n### 1. 모듈의 일반적 의미\n\n> 모듈이란 애플리케이션을 구성하는 개별적 요소로서 재사용 가능한 코드 조각을 말한다.\n\n모듈은 공개가 필요한 자산에 한정하여 export를 통해 선택적 공개가 가능하다. 모듈사용자는 공개된 자산중 일부 또는 전체를 import를 통해 자신의 스코프 내로 불러들여 재사용할 수 있다.\n\n### 2. 자바스크립트와 모듈\n\n자바스크립트는 본래 하나의 전역을 공유해 모듈 구현이 없었으나, CommonJS와 AMD(Asynchronous Module Definition)가 제안되었다.\n\n브라우저 환경에서 모듈을 사용하기 위해서는 이들을 구현한 모듈 로더 라이브러리를사용해야했다.\n\nNode.js는 사실상 표준(de factor standard)인 CommonJS를 채택했고 독자적인 진화를거쳤다.\n\n### 3. ES6 모듈\n\nES6에서 클라이언트 사이드 JS에서도 동작하는 모듈 기능을 추가했다. ES6 Module, ESM.\n\nscript 태그에 type=\"module\"을 추가하면 로드된 JS 파일은 모듈로서 동작한다. ESM의확장자는 mjs로 명시하는 것이 좋다.\n\nES6는 독자적인 모듈 스코프를 갖는다. export 키워드와 import 키워드를 사용할 수있다.\n\nrequire는 NodeJS에서 사용되고 있는 CommonJS 키워드이고, import는 ES6에서 도입된키워드이다.\n\n## 49. Babel과 Webpack을 이용한 ES6+/ES.NEXT 개발 환경 구축\n\n### 1. Babel\n\n> Babel은 ES6+/ES.NEXT로 구현된 최신 사양의 소수코드를 구형 브라우저에서도 동작하는 소스코드로 변환( 트랜스파일링)할 수 있다.\n\n> @babel/preset-env는 함께 사용되어야 하는 Babel 플러그인을 모아 둔 것으로 Babel 프리셋이라고 부른다 .\n\n### 2. Webpack\n\n> Webpack은 의존 관계에 있는 JS, CSS, 이미지 등의 리소스들을 하나(또는 여러 개) 의 파일로 번들링하는모듈 번들러다.\n","path":"language/javascript/index.md"}