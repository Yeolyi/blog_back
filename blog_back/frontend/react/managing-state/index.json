{"pathArr":[],"metaData":{"title":"Managing State"},"content":"\nWith React, you won’t modify the UI from code directly. For example, you won’t write commands like “disable the button”, “enable the button”, “show the success message”, etc. Instead, you will describe the UI you want to see for the different visual states of your component (“initial state”, “typing state”, “success state”), and then trigger the state changes in response to user input.\n\n### Reacting to Input with State\n\nReact uses a declarative way to manipulate the UI. Instead of manipulating individual pieces of the UI directly, you describe the different states that your component can be in, and switch between them in response to the user input. This is similar to how designers think about the UI.\n\n> Declarative programming means describing the UI for each visual state rather than micromanaging the UI (imperative).\n\n1. Identify your component’s different visual states\n2. Determine what triggers those state changes(state diagram?)\n3. Represent the state in memory using useState\n4. Remove any non-essential state variables\n5. Connect the event handlers to set the state\n\n### Choosing the State Structure\n\n- Group related state.\n- Avoid contradictions in state.\n- Avoid redundant state.\n- Avoid duplication in state.\n- Avoid deeply nested state.\n\n```jsx\nconst isSending = status === 'sending';\n// 한 렌더링 안에서는 state가 바뀌지 않으니 이렇게 써도 상관 없는 듯?\n```\n\n**Don't mirror props in state**. “Mirroring” props into state only makes sense when you want to ignore all updates for a specific prop. By convention, start the prop name with initial or default to clarify that its new values are ignored.\n\n### Sharing State Between Components\n\nSometimes, you want the state of two components to always change together. To do it, remove state from both of them, move it to their closest common parent, and then pass it down to them via props. This is known as lifting state up, and it’s one of the most common things you will do writing React code.\n\n> It is common to call a component with some local state “uncontrolled”.\n\n> In contrast, you might say a component is “controlled” when the important information in it is driven by props rather than its own local state.\n\nWhen writing a component, consider which information in it should be controlled (via props), and which information should be uncontrolled (via state)\n\n[Single source of truth](https://en.wikipedia.org/wiki/Single_source_of_truth)\n\n### Preserving and Resetting State\n\nReact associates each piece of state it’s holding with the correct component by where that component sits in the UI tree.\n\nState is not kept in JSX tags. It’s associated with the tree position in which you put that JSX.\n\nReact preserves a component’s state for as long as it’s being rendered at its position in the UI tree.\n\nWhen you render a different component in the same position, it resets the state of its entire subtree.\n\nNested Component는 렌더때마다 새로운 component function이 생성되므로 state가 렌더마다 초기화되는 문제가 있다.\n\nThere are two ways to reset state when switching between them:\n\n- Render components in different positions\n- Give each component an explicit identity with key\n\nRemember that keys are not globally unique. They only specify the position within the parent.\n\n컴포넌트가 제거돼도 그 내용을 보관하는 방법\n\n- 앱이 간단하다면 모두 렌더하고 CSS를 통해 숨길건 숨기기\n- state를 상위로 옮기기. 가장 일반적인 방법.\n- localStorage에 저장된 값을 토대로 렌더링하기.\n\n### Extracting State Login into a Reducer\n\nTo reduce this complexity and keep all your logic in one easy-to-access place, you can move that state logic into a single function outside your component, called a “reducer.”\n\nInstead of telling React “what to do” by setting state, you specify “what the user just did” by dispatching “actions” from your event handlers.\n\n```jsx\nfunction handleDeleteTask(taskId) {\n  dispatch(\n    // \"action\" object:\n    {\n      type: 'deleted',\n      id: taskId,\n    }\n  );\n}\n```\n\n보통 발생한 일을 묘사하는 type 문자열을 포함한다.\n\n```jsx\nfunction tasksReducer(tasks, action) {\n  switch (action.type) {\n    case 'added': {\n      return [\n        ...tasks,\n        {\n          id: action.id,\n          text: action.text,\n          done: false,\n        },\n      ];\n    }\n    case 'changed': {\n      return tasks.map((t) => {\n        if (t.id === action.task.id) {\n          return action.task;\n        } else {\n          return t;\n        }\n      });\n    }\n    case 'deleted': {\n      return tasks.filter((t) => t.id !== action.id);\n    }\n    default: {\n      throw Error('Unknown action: ' + action.type);\n    }\n  }\n}\n```\n\nreduce와 유사한 형식으로 구성되어있다. reduce 함수에 전달되는 함수를 reducer라고한다. We recommend to wrap each case block into the { and } curly braces so that variables declared inside of different cases don’t clash with each other.\n\n```jsx\nconst [tasks, dispatch] = useReducer(tasksReducer, initialTasks);\n```\n\nA reducer is a pure function that doesn’t depend on your component.\n\nReducers must be pure, Each actino describes a single user interaction, even if that leads to multiple changes in the data.\n\nState updater function처럼 reducer도 렌더링 중 동작한다??. They should not send requests, schedule timeouts, or perform any side effects.\n\n### Passing Data Deeply with Context\n\n> Context lets the parent component make some information available to any component in the tree below it—no matter how deep—without passing it explicitly through props.\n\n> Lifting state up that high can lead to a situation sometimes called **“prop drilling.”**\n\nIf you don’t provide the context, React will use the default value you’ve specified in the previous step.\n\nThe component will use the value of the nearest <LevelContext.Provider> in the UI tree above it.\n\nContext lets you write components that “adapt to their surroundings” and display themselves differently depending on where (or, in other words, in which context) they are being rendered.\n\nJust because you need to pass some props several levels deep doesn’t mean you should put that information into context.\n\nStart by passing props, extract components and pass JSX as children them.\n\nTheming, Current account, Routing, Managing state...\n\n### Scaling Up with Reducer and Context\n\nCustom Hooks. Your function is considered a custom Hook if its name starts with use. This lets you use other Hooks, like useContext, inside it.\n\nCreate two contexts (for state and for dispatch functions). - 값에 접근만 해도되는 경우가 있으니까분리하는건가?\n\n- 객체로 만들어서 하나에 넣으면 번거로운 것도 있을 듯.\n","path":"frontend/react/managing-state/index.md"}