{"pathArr":[],"metaData":{"title":"Web Development with Node and Express"},"content":"\n다음에서 발췌 Web Development with Node and Express, 2nd Edition Ethan Brown\n\n[GitHub](https://github.com/EthanRBrown/web-development-with-node-and-express-2e)\n\n## 1. Introducing Express\n\nAll-javascript 기술 스택을 통해 context switching을 그만둘 수 있다. Mental gear의 조절이 불필요.\n\n> Express 웹사이트의 설명 minimal and flexible Node.js web application framework that provides a robust set of features for web and mobile applications.\n\nServer-side application에서는 어플리케이션의 페이지가 서버에서 렌더링된다.\n\nClient-side application에서는 대부분의 UI를 한번만 보내지는 초기 어플리케이션 번들을 통해 그려진다. 브라우저가 HTML을 받으면 JS를 사용해 DOM을 동적으로 변환시킨다. 새로운 페이지를 보이기 위해 서버에 의존할 필요가 없다.\n\n1999년 전에는 SSA가 표준이었다. 이후 2012년에 스마트폰이 보급되면서 네트워크로 적은 정보를 보내야했고 CSA가 성행했다.\n\nSSA는 종종 SSR(server-side rendered), CSA는 SPAs(single-page applitaions)로 불린다.\n\n경계가 명확한 것은 아닌데, client-side application이 2-3개의 HTML 파일을 보낼 수 있고 SSR과 합쳐져 first-page-load 성능과 SEO를 개선할 수 있기 때문이다.\n\n### Node: A New Kind of Web Server\n\nIIS나 아파치와는 다르게 노드는 셋업과 설정이 쉽다. Configuration option이 간단하고 직관적이다.\n\n노드가 사용하는 JS 엔진(V8)은 JS를 네이티브 코드로 컴파일하지만 유저에게 transparent하게 진행해서 마치 인터프리터 언어처럼 작동하게 한다. JIT.\n\n노드는 싱글 쓰레드이다. **여기 관련은 나중에 또 읽어보기.** Isn't multithreading through server parallelism(as opposed to app parallelism) simply moving the complexity around, not eliminating it?\n\n플랫폼에 무관하다.\n\n### The Node Ecosystem\n\nJavascript stack -> Node / Express / Database server / Rendering engine...\n\n이 책에서는 Node, Express, MongoDB\n\n## 2. Getting Started with Node\n\nbash, zsh. The main reason I gravitate toward bash is ubiquity.\n\n[The Bash Guide](https://guide.bash.academy/)\n\nnodemon은 소스코드에 변화가 있을 때 자동으로 노드 프로그램을 재시작해주는 유틸리티이다.\n\nPHP/ASP 등의 기존 방식은 URL과 파일 이름 사이 관계가 명확하다. 웹 서버는 파일이 컴퓨터 어디에 위치한지 알고 그것을 브라우저에게 제공한다.\n\n노드는 기존 패러다임과는 달리 작성한느 앱이 즉 웹 서버이다. 노드는 웹 서버를 위한 프레임워크를 제공할 뿐이다.\n\n[About node.js](https://nodejs.org/en/about/)\n\n```js\nconst http = require('http');\nconst port = process.env.PORT || 3000;\n\nconst server = http.createServer((req, res) => {\n  // text/html도 가능하지만 저자는 JS 내에서 HTML를 포함시키는 것을 피하려 한다.\n  // 자세한 것은 챕터7\n  res.writeHead(200, { 'Content-Type': 'text/plain' });\n  res.end('Hello world!');\n});\n\nserver.listen(port, () => {\n  console.log(`server started on port ${port}`);\n});\n```\n\nNode의 핵심 철학은 이벤트 기반 프로그래밍이다. 개발자는 어떤 이벤트가 가능하고 그것들에 어떻게 반응할지를 이해해야한다. 위 코드에서는 HTTP request 이벤트가 처리된다.\n\n유저가 앱의 한 페이지에서 다른 페이지로 이동할 때 발생하는 navigation event에 반응하는 것을 routing이라 한다.\n\n> Routing refers to the mechanism for serving the client the content it has asked for.\n\n작은 프로젝트에서는 노드로 static resource를 제공하는 것도 좋지만 큰 프로젝트에서는 NGINX나 CDN같은 프록시 서버를 원할 수도 있다. 챕터 17.\n\n```js\nconst http = require('http');\nconst port = process.env.PORT || 3000;\n\nconst server = http.createServer((req, res) => {\n  // regex 해석,,,\n  // Clustering without capturing\n  // https://stackoverflow.com/questions/3512471/what-is-a-non-capturing-group-in-regular-expressions\n  const path = req.url.replace(/\\/?(?:\\?.*)?$/, '').toLowerCase();\n  switch (path) {\n    case '':\n      res.writeHead(200, { 'Content-Type': 'text/plain' });\n      res.end('Homepage');\n      break;\n    case '/about':\n      res.writeHead(200, { 'Content-Type': 'text/plain' });\n      res.end('About');\n      break;\n    default:\n      res.writeHead(404, { 'Content-Type': 'text/plain' });\n      res.end('Not Found');\n      break;\n  }\n});\n\nserver.listen(port, () => {\n  console.log(`server started on port ${port}`);\n});\n```\n\n```js\nconst http = require('http');\nconst fs = require('fs');\nconst port = process.env.PORT || 3000;\n\nconst serveStaticFile = (res, path, contentType, responseCode = 200) => {\n  fs.readFile(__dirname + path, (err, data) => {\n    if (err) {\n      res.writeHead(500, { 'Content-Type': 'text/plain' });\n      return res.end('500 - Internal Error');\n    }\n    res.writeHead(responseCode, { 'Content-Type': contentType });\n    res.end(data);\n  });\n};\n\nconst server = http.createServer((req, res) => {\n  const path = req.url.replace(/\\/?(?:\\?.*)?$/, '').toLowerCase();\n  switch (path) {\n    case '':\n      serveStaticFile(res, '/public/home.html', 'text/html');\n      break;\n    case '/about':\n      serveStaticFile(res, '/public/about.html', 'text/html');\n      break;\n    case '/img/logo.png':\n      serveStaticFile(res, '/public/img/logo.png', 'image/png');\n      break;\n    default:\n      serveStaticFile(res, '/public/404.html', 'text/html');\n      break;\n  }\n});\n\nserver.listen(port, () => console.log(`server started on port ${port}`));\n```\n\n## 3. Saving Time with Express\n\n> Express has taken a page from Ruby on Rails and provided a utility to generate **scaffolding** to start your Express project.\n\n[express-generator](http://bit.ly/2CyvvLr)\n\n프로젝트 루트 경로를 프로젝트 경로의 하위 디렉터리로 만드는 것을 추천한다. 미팅 노트, 문서,,, 등등을 놓을 곳이 필요하니까.\n\n일반적으로 primary file은 app.js로 명명한다. 다른 것 쓰려면 package.json의 main 프로퍼티 바꾸는 것 잊지 말기.\n\n[redirect-path chrome extension](https://chrome.google.com/webstore/detail/redirect-path/aomidfkchockcldhbkggjokdkkebmdll)\n\n```js\n// Handlebar 적용 이전\n\n//  책에서는 app file로 지칭\nconst express = require('express');\nconst app = express();\n\nconst port = process.env.PORT || 3000;\n\n// 404 handler 이전에 추가해야함\n// app.get is the method by which we're adding routes.\n// trailing 슬래시나 쿼리스트링을 신경쓰지 않아도 된다.\napp.get('/', (req, res) => {\n  res.type('text/plain');\n  res.send('Meadowlark Travel');\n});\n\napp.get('/about', (req, res) => {\n  res.type('text/plain');\n  res.send('About Meadowlark Travel');\n});\n\n// app.use로 미들웨어를 추가한다.\n// catchall handler for anything that didn't get matched by a route.\n// 따라서 순서가 중요하다.\napp.use((req, res) => {\n  // 실수로 type/plain으로 했는데 파일이 다운로드됨\n  res.type('text/plain');\n  res.status(404);\n  res.send('404 - Not Found');\n});\n\n// 여기만 인자가 4개로 err로 시작하네?\napp.use((err, req, res, next) => {\n  console.error(err.message);\n  res.type('text/plain');\n  res.status(500);\n  res.send('500 - Server Error');\n});\n\napp.listen(port, () => console.log(`Express started on http://localhost:${port}`));\n```\n\nMVC 패러다임에서 view는 유저에게 전달되는 것이다. 여기서는 HTML. Pug와 같은 view engine은 HTML보다 간략한 syntax를 HTML로 변환한다. Handlebars는 pug보다 덜 추상화했다.\n\n> ‘In the years following the original release of this book, React has taken the world by storm…which abstracts HTML away from frontend developers! Viewed through that lens, my prediction that frontend developers didn’t want HTML abstracted away hasn’t stood the test of time. However, JSX (the JavaScript language extension that most React developers use) is (almost) identical to writing HTML, so I wasn’t entirely wrong.\n\n```js\nconst express = require('express');\nconst expressHandlebars = require('express-handlebars');\nconst app = express();\n\nconst fortunes = [\n  'Conquer your fears or they will conquer you.',\n  'Rivers need springs.',\n  \"Do not fear what you don't know.\",\n  'You will have a pleasant surprise.',\n  'Whenever possible, keep it simple',\n];\n\n// static 미들웨어는 각 정적 파일에 대한 라우트를 만드는 것과 같은 효과를 가진다.\napp.use(express.static(__dirname + '/public'));\n\napp.engine(\n  'handlebars',\n  // 책에는 engine 안씀. 달라진 듯?\n  expressHandlebars.engine({\n    defaultLayout: 'main',\n  })\n);\napp.set('view engine', 'handlebars');\n\nconst port = process.env.PORT || 3000;\n\napp.get('/', (req, res) => {\n  res.render('home');\n});\n\napp.get('/about', (req, res) => {\n  const randomFortune = fortunes[Math.floor(Math.random() * fortunes.length)];\n  res.render('about', { fortune: randomFortune });\n});\n\napp.use((req, res) => {\n  res.status(404);\n  res.render('404');\n});\n\napp.use((err, req, res, next) => {\n  console.error(err.message);\n  res.status(500);\n  res.render('500');\n});\n\napp.listen(port, () => console.log(`Express started on http://localhost:${port}`));\n```\n\n```handlebars\n<h1>About Meadowlark Travel</h1>\n{{#if fortune}}\n  <p>Your fortune for the day:</p>\n  <blockquote>{{fortune}}</blockquote>\n{{/if}}\n```\n\n방문마다 같은 html을 받기는 하지만 route가 불릴 때마다 다른 결정을 할 수 있고 그래서 dynamic content로 간주된다.\n\nExpress는 정적 파일과 뷰를 다루기 위해 미들웨어를 사용한다.\n\nstatic 미들웨어는 별다른 처리 없이 유저에게 곧장 전달하면 되는 정적 자원이 있는 디렉터리를 지정할 때 사용된다. 이미지, CSS, client-side JS 파일,,,\n\npublic 폴더 -> 폴더 내용물이 묻지도 따지지도 않고 클라이언트에 전달되기 때문에 붙은 이름.\n\n## 4. Tidying Up\n\n보통 소스코드를 src와 같은 디렉터리 아래 몰아넣는 것이 깔끔하다.\n\n> I had a fencing coach who would always remind us that practice doesn’t make perfect; practice makes permanent. That is, if you do something over and over again, eventually it will become automatic, rote. That is true, but it says nothing about the quality of the thing you are practicing.\n\n[Version Control with Git](https://www.oreilly.com/library/view/version-control-with/9780596158187/)\n\nGit은 staging area가 있어 git add를 하면 변경점들이 이곳으로 이동한다.\n\npackage.json의 두 목적은 프로젝트를 설명하고 의존성들을 나열하는 것이다.\n\nnpm의 버전 번호는 semver(semantic versioning)에 의해 파싱된다.\n\n**Node modules**는 모듈화와 캡슐화의 매커니즘을 제공하고, **npm package**는 프로젝트의 저장, 버전 매기기, 참조를 위핸 표준화된 스킴을 제공한다.\n\n```js\n// ./이 없으면 node_modules를 찾아버리게 된다.\nconst fortune = require('./lib/fortune)\n```\n\nNode modules는 CommonJS(CJS) 모듈로도 불린다. JS가 도입하고 있는 공식적인 패키징 매커니즘은 ECMAScript Module(ECM)이라 불린다. 리액트와 같은 progressive한 프론트 언어에서는 ESM이 익숙할 것이다.\n\n## 5. Quality Assurance\n\n> QA is a very different discipline than development, and it attracts dirrefent personalities and talents.\n\nQA 계획의 목표는 제품이 의도된대로 동작하는지를 확신하기 위해 밟아야 할 단계들을 기록하는 것이다. 아래 것들에 따라 업데이트된다.\n\n- 새로운 기능\n- 기존 기능의 변화\n- 사라진 기능\n- 테스트 기술이나 테크닉의 변화\n- QA 계획에서 놓친 결함\n\n웹 개발에서 퀄리티란 네 차원으로 나뉠 수 있다.\n\n- Reach: market penetration of your product. SEO\n- Functionality: Site that works as advertised\n- Usability: human-computer interaction(HCI)\n- Aesthetics\n\nFunctionality와 SEO는 자동화 가능하니 이들을 집중적으로 다뤄보자.\n\n웹사이트에는 logic / presentation 두가지 영역이 있다. Logic 영역에 있는 것들은 명확하고 간단해야한다. Presentation 영역의 것들은 usability와 aesthetic의 잣대에 놓인다. 최대한 이 둘의 경계를 명확하게 하려고 해야한다.\n\n> Unit testing is very fine-grained, testing single components to make sure they function properly, whereas integration testing tests the interactino between multiple components or even the whole system.\n\n유닛 테스트는 로직 테스팅, integration 테스트는 두 영역 모두에 유용하다.\n\n### Unit Testing\n\nExpress를 mock할 필요가 있다.\n\n테스트 파일을 만드는 방법에는 \\_\\_tests\\_\\_ 서브디렉터리에 넣거나 .test.js 접미사를 붙이는 것이 있는데 둘 다 사용해보자.\n\n```js\nconst fortune = require('./fortune');\n\nexports.home = (req, res) => res.render('homeWithLink');\nexports.about = (req, res) => res.render('about', { fortune: fortune.getFortune() });\nexports.notFound = (req, res) => res.render('404');\nexports.serverError = (err, req, res, next) => res.render('500');\n```\n\n```js\nconst express = require('express');\nconst expressHandlebars = require('express-handlebars');\nconst handlers = require('./lib/handlers');\n\nconst app = express();\nconst port = process.env.PORT || 3000;\n\napp.use(express.static(__dirname + '/public'));\napp.engine(\n  'handlebars',\n  expressHandlebars.engine({\n    defaultLayout: 'main',\n  })\n);\napp.set('view engine', 'handlebars');\n\n// 이제 이 handler들을 잘 쓰는지만 테스트하면 된다.\napp.get('/', handlers.home);\napp.get('/about', handlers.about);\napp.use(handlers.notFound);\napp.use(handlers.serverError);\n\napp.listen(port, () => console.log(`Express started on http://localhost:${port}`));\n```\n\n(책에서는 파일명을 \\_\\_test\\_\\_라고 했으나 prettier가 언더스코어를 별로 바꿔서 test로 폴더 만듦)\n\n```js\nconst handlers = require('../lib/handlers');\n\ntest('home page renders', () => {\n  const req = {};\n  const res = { render: jest.fn() };\n  handlers.home(req, res);\n  // 0번째 요소는 호출을 담고 있고 1번째 요소는 인자를 담고 있다.\n  expect(res.render.mock.calls[0][0]).toBe('homeWithLink');\n});\n\ntest('about page renders with fortune', () => {\n  const req = {};\n  const res = { render: jest.fn() };\n  handlers.about(req, res);\n  expect(res.render.mock.calls.length).toBe(1);\n  expect(res.render.mock.calls[0][0]).toBe('about');\n  expect(res.render.mock.calls[0][1]).toEqual(\n    expect.objectContaining({\n      fortune: expect.stringMatching(/\\W/),\n    })\n  );\n});\n\ntest('404 handler renders', () => {\n  const req = {};\n  const res = { render: jest.fn() };\n  handlers.notFound(req, res);\n  expect(res.render.mock.calls.length).toBe(1);\n  expect(res.render.mock.calls[0][0]).toBe('404');\n});\n\ntest('500 handler renders', () => {\n  const err = new Error('some error');\n  const req = {};\n  const res = { render: jest.fn() };\n  const next = jest.fn();\n  handlers.serverError(err, req, res, next);\n  expect(res.render.mock.calls.length).toBe(1);\n  expect(res.render.mock.calls[0][0]).toBe('500');\n});\n```\n\njest.fn()으로 generic mock function을 만들어 어떻게 호출되는지 추적할 수 있다.\n\nwatch 모드를 통해 코드에 변화가 있을 때 자동으로 테스트를 돌릴 수 있다.\n\n```\n// -- 은 npm이 jest에게 --watch 인자를 넘기게 하기위해 필요하다.\ntest -- --watch\n```\n\n테스트를 어떻게 얼마나 진행할지에 대해서는 정답이 없지만, code coverage는 중요하다할 수 있다.\n\n> Code coverage offers a quantitative answer to how much of your code is tested.\n\n```\nnpm test -- --coverage\n```\n\n- Stmt: JS 문. 한 줄에 여러 문이 있을 수 있어서 Lines의 결과와는 다를 수 있다.\n- Branch: if-else와 같은 제어 흐름에서 얼마나 실행됐는지\n\nEntropic functionality(랜덤)를 테스트하는 것은 어렵다.\n\n### Integration Testing\n\nHome에서 About 페이지로 이동할 수 있는 기능을 추가해보자. 두개의 Express route henalder를 사용하며 HTML과 DOM 상호작용(링크 클릭+페이지네비게이션)을 포함하니 integration test라 할 수 있겠다.\n\n```handlebars\n<h2>HOME</h2>\n<!-- 저자는 class는 스타일을 위해 남겨두고 자동화를 위해 data attibute(data-test-id)를 사용하는 것을 선호한다. -->\n<a href=\"/about\" data-test-id=\"about\">About Us</a>\n```\n\n[Node's module documentation](https://nodejs.org/docs/latest-v14.x/api/modules.html)\n\n[Difference between module.exports and exports in Node.js](https://www.geeksforgeeks.org/difference-between-module-exports-and-exports-in-node-js/)\n\n> Puppeteer is essentially a controllable, headless version of Chrome. (Headless simply means that the browser is capable of running wothout actually rendering a UI on-screen.)\n\n```js\nconst portfinder = require('portfinder');\nconst puppeteer = require('puppeteer');\n\nconst app = require('../meadowlark3.js');\n\nlet server = null;\nlet port = null;\n\nbeforeEach(async () => {\n  port = await portfinder.getPortPromise();\n  server = app.listen(port);\n});\n\nafterEach(() => {\n  server.close();\n});\n\ntest('home page links to about page', async () => {\n  const browser = await puppeteer.launch();\n  const page = await browser.newPage();\n  await page.goto(`http://localhost:${port}`);\n  // Prevent race condition?\n  await Promise.all([page.waitForNavigation(), page.click('[data-test-id=\"about\"]')]);\n  expect(page.url()).toBe(`http://localhost:${port}/about`);\n  await browser.close();\n});\n```\n\n### Linting\n\nESLint에서 한 프로젝트 내의 다른 부분에서 다른 규칙을 사용할 수도 있다.\n\nESLint는 미확인된 global 변수를 싫어한다. Jest의 경우 .eslintrc.js의 env에 \"jest\": true를 추가함으로써 해결할 수 있다.\n\n```js\n// 아래 코드는 eslint에 의해 next를 사용하지 않는다는 경고가 표시된다.\n// 하지만 next를 제거하면 argument 개수의 변화때문에 error handler 여부가 바뀌게 된다.\nexports.serverError = (err, req, res, next) => res.render('500');\n```\n\n### Continuous Integration\n\n레포에 기여할 때마다 테스트를 실행한다. 테스트 실패시 알림이 가게 할 수 있다.\n\n노드 프로젝트에서는 Travis CI가 많이 사용된다. 깃허브에서도 잘 지원하고 CircleCI라는 것도 있다.\n\n## 6. The Request and Response Objects\n\nExpress로 웹 서버를 만드는 과정은 request 객체로 시작해서 response 객체로 끝난다.\n\n### URL의 구성요소\n\n- 프로토콜: 요청이 어떻게 전송될 것인지\n- 호스트: 서버를 식별. 인터넷에서 호스트는 TLD(Top Level Domain)으로 끝나고 www와 같은 subdomain이 접두어로 붙을 수도 있다.\n- 포트: 1023보다 큰 것을 사용해야 한다.\n- Path\n- 쿼리스트링: 키/값 조합들의 집합. URL 인코딩되어야한다. JS에는 encodeURIComponent가 있다.\n- Fragment: 브라우저에 의해 사용된다.\n\n### HTTP Request methods\n\nor HTTP verbs\n\n브라우저에서 페이지를 열면 GET 요청을 한다.\n\nPOST 요청은 흔히 대응되는 GET 요청과 같은 HTML를 반환한다.\n\n### Request Headers\n\nuser agent(브라우저, 운영체제, 하드웨어 등)에 대한 정보를 보낸다.\n\n```js\nconst express = require('express');\n\nconst app = express();\n\napp.get('/headers', (req, res) => {\n  res.type('text/plain');\n  const headers = Object.entries(req.headers).map(([key, value]) => `${key}: ${value}`);\n  res.send(headers.join('\\n'));\n});\n\napp.listen(3000);\n\n/*\nhost: localhost:3000\nupgrade-insecure-requests: 1\naccept: text/html,application/xhtml+xml,application/xml;q=0.9,*\\/*;q=0.8\nuser-agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.1 Safari/605.1.15\naccept-language: ko-KR,ko;q=0.9\naccept-encoding: gzip, deflate\nconnection: keep-alive\n*/\n```\n\n### Response Headers\n\n메타데이터와 서버 정보가 담겨있다.\n\nURL의 path는 추상적이고 브라우저는 궁극적으로 Content-Type을 참고해 렌더링한다.\n\n```js\nconst express = require('express');\nconst app = express();\n\napp.get('/', (req, res) => {\n  res.send('Hello');\n});\n// X-Powered-By: Express 가 사라진다.\n// 위치는 상관없나?\napp.disable('x-powered-by');\napp.listen(3000);\n```\n\n### Internet Media Types\n\ncontent type / internet media type / MIME(Multipurpose Internet Mail Extensions)\n\nMIME는 precursor지만 대부분 같다.\n\n### Request Body\n\nPOST는 보통 application/x-www-form-urlencoded(쿼리스트링과 유사). 파일 업로드가 필요하면 multipart/form-data.\n\n### The Request/Response Object\n\n각각 노드의 http.IncomingMessage, http.ServerResponse에 기능을 붙인 것.\n\n훑어보고 지나감.\n\n## Boiling It Down\n\n렌더링 관련 여러 사용례들. These examples are intended to be a quick reference you can revisit in the future.\n\nchaining을 사용할 수 있는지 고려해보기.\n\n레이아웃은 views/ 커스텀 한 것들은 views/layouts인듯?\n\n```js\n// 위에서도 언급되었지만 next를 안쓰더라도 있어야 error handler임이 인식된다.\napp.use((err, req, res, next) => {\n  console.error('** SERVER ERROR: ' + err.message);\n  res.status(500).render('08-error', { message: \"you shouldn't have clicked that!\" });\n});\n```\n\n> The term **endpoint** is often used to describe a single function in an API.\n\n## 7. Templating with Handlebars\n\nTemplating: Technique for constructing and formating your content to display to the user.\n\nThis process of replacing fields is sometimes called **interpolation**, which is just a fancy word for “supplying missing information” in this context.\n\nPHP는 초기 템플릿 언어이다. 요즘 기술은 템플릿 엔진으로 따로 언어에서 분리되어 사용한다.\n\nJS에서 HTML을 뱉어서 발생하는 대부분의 문제를 템플릿을 통해 해결할 수 있다.\n\nPug는 HTML를 추상화했다. 인덴트와 몇몇 규칙을 사용해 타이핑 양을 줄였다.\n\n템플릿을 렌더링할 때 템플릿 엔진에게 **context 객체**를 건네준다.\n\nHandlebar의 주석은 HTML 주석과 달리 유저에게 전달되지 않는다.\n\n```html\n<!-- Include Handlebars from a CDN -->\n<script src=\"https://cdn.jsdelivr.net/npm/handlebars@latest/dist/handlebars.js\"></script>\n<script>\n  // compile the template\n  var template = Handlebars.compile('Handlebars <b>{{doesWhat}}</b>');\n  // execute the compiled template and print the output to the console\n  console.log(template({ doesWhat: 'rocks!' }));\n</script>\n```\n\n```js\n{\n  currency: {\n    name: 'United States dollars',\n    abbrev: 'USD',\n  },\n  tours: [\n    { name: 'Hood River', price: '$99.95' },\n    { name: 'Oregon Coast', price: '$159.95' },\n  ],\n  specialsUrl: '/january-specials',\n  currencies: [ 'USD', 'GBP', 'BTC' ],\n}\n```\n\n```handlebars\n<ul>\n  {{#each tours}}\n    {{! I'm in a new block...and the context has changed }}\n    <li>\n      {{name}} - {{price}}\n      {{#if ../currencies}}\n        ({{../currency.abbrev}})\n      {{/if}}\n    </li>\n  {{/each}}\n</ul>\n{{#unless currencies}}\n  <p>All prices in {{currency.name}}.</p>\n{{/unless}}\n{{#if specialsUrl}}\n  {{! I'm in a new block...but the context hasn't changed (sortof) }}\n  <p>Check out our <a href=\"{{specialsUrl}}\">specials!</p>\n{{else}}\n  <p>Please check back often for specials.</p>\n{{/if}}\n<p>\n  {{#each currencies}}\n    <a href=\"#\" class=\"currency\">{{.}}</a>\n  {{else}}\n    Unfortunately, we currently only accept {{currency.name}}.\n  {{/each}}\n</p>\n```\n\nClient-side templating은 유저에게 템플릿이 공개되지만 server-side는 유저가 알 수 없다. 캐싱도 가능하다.\n\n```js\napp.set('view cache', true);\n```\n\nview는 웹사이트의 개별 페이지를 의미하고, layout은 특별한 종류의 view로 템플릿을 위한 템플릿이다.\n\nview가 먼저 렌더링되고, 이후 레이아웃이 렌더링된다.\n\n섹션은 뭔 얘긴지 모르겠음,,,\n\nThe {{> partial_name}} syntax is how you include a partial in a view.\n\n```handlebars\n<div class=\"weatherWidget\">\n  {{#each partials.weatherContext}}\n    <div class=\"location\">\n      <h3>{{location.name}}></h3>\n      <a href=\"{{location.forecaseUrl}}\">\n        <img src=\"{{iconUrl}}\" alt=\"{{weather}}\">\n        {{weather}}, {{temp}}\n      </a>\n    </div>\n  {{/each}}\n  <small>Source: \n    <a href=\"https://www.weather.gov/documentation/services-web-api\">\n      National Weather Service\n    </a>\n  </small>\n</div>\n```\n\n```js\nconst getWeatherData = () =>\n  Promise.resolve([\n    {\n      location: {\n        name: 'Portland',\n        coordinates: { lat: 45.5154586, lng: -122.6793461 },\n      },\n      forecastUrl: 'https://api.weather.gov/gridpoints/PQR/112,103/forecast',\n      iconUrl: 'https://api.weather.gov/icons/land/day/tsra,40?size=medium',\n      weather: 'Chance Showers And Thunderstorms',\n      temp: '59 F',\n    },\n    {\n      location: {\n        name: 'Bend',\n        coordinates: { lat: 44.0581728, lng: -121.3153096 },\n      },\n      forecastUrl: 'https://api.weather.gov/gridpoints/PDT/34,40/forecast',\n      iconUrl: 'https://api.weather.gov/icons/land/day/tsra_sct,50?size=medium',\n      weather: 'Scattered Showers And Thunderstorms',\n      temp: '51 F',\n    },\n    {\n      location: {\n        name: 'Manzanita',\n        coordinates: { lat: 45.7184398, lng: -123.9351354 },\n      },\n      forecastUrl: 'https://api.weather.gov/gridpoints/PQR/73,120/forecast',\n      iconUrl: 'https://api.weather.gov/icons/land/day/tsra,90?size=medium',\n      weather: 'Showers And Thunderstorms',\n      temp: '55 F',\n    },\n  ]);\n\nconst weatherMiddleware = async (req, res, next) => {\n  // res.locals는 모든 view들에서 접근 가능하다.\n  if (!res.locals.partials) res.locals.partials = {};\n  res.locals.partials.weatherContext = await getWeatherData();\n  next();\n};\n\nmodule.exports = weatherMiddleware;\n```\n\n[HTML5 boilerplate](https://html5boilerplate.com)\n\n## 8. Form Handling\n\n유저로부터 정보를 모으는 여러 방법이 있지만 근원적으로는 HTML form을 활용하게 된다.\n\nGET과 POST 여부에 상관없이 HTTPS면 안전하고 HTTP면 위험하다.\n\n항상 form 태그에 유효한 action을 명시하는 것을 추천한다.\n\nform 제출은 기본적으로 application/x-www-form-urlencoded로 설정된다. URL encoded를 그냥 길게 쓴 것임. express에서 기본적으로 지원함.\n\n파일 전송은 multipart/form-data를 사용해야되는데, express에서 곧장 지원하지는 않음.\n\n[AJAX - 나무위키](https://namu.wiki/w/AJAX)\n\nAJAX를 사용하지 않으면 form을 제출했을 때 브라우저가 reload된다. 이때 브라우저에게 HTML을 보내주는 방법은 북마크나 뒤로가기 등을 고장낼 수 있어서 비추. 303(See Other)를 사용하자.\n\n이후 성공/실패 페이지로 리다이렉트하거나 flash message와 함께 원래 위치 혹은 새로운 위치로 리다이렉트할 수 있다.\n\n### Form Handling with Express\n\n```handlebars\n<h2>Sign up for our newsletter to receive news and specials!</h2>\n<form class=\"form-horizontal\" role=\"form\" action=\"/newsletter-signup/process?form=newsletter\" method=\"POST\">\n  <input type=\"hidden\" name=\"_csrf\" value=\"{{csrf}}\">\n  <div class=\"form-group\">\n    <label for=\"fieldName\" class=\"col-sm-2 control-label\">Name</label>\n    <div class=\"col-sm-4\">\n      <input type=\"text\" class=\"form-control\" id=\"fieldName\" name=\"name\">\n    </div>\n  </div>\n  <div class=\"form-group\">\n    <label for=\"fieldEmail\" class=\"col-sm-2 control-label\">Email</label>\n    <div class=\"col-sm-4\">\n      <input type=\"email\" class=\"form-control\" required id=\"fieldEmail\" name=\"email\">\n    </div>\n  </div>\n  <div class=\"form-group\">\n    <div class=\"col-sm-offset-2 col-sm-4\">\n      <button type=\"submit\" class=\"btn btn-primary\">Register</button>\n    </div>\n  </div>\n</form>\n```\n\n```js\nconst fortune = require('./fortune');\n\nexports.home = (req, res) => res.render('homeWithLink');\nexports.about = (req, res) => res.render('about', { fortune: fortune.getFortune() });\nexports.notFound = (req, res) => res.render('404');\nexports.serverError = (err, req, res, next) => res.render('500');\n\nexports.newsletterSignup = (req, res) => {\n  res.render('newsletter-signup', { csrf: 'CSRF token goes here' });\n};\nexports.newsletterSignupProcess = (req, res) => {\n  console.log('Form (from querystring): ' + req.query.form);\n  console.log('CSRF token (from hidden form field): ' + req.body._csrf);\n  console.log('Name (from visible form field): ' + req.body.name);\n  console.log('Email (from visible form field): ' + req.body.email);\n  // 301은 permenent라서 다음 요청때 캐시를 통해 bypass할 수 있어서 이 경우 사용하면 안됨.\n  res.redirect(303, '/newsletter-signup/thank-you');\n};\nexports.newsletterSignupThankYou = (req, res) => res.render('newsletter-signup-thank-you');\n```\n\n```js\nconst express = require('express');\nconst expressHandlebars = require('express-handlebars');\nconst handlers = require('./lib/handlers2');\n\nconst app = express();\nconst port = process.env.PORT || 3000;\n\nconst bodyParser = require('body-parser');\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.use('/css', express.static(__dirname + '/node_modules/bootstrap/dist/css'));\n\napp.use(express.static(__dirname + '/public'));\napp.engine(\n  'handlebars',\n  expressHandlebars.engine({\n    defaultLayout: 'main',\n  })\n);\napp.set('view engine', 'handlebars');\n\napp.get('/', handlers.home);\napp.get('/about', handlers.about);\n\napp.get('/newsletter-signup', handlers.newsletterSignup);\napp.post('/newsletter-signup/process', handlers.newsletterSignupProcess);\napp.get('/newsletter-signup/thank-you', handlers.newsletterSignupThankYou);\n\n// 여기가 마지막이 아니면 안됨!!!\napp.use(handlers.notFound);\napp.use(handlers.serverError);\n\napp.listen(port, () => console.log(`Express started on http://localhost:${port}`));\n```\n\n### Using Fetch to Send Form Data\n\n```js\ndocument.getElementById('newsletterSignupForm').addEventListener('submit', (evt) => {\n  evt.preventDefault();\n  const form = evt.target;\n  const body = JSON.stringify({\n    _csrf: form.elements._csrf.value,\n    name: form.elements.name.value,\n    email: form.elements.email.value,\n  });\n  const headers = { 'Content-Type': 'application/json' };\n  const container = document.getElementById('newsletterSignupFormContainer');\n  fetch('/api/newsletter-signup', { method: 'post', body, headers })\n    .then((resp) => {\n      if (resp.status < 200 || resp.status >= 300)\n        throw new Error(`Request failed with status ${resp.status}`);\n      return resp.json();\n    })\n    .then((json) => {\n      container.innerHTML = '<b>Thank you for signing up!</b>';\n    })\n    .catch((err) => {\n      container.innerHTML =\n        `<b>We're sorry, we had a problem` +\n        `signing you up. Please <a href=\"/newsletter\">try again</a>`;\n    });\n});\n\n// meadowlark.js\napp.use(bodyParser.urlencoded({ extended: true }));\n```\n\n### File Uploads\n\nbusboy / multiparty / formidable / multer\n\nform 태그에 enctype=\"multipart/form-data\"를 명시해주어야한다.\n\naccept를 통해 가능한 파일 형식을 지정해줄 수도 있다.\n\n```js\nconst multiparty = require('multiparty');\n\napp.post('/contest/vacation-photo/:year/:month', (req, res) => {\n  const form = new multiparty.Form();\n  form.parse(req, (err, fields, files) => {\n    if (err) return res.status(500).send({ error: err.message });\n    handlers.vacationPhotoContestProcess(req, res, fields, files);\n  });\n});\n```\n\n```js\n// Fetch를 사용한 방법\ndocument.getElementById('vacationPhotoContestForm').addEventListener('submit', (evt) => {\n  evt.preventDefault();\n  const body = new FormData(evt.target);\n  const container = document.getElementById('vacationPhotoContestFormContainer');\n  const url = '/api/vacation-photo-contest/{{year}}/{{month}}';\n  fetch(url, { method: 'post', body })\n    .then((resp) => {\n      if (resp.status < 200 || resp.status >= 300)\n        throw new Error(`Request failed with status ${resp.status}`);\n      return resp.json();\n    })\n    .then((json) => {\n      container.innerHTML = '<b>Thank you for submitting your photo!</b>';\n    })\n    .catch((err) => {\n      container.innerHTML =\n        `<b>We're sorry, we had a problem processing ` +\n        `your submission.  Please <a href=\"/newsletter\">try again</a>`;\n    });\n});\n```\n\n[Uppy](https://github.com/transloadit/uppy)\n\n> We explored the traditional way forms are handled by browsers (letting the browser issue a POST request to the server with the form contents and rendering the response from the server, usually a redirect) as well as the increasingly ubiquitous approach of preventing the browser from submitting the form and handling it ourselves with fetch.\n\n## 9. Cookies and Sessions\n\nHTTP는 stateless한 프로토콜이다. 모든 HTTP 요청은 서버가 응답하기 위해 필요한 모든 정보를 담고있다.\n\n- 쿠키는 유저에게 숨겨져있지 않다.\n- 쿠키는 삭제되거나 승인되지 않을 수 있다.\n- 쿠키는 조작될 수 있다. 쿠키에 코드를 담고 그걸 실행시키는 짓은 하면 안됨.\n- 쿠키는 공격에 이용될 수 있다. XSS(cross-site scripting) 중 하나는 쿠키의 내용을 바꾼다. signed cookie를 사용할 수는 있지만 덜 유용해질 수 있다.\n- 쿠키를 남용하면 유저가 눈치챈다.\n- 쿠키보다 세션을 선호하자.\n\n> cookie secret이란 서버에게 알려진 문자열로 쿠키를 클라이언트에게 보내기 전에 암호화한다.\n\ncredential을 externalizing하는 것은 유지보수가 편하고 버전 관리 시스템에서 제외하기 용이하다.\n\n```json\n{\n  \"cookieSecret\": \"...your cookie secret goes here\"\n}\n```\n\n```js\nconst env = process.env.NODE_ENV || 'development';\nconst credentials = require(`./.credentials.${env}`);\nmodule.exports = { credentials };\n```\n\n### Cookies in Express\n\n```js\nconst express = require('express');\nconst { credentials } = require('./config');\n\nconst app = express();\nconst port = process.env.PORT || 3000;\n\nconst cookieParser = require('cookie-parser');\napp.use(cookieParser(credentials.cookieSecret));\n\napp.get('/', (req, res) => {\n  res.cookie('monster', 'nom nom');\n  res.cookie('signed_monster', 'nom nom', { signed: true });\n  // res.clearCookie('monster');\n  res.send({ cookies: req.cookies, signedCookies: req.signedCookies });\n});\n\napp.listen(port, () => console.log(`Express started on http://localhost:${port}`));\n```\n\n쿠키의 domain, path, maxAge, secure, httpOnly, signed를 설정할 수 있다.\n\n크롬의 inspector에서 쿠키를 삭제할 수 있다.\n\n### Sessions\n\n세션은 상태를 유지하기 위한 더 편리한 방법이다.\n\n쿠키에 전부 저장하거나, 쿠키에는 식별자만 저장하고 나머지는 서버에 저장하는 방법이 있다. 전자는 cookie-based sessions로 불리고 클라이언트의 브라우저에 죄다 저장돼서 비추. 적은 양의 정보라서 이거 쓸거면 cookie-session 미들웨어를 사용하면 된다.\n\n후자는 어딘가에 세션 정보를 저장해야한다. 일단은 메모리에,, express-session 미들웨어를 써보자.\n\n```js\nconst express = require('express');\nconst expressHandlebars = require('express-handlebars');\nconst { credentials } = require('./config');\nconst flashMiddleware = require('./lib/middleware/flash');\n\nconst app = express();\nconst port = process.env.PORT || 3000;\n\napp.engine(\n  'handlebars',\n  expressHandlebars.engine({\n    defaultLayout: 'main',\n  })\n);\napp.set('view engine', 'handlebars');\n\nconst cookieParser = require('cookie-parser');\napp.use(cookieParser(credentials.cookieSecret));\n\nconst expressSession = require('express-session');\n// 쿠키 미들웨어를 미리 적용해야함 유의\napp.use(\n  expressSession({\n    resave: false,\n    saveUninitialized: false,\n    secret: credentials.cookieSecret,\n  })\n);\n\napp.use(flashMiddleware);\n\napp.get('/', (req, res) => {\n  req.session.flash = {\n    type: 'danger',\n    intro: 'Database error!',\n    message: 'There was a database error; please try again later.',\n  };\n  return res.redirect(303, '/newsletter/archive');\n});\n\napp.get('/newsletter/archive', (req, res) => {\n  res.render('homeWithFlash');\n});\n\napp.listen(port, () => console.log(`Express started on http://localhost:${port}`));\n```\n\n[delete vs undefined](https://stackoverflow.com/questions/14967535/delete-a-x-vs-a-x-undefined)\n\n```handlebars\n{{#if flash}}\n<div class=\"alert alert-dismissible alert-{{flash.type}}\">\n  <button type=\"button\" class=\"close\" data-dismiss=\"alert\" aria-hidden=\"true\">&times;</button>\n  <strong>{{flash.intro}}</strong> {{{flash.message}}}\n</div>\n{{/if}}\n<h1>Welcome to Meadowlark Travel</h1>\n```\n\nThe use of sessions to control UI like this is typically not used in applications that use Ajas for form submission. 프론트엔드에서 렌더링하는 어플리케이션에서는 이런 방법은 잘 안쓴다.\n\n세션은 페이지를 넘나들며 유용한 유저 정보를 저장하기에 유용하다.\n\n그럼 쿠키 차단하면 refresh마다 로그인 풀리고 그러나??\n\n## 10. Middleware\n\n> Conceptually, middleware is a way to encapsulate functionality—specifically, functionality that operates on an HTTP request to your application.\n\n미들웨어는 req, res, next 세가지의 인자를 받는다.\n\n미들웨어는 파이프라인으로 실행되고, 따라서 순서가 중요하다. app.use를 통해 파이프라인에 미들웨어를 삽입한다.\n\n마지막 미들웨어는 catchall handler로 자주 활용된다. next를 호출하지 않으면 request는 해당 미들웨어에서 중단된다.\n\n- Route handler(app.get, app.post...)는 특정 HTTP 동사만 처리하는 미들웨어로 생각할 수 있다.\n- Route handler는 첫 패러미터로 path를 필요로하고, \\*를 사용해서?? 어떤 path든지 매치시킬 수 있다. 미들웨어도 path 명시 가능\n- 2, 3개의 패러미터면 req, res, next, 4개면 err, req, res, next\n- next를 호출하는데 클라이언트에게 응답하는 것은 비추. 이러면 이후 응답은 무시된다.\n\n```js\nconst express = require('express');\nconst app = express();\n\napp.use((req, res, next) => {\n  console.log('\\n\\nALWAYS');\n  next();\n});\n\napp.get('/a', (req, res) => {\n  console.log('/a: route terminated');\n  res.send('a');\n});\napp.get('/a', (req, res) => {\n  console.log('/a: never called');\n});\n\napp.get('/b', (req, res, next) => {\n  console.log('/b: route not terminated');\n  next();\n});\napp.use((req, res, next) => {\n  console.log('SOMETIMES');\n  next();\n});\napp.get('/b', (req, res, next) => {\n  console.log('/b (part 2): error thrown');\n  throw new Error('b failed');\n});\napp.use('/b', (err, req, res, next) => {\n  console.log('/b error detected and passed on');\n  next(err);\n});\n\n// err랑 req가 맞나??\napp.get('/c', (err, req) => {\n  console.log('/c: error thrown');\n  throw new Error('c failed');\n});\napp.use('/c', (err, req, res, next) => {\n  console.log('/c: error detected but not passed on');\n  next();\n});\n\n// 궁금해서 추가\napp.use('/d', (req, res) => {\n  // Always가 두 번 출력됨. redirect하면 처음부터 되는 듯.\n  res.redirect(303, '/a');\n});\n\napp.use((err, req, res, next) => {\n  console.log('unhandled error detected: ' + err.message);\n  res.send('500 - server error');\n});\n\napp.use((req, res) => {\n  console.log('route not handled');\n  res.send('404 - not found');\n});\n\nconst port = process.env.PORT || 3000;\napp.listen(port, () =>\n  console.log(`Express started on http://localhost:${port}` + '; press Ctrl-C to terminate.')\n);\n```\n\n```js\n// middleware의 반환값으로 뭐 하는게 없어서 아래처럼 줄여쓸 수 있다.\nnext();\nreturn;\n\nreturn next();\n```\n\nexpress에 번들 된 미들웨어는 static뿐이다.\n\n- basicauth-middleware: HTTPS 환경에서 빠르게 해야할 때만 사용할 것.\n- body-parser\n- bosboy, multiparty, formidable, multer: multipart/form-data의 body 처리\u001f\n- compression. 대부분 프로덕션 환경에서는 NGINX 같은 프록시가 압축을 처리한다.\n- cookie-parser\n- cookie-session. 추천은 안함\n- express-session\n- csurf: CSRF에서 보호\n- serve-index: directory listing support\n- errorhandler: 클라이언트에 stack trace/error message 적용. 프로덕션 서버에서는 쓰지 말 것.\n- serve-favicon: 더 좋은 성능\n- morgan: 디버깅용.\n- response-time\n- static\n- vhost: virtual hosts\n\n[expressjs.com - middleware](https://expressjs.com/en/resources/middleware.html)\n\n## 11. Sending Email\n\n> Lingua franca: 모국어가 다른 사람들이 상호 이해를 위하여 만들어 사용하는 언어. 어느 한쪽의 모국어이거나 제3의 언어일 때도 있으나, 대개의 경우 양쪽 국어가 혼합되고 문법이 간략하게 된 것이 많음. 명칭은 중세 시대 십자군이나 무역업자들 사이에서 사용된, 프로방스어를 중심으로 한 여러 언어의 혼합어에서 유래함.\n\n이메일을 보낼 때의 lingua franca는 SMTP(Simple Mail Transfer Protocol)이다. 하지만 이걸 바로 쓰면 trusted sender가 아니기 때문에 스팸메일함으로 갈 것임.\n\n따라서 MSA(Mail Submission Agent)를 사용. MTA(Mail Transfer Agent)는 뭐가 다른거지??\n\nSendgrid 가입하기 귀찮아서,,,PASS\n\n## 12. Production Concerns\n\n원하는 만큼의 서로 다른 환경을 가질 수 있다. 보통 development, production, test를 사용한다.\n\n`app.get('env')`로 현재 모드를 알아낼 수 있다.\n\n```bash\nexport NODE_ENV=production\nnode meadowlark.js\n# Unix/BSD에서 명령어 실행되는 동안만 환경 바꾸기\nNODE_ENV=production node meadowlark.js\n```\n\n```js\nconst express = require('express');\nconst morgan = require('morgan');\nconst fs = require('fs');\n\nconst app = express();\n\nconsole.log(app.get('env'));\n\nswitch (app.get('env')) {\n  case 'development':\n    app.use(morgan('dev'));\n    break;\n  case 'production':\n    const stream = fs.createWriteStream(__dirname + '/access.log', { flags: 'a' });\n    app.use(morgan('combined', { stream }));\n    break;\n}\n\napp.listen(3000);\n```\n\n```log\n::1 - - [03/Nov/2022:16:29:09 +0000] \"GET / HTTP/1.1\" 404 139 \"-\" \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.1 Safari/605.1.15\"\n::1 - - [03/Nov/2022:16:29:19 +0000] \"GET / HTTP/1.1\" 404 139 \"-\" \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.1 Safari/605.1.15\"\n```\n\n로그를 저장하는 Unix-like 접근법은 /var/log의 서브디렉터리에 저장하는 것이다. 아파치가 이렇게 함.\n\n지금까지는 node로 곧장 실행시켰지만 production에서는 이 경우 앱이 충돌나거나 종료되었을 때를 위한 보호가 없다. 이때 **process manager**를 사용한다. Forever, PM2 등등...\n\n저자의 의견으로는 Forever가 조금 더 직관적이고 시작하기 쉬웠고 PM2는 기능이 더 많았다.\n\n- Scaling up: 서버를 더 강력하게\n- Scaling out: 서버를 더 많이\n\n노드는 scaling out하기 용이하다.\n\n하지만 persistence를 유념하기. Persistence를 위해 file-based storage를 사용한다면 나중에 scale out할 때 정신나갈 것임. 모든 서버에서 접근 가능한 파일 시스템이 아닌 이상 local filesystem을 사용하면 안된다. read-only data는 그나마 예외.\n\nNode는 app cluster를 지원한다. CPU 코어마다 독립적인 서버를 만들 수 있다.\n\n```js\nconst cluster = require('cluster');\n\nfunction startWorker() {\n  const worker = cluster.fork();\n  console.log(`CLUSTER: Worker ${worker.id} started`);\n}\n\n// script를 직접 실행했으면 master mode\nif (cluster.isMaster) {\n  require('os').cpus().forEach(startWorker);\n  // log any workers that disconnect; if a worker disconnects, it\n  // should then exit, so we'll wait for the exit event to spawn\n  // a new worker to replace it\n  cluster.on('disconnect', (worker) =>\n    console.log(`CLUSTER: Worker ${worker.id} disconnected from the cluster.`)\n  );\n\n  // when a worker dies (exits), create a worker to replace it\n  cluster.on('exit', (worker, code, signal) => {\n    console.log(`CLUSTER: Worker ${worker.id} died with exit ` + `code ${code} (${signal})`);\n    startWorker();\n  });\n} else {\n  const port = process.env.PORT || 3000;\n  // start our app on worker; see meadowlark.js\n  require('./01-server.js')(port);\n}\n```\n\n```js\nconst express = require('express');\nconst cluster = require('cluster');\nconst app = express();\n\nfunction startServer(port) {\n  app.listen(port, () => {\n    console.log(\n      `Express started in ${app.get('env')} ` +\n        `mode on http://localhost:${port}` +\n        `; press Ctrl-C to terminate.`\n    );\n  });\n}\n\napp.use((req, res, next) => {\n  if (cluster.isWorker) {\n    console.log(`Worker ${cluster.worker.id} received request`);\n  }\n  next();\n});\n\nif (require.main === module) {\n  // application run directly; start app server\n  startServer(process.env.PORT || 3000);\n} else {\n  // application imported as a module via \"require\": export\n  // function to create server\n  module.exports = startServer;\n}\n```\n\n코어가 10개인 것 같은데 worker가 10개인건 master와 worker가 같이 돌아가는 코어가 있다는 뜻인가??\n\n```js\n// 서버 터지고 request가 serve되지 않음\napp.get('/epic-fail', (req, res) => {\n  // execution of the function with the exception is being deferred until Node is idle\n  process.nextTick(() => throw new Error('Kaboom!'));\n  // 함수를 실행할 쯤이면 더 이상 serve하던 request의 context가 존재하지 않는다?\n});\n```\n\n> If Node can't determine the stability of your application, neither can you.\n\n가장 쉬운 failover 매커니즘은 cluster를 사용하는 것이다. 한 worker가 죽으면 master가 그 자리에 새로운 worker를 소환한다.\n\n```js\n// uncaughtException 이벤트를 사용한다.\nprocess.on('uncaughtException', (err) => {\n  console.error('UNCAUGHT EXCEPTION\\n', err.stack);\n  // do any cleanup you need to do here...close\n  // database connections, etc.\n  process.exit(1);\n});\n```\n\n여러 서버로 늘려야되면 **프록시 서버**를 활용한다. 외부 네트워크에 접근하기 위해 사용되는 프록시 서버와 구분해 reverse proxy, forward-facing proxy로 불리기도 한다.\n\n개발중에 간단히 하려면 node-http-proxy도 있다.\n\n```js\n// Express에게 프록시를 사용하고 it should be trusted임을 알린다.\napp.enable('trust proxy');\n// 이후 req.ip, req.protocol, req.secure가 client와 app이 아닌 client와 proxy 사이 연결을 반영한다.\n// 특히 req.ip는 클라이언트 ip와 중간 프록시의 ip를 담은 배열이 된다.\n```\n\n서버가 죽으면 서버 내에 있는 모니터도 죽으니 third-party uptime monitor가 필요하다. UptimeRobot 등등...\n\nArtillery 등으로 stress test를 할 수 있다.\n\n```json\n\"scripts\": {\n  \"stress\": \"artillery quick --count 10 -n 20 http://localhost:3000/\"\n},\n```\n\n## 13. Persistence\n\n데이터를 flat files로 저장해서 달성할 수 있다. 파일에 구조가 없기 때문에 flat file이라고 한다. Just a sequence of bytes. 이거는 scale이 용이하지는 않다.\n\n사진 같은 이진 파일은 데이터베이스보다 파일 시스템이 더 잘하긴 한다. 이 경우에도 탐색이나 정렬을 위한 이미지에 대한 데이터는 데이터베이스에 저장한다. 그래도 scale이 잘 안되니 S3나 Azure같은 클라우드 기반 저장 시스템을 쓰자.\n\n```js\n// filesystem persistence\nconst pathUtils = require('path');\nconst fs = require('fs');\n\n// create directory to store vacation photos (if it doesn't already exist)\nconst dataDir = pathUtils.resolve(__dirname, '..', 'data');\nconst vacationPhotosDir = pathUtils.join(dataDir, 'vacation-photos');\nif (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir);\nif (!fs.existsSync(vacationPhotosDir)) fs.mkdirSync(vacationPhotosDir);\n\nfunction saveContestEntry(contestName, email, year, month, photoPath) {\n  // TODO...this will come later\n}\n\n// we'll want these promise-based versions of fs functions later\nconst { promisify } = require('util');\nconst mkdir = promisify(fs.mkdir);\nconst rename = promisify(fs.rename);\n\nexports.api.vacationPhotoContest = async (req, res, fields, files) => {\n  const photo = files.photo[0];\n  const dir = vacationPhotosDir + '/' + Date.now();\n  const path = dir + '/' + photo.originalFilename;\n  await mkdir(dir);\n  await rename(photo.path, path);\n  saveContestEntry('vacation-photo', fields.email, req.params.year, req.params.month, path);\n  res.send({ result: 'success' });\n};\n```\n\n```js\n// Cloud Persistence (S3)\nconst filename = 'customerUpload.jpg'\n\ns3.putObject({\n  Bucket: 'uploads',\n  Key: filename,\n  Body: fs.readFileSync(__dirname + '/tmp/ + filename),\n})\n```\n\n유명한 NoSQL의 타입은 document database와 key-value database이다. 전자는 객체를 잘 저장해서 Node와 JS에 맞고, 후자는 매우 단순하고 key-value 짝인 데이터 스킴을 가지는 앱에 유용하다.\n\nMongoDB가 document database에 자주 사용된다. RDBMS(relational database management system)에는 PostgreSQL을 사용해보자.\n\nNoSQL은 성능을 위한 동시성에 집중했다.\n\nMongoDB를 위한 ODM(object document mapper)에는 Mongoose가 있다. JS에서는 object model이 매우 유연하지만 남용하면 데이터베이스의 최적화에 나쁜 영향을 줄 수 있다. 이에 Mongoose는 schema와 model을 도입했다.\n\n[currency.js](https://github.com/scurker/currency.js)\n\n```js\nrequire('dotenv').config();\nconst mongoose = require('mongoose');\nconst Vacation = require('./models/vacation');\nconst connectionString = process.env.MONGO_CONNECTION_STRING;\nif (!connectionString) {\n  console.error('MongoDB connection string missing!');\n  process.exit(1);\n}\n\nmongoose.connect(connectionString);\nconst db = mongoose.connection;\ndb.on('error', (err) => {\n  console.error('MongoDB error: ' + err.message);\n  process.exit(1);\n});\ndb.once('open', () => console.log('MongoDB connection established'));\n\nVacation.find((err, vacations) => {\n  if (err) return console.error(err);\n  if (vacations.length) return;\n\n  new Vacation({\n    name: 'Hood River Day Trip',\n    slug: 'hood-river-day-trip',\n    category: 'Day Trip',\n    sku: 'HR199',\n    description: 'Spend a day sailing on the Columbia and ' + 'enjoying craft beers in Hood River!',\n    location: {\n      search: 'Hood River, Oregon, USA',\n    },\n    price: 99.95,\n    tags: ['day trip', 'hood river', 'sailing', 'windsurfing', 'breweries'],\n    inSeason: true,\n    maximumGuests: 16,\n    available: true,\n    packagesSold: 0,\n  }).save();\n\n  new Vacation({\n    name: 'Oregon Coast Getaway',\n    slug: 'oregon-coast-getaway',\n    category: 'Weekend Getaway',\n    sku: 'OC39',\n    description: 'Enjoy the ocean air and quaint coastal towns!',\n    location: {\n      search: 'Cannon Beach, Oregon, USA',\n    },\n    price: 269.95,\n    tags: ['weekend getaway', 'oregon coast', 'beachcombing'],\n    inSeason: false,\n    maximumGuests: 8,\n    available: true,\n    packagesSold: 0,\n  }).save();\n});\n\nmodule.exports = {\n  getVacations: async (options = {}) => Vacation.find(options),\n  addVacationInSeasonListener: async (email, sku) => {\n    // we'll just pretend we did this...since this is\n    // an async function, a new promise will automatically\n    // be returned that simply resolves to undefined\n  },\n};\n```\n\n```js\nconst mongoose = require('mongoose');\n\nconst vacationSchema = mongoose.Schema({\n  name: String,\n  slug: String,\n  category: String,\n  sku: String,\n  description: String,\n  location: {\n    search: String,\n    coordinates: {\n      lat: Number,\n      lng: Number,\n    },\n  },\n  price: Number,\n  tags: [String],\n  inSeason: Boolean,\n  available: Boolean,\n  requiresWaiver: Boolean,\n  maximumGuests: Number,\n  notes: String,\n  packagesSold: Number,\n});\n\n// Vacation is very much like a class in traditional object-oriented programming.\nconst Vacation = mongoose.model('Vacation', vacationSchema);\nmodule.exports = Vacation;\n```\n\n> There are good reasons not to pass unmapped database objects directly to views. The view gets a bunch of properties it may not need, possibly in formats that are incompatible with it.\n\n> **In some variations of the MVC architecture, a third component called a view model is introduced. A view model essentially distills and transforms a model (or models) so that it’s more appropriate for display in a view. What we’re doing here is creating a view model on the fly.**\n\n## 14. Routing\n\n## 15. REST APIs and JSON\n\n## 16. Single-Page Applications\n\n## 17. Static Content\n\n## 18. Security\n\n## 19. Integrating with Third-Party APIs\n\n## 20. Debugging\n\n## 21. Going Live\n\n## 22. Maintenance\n\n## 23. Additional Resources\n","path":"backend/express/web-development-with-node-and-express/index.md"}