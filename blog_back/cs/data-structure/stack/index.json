{"pathArr":[],"metaData":{"title":"스택"},"content":"\n> In computer science, a stack is an abstract data type that serves as a collection of elements, with two main principal operations:\n\n> - Push, which adds an element to the collection, and\n> - Pop, which removes the most recently added element that was not yet removed.\n>\n> -wikipedia\n\n**LIFO (last in, first out)**\n\n## ADT\n\n```{class=\"language-c\"}\nvoid StackInit(Stack *pstack);\n\nbool SIsEmpty(Stack *pstack);\n\nvoid SPush(Stack *pstack, Data data);\n\nData SPop(Stack *pstack);\n// 데이터가 하나 이상 존재함이 보장되어야 한다.\n\nData SPeek(Stack *pstack);\n// 데이터가 하나 이상 존재함이 보장되어야 한다.\n```\n\n배열 기반이면 몰라도 연결리스트 기반 스택이면 size 변수가 굳이 필요하지 않음.\n\nexit 함수의 사용도 눈여겨보자.\n\n중위연산자 변환 문제 풀어보기,,,\n\n## 연결 리스트 기반 스택 구현\n\n```{class=\"language-c\"}\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef int LData;\n\ntypedef struct _Node\n{\n    struct _Node *next;\n    LData data;\n} Node;\n\ntypedef struct _Stack\n{\n    Node *head;\n} Stack;\n\nvoid StackInit(Stack *pstack)\n{\n    pstack->head = malloc(sizeof(Node));\n    pstack->head->next = NULL;\n}\n\nbool SIsEmpty(Stack *pstack)\n{\n    return !(pstack->head->next);\n}\n\nvoid SPush(Stack *pstack, LData data)\n{\n    Node *node = malloc(sizeof(Node));\n    node->data = data;\n    node->next = pstack->head->next;\n    pstack->head->next = node;\n}\n\nLData SPop(Stack *pstack)\n{\n    if (!(pstack->head->next))\n    {\n        printf(\"Stack Memory Error\");\n        exit(-1);\n    }\n    Node *toRemove = pstack->head->next;\n    pstack->head->next = pstack->head->next->next;\n    LData ret = toRemove->data;\n    free(toRemove);\n    return ret;\n}\n\nint main()\n{\n    Stack stack;\n    LData data;\n    StackInit(&stack);\n    for (int i = 0; i < 10; i++)\n        SPush(&stack, i);\n    while (!SIsEmpty(&stack))\n        printf(\"%d \", SPop(&stack));\n    return 0;\n}\n```\n","path":"cs/data-structure/stack/index.md"}