{"pathArr":[],"metaData":{"title":"리스트"},"content":"\n## 구현 방법에 따른 리스트의 분류\n\n[순차 리스트](array-list)\n\n- 배열을 기반으로 구현된 리스트\n\n[연결 리스트](linked-list)\n\n- 메모리의 동적 할당을 기반으로 구현된 리스트\n\n## 리스트의 변형\n\n[원형 연결 리스트](circular-linked-list)\n\n[양방향 연결 리스트](double-linked-list)\n\n## 리스트의 기본 특성\n\n데이터를 나란히 저장하며 중복된 데이터의 저장을 막지 않는다.\n\n> In computer science, a list or sequence is an abstract data type that represents a finite number of ordered values, where the same value may occur more than once.\n>\n> - Wikipedia\n\n원소의 추가 순서가 보존될 필요는 없는 것 같다.\n\n## ADT 정의\n\n구현하려는 리스트의 기본적인 ADT는 다음과 같다. 리스트의 종류에 따라 추가적인 기능이 있을 수 있다.\n\n책의 예제에 내 생각을 첨가해서 ADT를 꽤나 수정했다.\n\n- LRemove가 데이터를 반환해야 할 이유를 모르겠어서 책의 예제의 반환값이없던 LData에서 Void로 수정했다. 어차피 LFirst나 LNext 호출하고 LRemove를 쓸거니까. 스택의 pop 같은 함수면 반환해야지.\n- 또한 책에는 리스트를 deinit하는 함수가 없어서 내가 추가했다.\n\n```{class=\"language-c\"}\nvoid ListInit(List *plist);\n// 리스트 생성 후 가장 먼저 호출되어야 하는 함수\n\nvoid LInsert(List *plist, LData *pdata);\n\nbool LFirst(List *plist, LData *pdata);\n// 데이터의 참조를 위한 초기화가 진행된다.\n// 성공 여부를 반환한다.\n\nbool LNext(List *plist, LData *pdata);\n// 다음 데이터를 참조한다.\n// 순차적 참조를 위한 반복 호출이 가능하다.\n\nvoid LRemove(List *plist);\n// LFirst 혹은 LNext의 마지막 반환 데이터를 삭제한다.\n\nint LCount(List *plist);\n\nvoid LClear(List *plist);\n```\n\n추가로 다음 typedef를 통해 사용할 리스트와 저장할 원소를 유동적으로 변경할 수 있다.\n\n```{class=\"language-c\"}\ntypedef Point LData;\ntypedef LinkedList List;\n```\n\n## 리스트 구현\n\nADT는 구현에 영향을 미쳐 중요하다. 예를 들어 LFirst가 순회 전에 항상 호출됨을 명시되어있는데, 따라서 LInit에서는 before를 꼭 초기화하지 않아도 된다. 마찬가지로 LRemove에서는 원소의 개수가 0임을 확인하지 않아도 된다.\n\n구현 단계에서는 next 함수에서 data 참조와 next 이동의 순서 관계가 포인트. 이동을하고 참조를 하니 cur 이 6에 있다는 것을 6이 참조되었다는 것을 의미한다.\n\nLClear 함수를 구현하다보니 LFirst와 LNext 함수에 LData 포인터가 꼭 유효해야하는지 고민하게 되었다. 그래서 두 함수에 포인터가 NULL인지 확인하는 조건문을 삽입했다.\n\nwhile문이 종료되었다는 것은 그 아래는 while문의 조건을 충족시키지 못하는 상태하는 뜻. 당연하지만 코드 해석할 때 유용한 정보이다.\n\n## 추가할 원소 정의\n\n테스트를 위해 다음과 같은 구조체와 함수를 정의했다. 자연수 배열에서 자연수를 찾는 것은 웃기니까 ^^;\n\n```{class=\"language-c\"}\ntypedef struct __Point\n{\n    int x;\n    int y;\n    int level;\n} Point;\n\nvoid printPoint(Point *a)\n{\n    printf(\"(%d, %d, level: %d) \", a->x, a->y, a->level);\n}\n```\n\n다음과 같이 typedef를 정의해 사용할 리스트의 종류와 저장될 원소를 유동적으로 지정할 수 있다.\n\n```{class=\"language-c\"}\ntypedef Point LData;\ntypedef LinkedList List;\n```\n\n## 테스트 코드\n\n```{class=\"language-c\"}\nint main(void)\n{\n    int testDataSize = 7;\n    int xList[] = {3, 1, 4, 1, 5, 9, 2};\n    int yList[] = {6, 8, 3, 5, 8, 9, 7};\n    int level[] = {3, 2, 3, 8, 4, 6, 2};\n\n    Point *testData = malloc(sizeof(Point) * testDataSize);\n\n    for (int i = 0; i < testDataSize; i++)\n    {\n        testData[i].x = xList[i];\n        testData[i].y = yList[i];\n        testData[i].level = level[i];\n    }\n\n    List list;\n    Point data;\n    ListInit(&list);\n\n    for (int i = 0; i < testDataSize; i++)\n        LInsert(&list, testData[i]);\n\n    printf(\"Data Count: %d\\n\", LCount(&list));\n\n    if (LFirst(&list, &data))\n    {\n        PrintPoint(&data);\n        while (LNext(&list, &data))\n            PrintPoint(&data);\n    }\n    puts(\"\");\n\n    if (LFirst(&list, &data))\n    {\n        if (data.level == 2)\n            LRemove(&list);\n        while (LNext(&list, &data))\n            if (data.level == 2)\n                LRemove(&list);\n    }\n    if (LFirst(&list, &data))\n    {\n        PrintPoint(&data);\n        while (LNext(&list, &data))\n            PrintPoint(&data);\n    }\n    puts(\"\");\n    printf(\"Data Count: %d\\n\", LCount(&list));\n    LClear(&list);\n}\n```\n\nC를 오랜만에 다뤘는데 검색 중 다음과 같은 사실들을 깨달았다.\n\n- c언어에서 NULL은 포인터에 적용됨.\n- [NULL의 크기](https://stackoverflow.com/questions/4141666/why-sizeof-is-equivalent-to-1-and-sizeofnull-is-equivalent-to-4-in-c-langu/4141699)\n- You must always check for NULL pointers when using malloc & co. In that case NULL mean that something went wrong, most likely that no memory was available.\n\n[Difference between head and tail insert in a single linkedlist](https://stackoverflow.com/questions/58581870/difference-between-head-and-tail-insert-in-a-single-linkedlist)\n\n> The difference is in the names.\n\n> A \"tail insert\" inserts the new object at the tail of the list and thus the list has the same order as the order in which elements are added.\n\n> A \"head insert\" inserts the new object at the head of the list, so the list has the reverse order compared to the order in which elements are added.\n","path":"cs/data-structure/list/index.md"}