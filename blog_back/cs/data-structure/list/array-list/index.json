{"pathArr":[],"metaData":{"title":"배열 기반 리스트 구현"},"content":"\n장점\n\n- 데이터의 참조가 쉽다. 인덱스 값을 기준으로 어디든 한 번에 참조가 가능하다.\n\n단점\n\n- 배열의 길이가 초기에 결정되어야 한다. 변경이 불가능하다??\n\n- 삭제의 과정에서 데이터의 이동(복사)가 매우 빈번히 일어난다.\n\n윤성우님 책에 있는 내용인데, 연결리스트와 비교해서 위와 같이 말할 수 있는 듯. 변경이 불가능하다고 하기는 힘들지 않을까?\n\n```{class=\"language-c\"}\n#include <stdio.h>\n#include <stdbool.h>\n\n#define LIST_LEN 100\ntypedef int LData;\n\ntypedef struct __ArrayList\n{\n    LData arr[LIST_LEN];\n    int numOfData;\n    int curPos;\n} ArrayList;\n\ntypedef ArrayList List;\n\nvoid ListInit(List *plist)\n{\n    plist->numOfData = 0;\n    plist->curPos = -1;\n}\n\nvoid LInsert(List *plist, LData data)\n{\n    if (plist->numOfData >= LIST_LEN)\n    {\n        puts(\"저장할 공간이 없습니다\");\n        return;\n    }\n    plist->arr[plist->numOfData] = data;\n    plist->numOfData++;\n}\n\nbool LFirst(List *plist, LData *pdata)\n{\n    if (plist->numOfData == 0)\n        return false;\n    plist->curPos = 0;\n    *pdata = plist->arr[plist->curPos];\n    return true;\n}\n\nbool LNext(List *plist, LData *pdata)\n{\n    if (plist->curPos >= (plist->numOfData) - 1)\n        return false;\n    (plist->curPos)++;\n    *pdata = plist->arr[plist->curPos];\n    return true;\n}\n\nint LCount(List *plist)\n{\n    return plist->numOfData;\n}\n\nLData LRemove(List *plist)\n{\n    int ret = plist->arr[plist->curPos];\n    for (int i = plist->curPos; i < (plist->numOfData) - 1; i++)\n    {\n        plist->arr[i] = plist->arr[i + 1];\n    }\n    (plist->numOfData)--;\n    (plist->curPos)--;\n    return ret;\n}\n\n```\n","path":"cs/data-structure/list/array-list/index.md"}