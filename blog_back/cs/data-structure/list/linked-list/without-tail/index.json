{"pathArr":[],"metaData":{"title":"꼬리 없는 연결 리스트 구현"},"content":"\n## 구조체 선언\n\n```{class=\"language-c\"}\ntypedef struct _node\n{\n    LData data;\n    struct _node *next;\n} Node;\n\ntypedef struct _linkedList\n{\n    Node *head;\n    Node *cur;\n    Node *prev;\n    int size;\n    bool (*AreInIncreasingOrder)(LData *a, LData *b);\n} LinkedList;\n```\n\n## 더미 노드가 없는 끔찍한 구현\n\n숨 쉴 때마다 head에 대한 예외를 생각해야한다. 정렬 때문에 head에 원소를 삽입해야되는 경우 예외처리를해줘야하는데 정말 끔찍하다. cur가 아무리 앞에 있어도 head에위치해있는데 이러면 head 뒤에만 원소를 이을 수밖에 없기 때문.\n\n```{class=\"language-c\"}\nvoid ListInit(List *plist)\n{\n    plist->head = NULL;\n    plist->size = 0;\n    plist->AreInIncreasingOrder = NULL;\n}\n\nvoid LInsert(List *plist, LData data)\n{\n    Node *node = malloc(sizeof(Node));\n    node->data = data;\n    (plist->size)++;\n    if (!plist->head)\n    {\n        node->next = NULL;\n        plist->head = node;\n        return;\n    }\n    if (plist->AreInIncreasingOrder)\n    {\n        if (plist->AreInIncreasingOrder(&data, &(plist->head->data)))\n        {\n            node->next = plist->head;\n            plist->head = node;\n            return;\n        }\n        Node *cur = plist->head;\n        while (cur->next && plist->AreInIncreasingOrder(&cur->next->data, &data))\n            cur = cur->next;\n        node->next = cur->next;\n        cur->next = node;\n    }\n    else\n    {\n        node->next = plist->head->next;\n        plist->head = node;\n    }\n}\n\nbool LFirst(List *plist, LData *data)\n{\n    if (!(plist->size))\n        return false;\n    plist->prev = NULL;\n    plist->cur = plist->head;\n    if (data)\n        *data = plist->cur->data;\n    return true;\n}\n\nbool LNext(List *plist, LData *data)\n{\n    if (!(plist->cur->next))\n        return false;\n    plist->prev = plist->cur;\n    plist->cur = plist->cur->next;\n    if (data)\n        *data = plist->cur->data;\n    return true;\n}\n\nint LCount(List *plist) { return plist->size; }\n\nvoid LRemove(List *plist)\n{\n    (plist->size)--;\n    if (!plist->prev)\n    {\n        plist->head = plist->head->next;\n        free(plist->cur);\n        plist->cur = plist->head;\n        return;\n    }\n    plist->prev->next = plist->cur->next;\n    free(plist->cur);\n    plist->cur = plist->prev;\n}\n\nvoid LClear(List *plist)\n{\n    while (LFirst(plist, NULL))\n    {\n        LRemove(plist);\n    }\n}\n\nvoid SetSortRule(List *plist, bool (*AreInIncreasingOrder)(LData *a, LData *b))\n{\n    plist->AreInIncreasingOrder = AreInIncreasingOrder;\n}\n```\n\n## 더미 노드가 있는 구현\n\n> Since every position you want to insert at (and every node you're allowed to delete) has a prev and next node, the code is simplified.\n\n[출처](https://stackoverflow.com/questions/9103577/what-is-the-difference-between-the-head-node-and-starting-node-of-link-list)\n\n- LInit에서 head에 더미 노드를 붙인다. 더미의 data는 상관 없지만 next는 NULL이어야 한다.\n- LInsert에서 초반 head가 NULL일 경우의 예외 처리 삭제.\n- 정렬 삽입일 때 맨 앞에 삽입되는 경우의 예외 처리 삭제.\n- 정렬 없는 삽입에서 plist->head = node;를 plist->head->next = node;로 변경\n- LFirst에서 이제 prev가 더미 노드를 가르킴.\n- LRemove에서 prev가 NULL인지 확인하지 않음.\n- 더미가 있어서 head 노드가 삭제될 걱정을 하지 않아도 된다.\n\n```{class=\"language-c\"}\nvoid ListInit(List *plist)\n{\n    plist->head = malloc(sizeof(Node));\n    plist->head->next = NULL;\n    plist->size = 0;\n    plist->AreInIncreasingOrder = NULL;\n}\n\nvoid LInsert(List *plist, LData data)\n{\n    Node *node = malloc(sizeof(Node));\n    node->data = data;\n    (plist->size)++;\n    if (plist->AreInIncreasingOrder)\n    {\n        Node *cur = plist->head;\n        while (cur->next && plist->AreInIncreasingOrder(&cur->next->data, &data))\n            cur = cur->next;\n        node->next = cur->next;\n        cur->next = node;\n    }\n    else\n    {\n        node->next = plist->head->next;\n        plist->head->next = node;\n    }\n}\n\nbool LFirst(List *plist, LData *data)\n{\n    if (!(plist->size))\n        return false;\n    plist->prev = plist->head;\n    plist->cur = plist->head->next;\n    if (data)\n        *data = plist->cur->data;\n    return true;\n}\n\nbool LNext(List *plist, LData *data)\n{\n    if (!(plist->cur->next))\n        return false;\n    plist->prev = plist->cur;\n    plist->cur = plist->cur->next;\n    if (data)\n        *data = plist->cur->data;\n    return true;\n}\n\nint LCount(List *plist) { return plist->size; }\n\nvoid LRemove(List *plist)\n{\n    (plist->size)--;\n    plist->prev->next = plist->cur->next;\n    free(plist->cur);\n    plist->cur = plist->prev;\n}\n\nvoid LClear(List *plist)\n{\n    while (LFirst(plist, NULL))\n        LRemove(plist);\n}\n\nvoid SetSortRule(List *plist, bool (*AreInIncreasingOrder)(LData *a, LData *b))\n{\n    plist->AreInIncreasingOrder = AreInIncreasingOrder;\n}\n```\n","path":"cs/data-structure/list/linked-list/without-tail/index.md"}