{"pathArr":[],"metaData":{"title":"꼬리가 있는 연결리스트 구현"},"content":"\n꼬리가 있으면 더미가 어떻게 붙을까?\n\n1. 머리 -> 더미 <- 꼬리\n1. 머리 -> 더미 -> 더미 <- 꼬리\n\n꼬리에 새로운 원소를 붙이려고 꼬리가 있는건데 꼬리에 더미가 있는건 의미가 없지않을까?! 1번 방식으로구현해보자.\n\n```{class=\"language-c\"}\nvoid ListInit(List *plist)\n{\n    plist->head = malloc(sizeof(Node));\n    plist->head->next = NULL;\n    plist->tail = plist->head;\n    plist->size = 0;\n    plist->AreInIncreasingOrder = NULL;\n}\n\nvoid LInsert(List *plist, LData data)\n{\n    Node *node = malloc(sizeof(Node));\n    node->data = data;\n    (plist->size)++;\n    if (plist->AreInIncreasingOrder)\n    {\n        Node *cur = plist->head;\n        while (cur->next && plist->AreInIncreasingOrder(&cur->next->data, &data))\n            cur = cur->next;\n        node->next = cur->next;\n        cur->next = node;\n        if (plist->tail->next)\n            plist->tail = plist->tail->next;\n    }\n    else\n    {\n        plist->tail->next = node;\n        plist->tail = node;\n    }\n}\n\nbool LFirst(List *plist, LData *data)\n{\n    if (!(plist->size))\n        return false;\n    plist->prev = plist->head;\n    plist->cur = plist->head->next;\n    if (data)\n        *data = plist->cur->data;\n    return true;\n}\n\nbool LNext(List *plist, LData *data)\n{\n    if (!(plist->cur->next))\n        return false;\n    plist->prev = plist->cur;\n    plist->cur = plist->cur->next;\n    if (data)\n        *data = plist->cur->data;\n    return true;\n}\n\nint LCount(List *plist) { return plist->size; }\n\nvoid LRemove(List *plist)\n{\n    (plist->size)--;\n    if (plist->cur == plist->tail)\n        plist->tail = plist->prev;\n    plist->prev->next = plist->cur->next;\n    free(plist->cur);\n    plist->cur = plist->prev;\n}\n\nvoid LClear(List *plist)\n{\n    while (LFirst(plist, NULL))\n        LRemove(plist);\n}\n\nvoid SetSortRule(List *plist, bool (*AreInIncreasingOrder)(LData *a, LData *b))\n{\n    plist->AreInIncreasingOrder = AreInIncreasingOrder;\n}\n```\n","path":"cs/data-structure/list/linked-list/with-tail/index.md"}