{"pathArr":[],"metaData":{"title":"이진 트리"},"content":"\n_영어 번역에 주의. 교재에서는 포화 이진 트리를 full binary tree로 번역하지만 위키피디아와 다른 자료에서 포화 이진 트리는 perfect binary tree이다._\n\n**이진 트리**\n\n> In computer science, a binary tree is a tree data structure in which each node has at most two children, which are referred to as the left child and the right child. A recursive definition using just set theory notions is that a (non-empty) binary tree is a tuple (L, S, R), where L and R are binary trees or the empty set and S is a singleton set containing the root. Some authors allow the binary tree to be the empty set as well.\n>\n> - Wikipedia\n\n## 이진 트리의 종류\n\n**정 이진 트리**\n\n> A full binary tree (sometimes referred to as a proper or plane binary tree) is a tree in which every node has either 0 or 2 children.\n\n**포화 이진 트리**\n\n> A perfect binary tree is a binary tree in which all interior nodes have two children and all leaves have the same depth or same level.\n\n**완전 이진 트리**\n\n> In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible\n\n## ADT\n\n```{class=\"language-c}\nBTreeNode *MakeBTreeNode(void);\n\nData GetData(BTreeNode *bt);\n\nvoid SetData(BTreeNode *bt, Data data);\n\nBTreeNode *GetLeftSubTree(BTreeNode *bt);\n\nBTreeNode *GetRightSubTree(BTreeNode *bt);\n\nvoid MakeLeftSubTree(BTreeNode *main, BTreeNode *sub);\n\nvoid MakeRightSubTree(BTreeNode *main, BTreeNode *sub);\n```\n\n## 순회(traverse)\n\n위 ADT를 구현하려면 서브트리의 모든 노드에 대해 free를 할 수 있어야 한다.\n\n루트 노드가 중간에 방문되면 중위(inorder), 마지막이면 후위(postorder), 처음이면전위(preorder).\n\n내가 처음에 구현한 이 방법보다는\n\n```{class=\"language-c\"}\nvoid InOrderTraverse(BTreeNode *main, void (*Transform)(Data))\n{\n    if (main->left)\n        InOrderTraverse(main->left, Transform);\n    Transform(main);\n    if (main->right)\n        InOrderTraverse(main->right, Transform);\n}\n```\n\n책의 이 방법이 나아보인다.\n\n```{class=\"language-c\"}\nvoid InOrderTraverse(BTreeNode *main, void (*Transform)(Data))\n{\n    if (!(main))\n        return;\n    InOrderTraverse(main->left, Transform);\n    Transform(main);\n    InOrderTraverse(main->right, Transform);\n}\n```\n\n## 구현\n\n연결 리스트처럼 자료 구조를 위한 구조체를 따로 선언할 필요는 없다. 루트 노드가곧트리이기 때문.\n\nvoid MakeLeftSubTree(BTreeNode *main, BTreeNode *sub)에서 free 잊지 말기!!! 세상에. 근데 free한거 그대로 쓰다가 에러난거 찾느라 한참 찾았다. 세상에.\n\n```{class=\"language-c\"}\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef int Data;\n\ntypedef struct _BTreeNode\n{\n    Data data;\n    struct _BTreeNode *left;\n    struct _BTreeNode *right;\n} BTreeNode;\n\nBTreeNode *MakeBTreeNode()\n{\n    BTreeNode *node = malloc(sizeof(BTreeNode));\n    node->left = NULL;\n    node->right = NULL;\n    return node;\n}\n\nData GetData(BTreeNode *bt)\n{\n    return bt->data;\n}\n\nvoid SetData(BTreeNode *bt, Data data)\n{\n    bt->data = data;\n}\n\nBTreeNode *GetLeftSubTree(BTreeNode *bt)\n{\n    return bt->left;\n}\n\nBTreeNode *GetRightSubTree(BTreeNode *bt)\n{\n    return bt->right;\n}\n\nvoid PostOrderTraverse(BTreeNode *main, void (*Transform)(BTreeNode *))\n{\n    if (!(main))\n        return;\n    PostOrderTraverse(main->left, Transform);\n    PostOrderTraverse(main->right, Transform);\n    Transform(main);\n}\n\nvoid FreeTreeNode(BTreeNode *main)\n{\n    printf(\"%d Deleted\\n\", main->data);\n    free(main);\n}\n\nvoid DeleteTree(BTreeNode *main)\n{\n    PostOrderTraverse(main, FreeTreeNode);\n}\n\nvoid MakeLeftSubTree(BTreeNode *main, BTreeNode *sub)\n{\n    main->left = sub;\n}\n\nvoid MakeRightSubTree(BTreeNode *main, BTreeNode *sub)\n{\n    main->right = sub;\n}\n\nvoid PrintContent(BTreeNode *node)\n{\n    printf(\"%d\", node->data);\n}\n\nint main()\n{\n\n    BTreeNode *bt1 = MakeBTreeNode();\n    BTreeNode *bt2 = MakeBTreeNode();\n    BTreeNode *bt3 = MakeBTreeNode();\n    BTreeNode *bt4 = MakeBTreeNode();\n\n    SetData(bt1, 1);\n    SetData(bt2, 2);\n    SetData(bt3, 3);\n    SetData(bt4, 4);\n\n    MakeLeftSubTree(bt1, bt2);\n    MakeRightSubTree(bt1, bt3);\n    MakeLeftSubTree(bt2, bt4);\n\n    PostOrderTraverse(bt1, PrintContent);\n\n    puts(\"\");\n\n    DeleteTree(bt1);\n\n    return 0;\n}\n```\n","path":"cs/data-structure/tree/binary_tree/index.md"}