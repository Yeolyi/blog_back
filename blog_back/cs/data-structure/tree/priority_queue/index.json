{"pathArr":[],"metaData":{"title":"우선순위 큐"},"content":"\n> In computer science, a priority queue is an abstract data-type similar to a regular queue or stack data structure in which each element additionally has a \"priority\" associated with it.\n\n## heap\n\n> In computer science, a heap is a specialized tree-based data structure which is essentially an almost complete tree that satisfies the heap property:\n\n**우선순위 큐와 힙의 관계**\n\n> While coders often implement priority queues with heaps, they are conceptually distinct from heaps. A priority queue is a concept like \"a list\" or \"a map\"; just as a list can be implemented with a linked list or with an array, a priority queue can be implemented with a heap or with a variety of other methods such as an unordered array.\n\n## ADT\n\n```{class=\"language-c\"}\nvoid PqueueInit(Pqueue *ppq, Comparator comp);\n\nbool PQIsEmpty(PQueue *ppq);\n\nvoid PEnqueue(PQueue *ppq, PQData data);\n\nPQData PDequeue(PQueue *ppq);\n// 데이터가 하나 이상 있음이 보장되어야 함.\n```\n\nvoid PqueueInit(Pqueue *ppq, Comparator *comp); 로 해도 잘 되네??\n\n## 힙을 이용한 구현\n\n_삭제 과정에서 굳이 swap을 할 필요는 없다. 하나만 대입연산하고 나머지는 마지막에만 해도 됨._\n\n책에서는 우선순위라고 표현하고 나는 comparator를 사용해서 헷갈렸다 ㅡㅡ 사용하는데이터 타입에 따라느낌이 달라질 수 있으니까 개념을 하나로 통일해서 코딩하자. comparator(a, b)를 a가 b보다 루트쪽에 있으면 true로 한다는 식,,, high priority라는건 값이 크다는게 아니라 우선순위 높으니까 먼저 나온다, 더루트쪽에 있다는 뜻이다. 하도 자연수로 테스트케이스 돌려서 까먹었다본데 우선순위 큐는 대소비교가 아니라우선순위 비교가 핵심이다!!!\n\n정렬함수 정의하는 것도 생각해보자. 책에서는 양수, 음수, 0으로 나눴지만 bool로도할 수 있지 않나??\n\n```{class=\"language-c\"}\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define HEAP_LEN 100\n\ntypedef char *Data;\ntypedef bool Comparator(Data d1, Data d2);\n\ntypedef struct _Heap\n{\n    int size;\n    Data arr[HEAP_LEN];\n    Comparator *comp;\n} Heap;\n\nvoid HeapInit(Heap *ph, Comparator comp)\n{\n    ph->size = 0;\n    ph->comp = comp;\n}\n\nbool HIsEmpty(Heap *ph)\n{\n    return !(ph->size);\n}\n\nint GetParentIdx(int idx)\n{\n    return idx / 2;\n}\n\nint GetLChildIdx(int idx)\n{\n    return idx * 2;\n}\n\nint GetRChildIdx(int idx)\n{\n    return idx * 2 + 1;\n}\n\nint GetHiPriorityChildIdx(Heap *ph, int idx)\n{\n    int lChildIdx = GetLChildIdx(idx);\n    int rChildIdx = GetRChildIdx(idx);\n    int size = ph->size;\n    if (lChildIdx > size)\n        return 0;\n    else if (lChildIdx == size)\n        return lChildIdx;\n    else\n    {\n        Data lChildVal = ph->arr[lChildIdx];\n        Data rChildVal = ph->arr[rChildIdx];\n        if (ph->comp(lChildVal, rChildVal))\n            return lChildIdx;\n        else\n            return rChildIdx;\n    }\n}\n\nvoid HInsert(Heap *ph, Data data)\n{\n    (ph->size)++;\n    int idx = ph->size;\n    while (idx != 1)\n    {\n        int parentIdx = GetParentIdx(idx);\n        Data parentVal = ph->arr[parentIdx];\n        if (ph->comp(data, parentVal))\n        {\n            ph->arr[idx] = ph->arr[parentIdx];\n            idx = parentIdx;\n        }\n        else\n            break;\n    }\n    ph->arr[idx] = data;\n}\n\nData HDelete(Heap *ph)\n{\n    int idx = 1;\n    Data ret = ph->arr[1];\n    Data movingVal = ph->arr[ph->size];\n    (ph->size)--;\n    int childIdx;\n    while ((childIdx = GetHiPriorityChildIdx(ph, idx)))\n    {\n        Data childVal = ph->arr[childIdx];\n        if (ph->comp(childVal, movingVal))\n        {\n            ph->arr[idx] = childVal;\n            idx = childIdx;\n        }\n        else\n            break;\n    }\n    ph->arr[idx] = movingVal;\n    return ret;\n}\n\nbool DataComp(char *d1, char *d2)\n{\n    int size1 = 0;\n    int size2 = 0;\n    while (d1[size1])\n        size1++;\n    while (d2[size2])\n        size2++;\n    return size1 > size2;\n}\n\nint main()\n{\n    Heap heap;\n    HeapInit(&heap, DataComp);\n    HInsert(&heap, \"one\");\n    HInsert(&heap, \"three\");\n    HInsert(&heap, \"two\");\n    HInsert(&heap, \"four\");\n    HInsert(&heap, \"five\");\n    HInsert(&heap, \"five\");\n    HInsert(&heap, \"eight\");\n    HInsert(&heap, \"eleven\");\n    HInsert(&heap, \"one hundred\");\n    while (!HIsEmpty(&heap))\n    {\n        printf(\"%s\\n\", HDelete(&heap));\n    }\n    return 0;\n}\n```\n\n[typedef로 함수 포인터 별칭 정의하기](https://dojang.io/mod/page/view.php?id=601)\n\n[pass function by value (?) instead of function pointer?](https://stackoverflow.com/questions/7111251/pass-function-by-value-instead-of-function-pointer)\n","path":"cs/data-structure/tree/priority_queue/index.md"}