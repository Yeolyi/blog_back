{"pathArr":[],"metaData":{"title":"프로세스"},"content":"\n## 프로세스의 개념\n\n위키피디아에 찾아보았다.\n\n> In computing, a process is the **instance** of a computer program that is being executed by one or many threads. It contains the program code and its activity. Depending on the operating system (OS), a process may be made up of multiple threads of execution that execute instructions concurrently.\n\n인스턴스는 여기서 뭐지?\n\n> In a computer system, any time a new context is created based on some model, it is said that the model has been instantiated. In practice, this instance usually has a data structure in common with other instances, but the values stored in the instances are separate. Changing the values in one instance will then not interfere with the values of some other instance. A compute instance can be software or hardware which can run code, for example a CPU, GPU or a virtual machine.\n\n실행중인 프로그램(Program in execution)을 프로세스라고 한다. 운영체제에서 작업의단위이다. 프로세스는그 일을 하기 위해 특정 자원(CPU time, 메모리, 파일, I/O 디바이스)들을 필요로 한다.\n\n하드 디스크에서 메모리로 로드돼서 CPU가 fetch해서 실행할 수 있는 상태의 프로그램을 프로세스라고 한다 .\n\n프로세스의 메모리 레이아웃은 다음과 같은 섹션들로 나뉜다.\n\n- Text section: 실행 가능한 코드\n- Data section: 전역 변수. uninitialized data와 initialized data가 분리되어있다.\n- Heap section: 런타임에 동적으로 할당된 메모리\n- Stack section: 함수 호출시의 임시 저장 공간. 함수 매개변수, 리턴 주소, 지역 변수 등.\n\n![](life_cycle.png)\n\n프로세스는 실행되는 과정에서 다섯가지의 state들을 가진다.\n\n- New: 프로세스 생성됨\n- Running: 명령어가 실행 중\n- Waiting: 특정 이벤트(I/O completion, reception of a signal)를 기다림\n- Ready: 프로세서에 맡겨지기를 기다림. Waiting에서 시그널 왔다고 바로 CPU 점유할수 있는게 아님.\n- Terminated: 실행이 끝남\n\n**PCB(Process Control Block)**이라는 구조체를 만들어서 프로세스를 관리. 프로세스에게 필요한 모든 정보들이 여기 담기고 handling된다. 프로그램 카운터와 레지스터를문맥, context라고 한다.\n\n- Process state\n- Program counter\n- CPU registers\n- CPU-scheduling information\n- Memory-management information\n- Accounting informaiton\n- I/O status information\n\n여기서 우리가 살펴본 프로세스는 single thread를 실행한다. 한 번에 한 작업밖에 못하니 multiprocessing(운영체제의 핵심 기능)을 위해서는 여러 쓰레드가 필요하다.\n\n따라서 lightweight process인 thread를 활용해 한 프로세스에서 여러개의 쓰레드를가지게 하고 한번에 여러 작업을 수행할 수 있도록 함. 이게 유리해서 대부분 multithreading 위주 병렬 처리, concurrency를 함.\n\n## 프로세스 스케줄링\n\nMultiprogramming의 목적은 항상 어떤 프로세스가 실행되고 있는 것. 아무튼 CPU 사용량을 늘리기 위해. 동시에 여러 프로세스를 실행시키는 것이라고 필기했었는데 이건좀애매한듯??\n\nAt the same time, simultaneously, concurrently 등등 같은 말들이 있지만 parallel 한 것과는 의미가 다름.\n\nTime sharing의 목적은 CPU를 프로세스간 빠르게 전환하여 각 프로그램들이 동시에 작동하는 것처럼 보이게하고 사용자가 여러 프로그램과 상호작용할 수 있게 하는 것. 이를 위해서는 CPU 스케줄링이 필요.\n\n**Scheduling Queue**. 프로세스가 시스템에 들어오면 ready queue에 추가되어 CPU core에서 실행되기를 기다린다. I/o관련된건 io 디바이스에 있는 ready queue에 가 있을 수도 있음. 특정 이벤트를 기다리는 것은 wait queue로 간다. 실제 구현은 PCB의연결 리스트.\n\nQueueing Diagram은 프로세스 스케줄링의 일반적인 표현이다.\n\n![](queueing_diagram.png)\n\n**Context Switch**. 문맥이란 프로세스가 사용되고 있는 상태를 말하며 PCB에 저장되어있음. Interrupt가일어나면 현재 프로세스의 문맥을 저장하고 나중에 resume될 떄다시 불러온다. Context switch란 CPU 코어를 다른 프로세스에게 넘겨주고 문맥 저장과 복원을 하는 일련의 과정.\n\n## Operations on Process\n\n운영체제는 프로세스 생성과 종료를 위한 mechanism을 제공해야 한다.\n\n![](linux_process.png)\n\n프로세스는 새로운 프로세스를 만들 수 있으며 이때 부모 프로세스와 자식 프로세스로나뉜다. 리눅스에서는 fork()라는 시스템 콜을 사용하며 리눅스 시스템 프로세스의 트리를 보면 첫번째 프로세스는 init으로 불리며 pid값은 1이다.\n\n두가지 실행 방법\n\n- Concurrent하게 동시에 실행\n- 부모가 자식의 종료까지 대기.\n\n두가지 주소 공간 처리? 방법\n\n- 자식이 부모 프로세스를 복제(혹은 pc만 바꿔서 할당 없이?)\n- 자식에게 별도의 프로그램이 로드\n\n마지막 문이 종료되면 프로세스도 종료. 혹은 exit() 시스템 콜. OS가 프로세스에 할당된 자원(할당된 메모리, 열린 파일들, I/O 버퍼)들을 돌려받음.\n\n[좀비 프로세스와 고아 프로세스](https://dongwooklee96.github.io/post/2021/04/03/좀비-프로세스와-고아-프로세스/)\n\nZombie: 이미 종료되었지만 부모가 wait()을 호출하지 않음. Orphan: wait 없이 부모가 종료됨. daemon, background 프로세스를 만들 때 활용.\n\n## 프로세스의 생성\n\nUNIX계열에서는 fork()로 새로운 프로세스를 만든다. 자식 프로세스는 부모 프로세스주소 공간의 복사를 가지게 된다. 두 프로세스 모두 fork() 이후의 명령어들을 실행하지만 자식 프로세스는 fork()의 반환값이 0 이며 부모 프로세스는 자식 프로세스의 0이아닌 pid값을 반환받는다.\n\nfork 이후에 부모는 계속 실행되거나 wait 콜로 자식이 끝나기를 기다릴 수 있다.\n\nwait 없이 실행했을 때 항상 parent가 먼저 실행될 보장은 없다. 동시에 실행되는 환경이 많은 문제를 일으키기 때문에 동기화를 잘 해줘야한다. 앞으로 배울 대부분의 문제가 여기서 발생한다.\n\n> The wait system-call puts the process to sleep and waits for a child-process to end. It then fills in the argument with the exit code of the child-process (if the argument is not NULL).\n\n```c\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\nint value = 5;\nint main()\n{\n    pid_t pid;\n    pid = fork();\n    if (pid == 0) // child process\n    {\n        value += 15;\n        printf(\"Child: pid = %d\\n\", getpid());\n        printf(\"Child: value = %d\\n\", value);\n        return 0;\n    }\n    else if (pid > 0) // parent process\n    {\n        wait(NULL);\n        printf(\"Parent: pid = %d\\n\", getpid());\n        printf(\"Parent: value = %d\\n\", value);\n    }\n}\n```\n\n```c\n#include <stdio.h>\n#include <unistd.h>\n\n// How many processes are created?\nint main()\n{\n    int i;\n    for (i = 0; i < 4; i++)\n        fork();\n    printf(\"Hello, world!\\n\");\n    return 0;\n}\n```\n\n```c\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\nint main()\n{\n    pid_t pid;\n    pid = fork();\n    if (pid == 0)\n    {\n        execlp(\"/bin/ls\", \"ls\", NULL);\n        printf(\"Another commands...\\n\"); // 실행 x\n    }\n    else if (pid > 0)\n    {\n        wait(NULL);\n        printf(\"Waiting Complete\");\n    }\n    return 0;\n}\n```\n\n## 프로세스간 통신(IPC)\n\n프로세스는 다른 프로세스간 데이터 공유 여부에 따라 independent/cooperating으로나뉨.\n\nCooperating하는 프로세스들은 **Inter-Process Communication** 매커니즘을 필요로한다. 이를 통해 데이터를 교환(send data, receive data)한다.\n\n![](communication_model.png)\n\n**IPC의 두 주요 모델**\n\n- Shared memory\n- Message passing: 운영체제에게 맡김. message queue가 있음.\n\n## Producer-Consumer Problem\n\n> In computing, the producer–consumer problem (also known as the bounded-buffer problem) is a classic example of a multi-process synchronization problem, the first version of which was proposed by Edsger W. Dijkstra in 1965 in his unpublished manuscript, in which the buffer was unbounded, and subsequently published with a bounded buffer in 1972.\n\n협동하는 프로세스들의 개념을 설명할 수 있다. 생산자는 정보를 생산하고 소비자는생산된 정보를 소비.\n\n## Shared-memory\n\n버퍼를 사용해 producer가 채우고 consumer가 가져간다. Bounded buffer를 shared memory로 만들면 된다. 각 프로세스의 영역에 접근하는건 보안상 안되고, 별개의 공유메모리 영역을 운영 체제가 할당해줘야한다. 하지만 알아서 잘 공유하는게 어렵다. 공유 메모리에 접근하고 조작하는 코드를 어플리케이션 프로그래머가알아서 짜야한다.\n\n## Message-passing\n\nshared memory의 관리를 os가 알아서 한다. send(message)와 receive(message) operation이 있다.\n\n(Prosumer간의 통신. 수백명이 동시에 한다면 message passing은 힘들고 shared memory가 사용됨.)\n\n**Communication Links**. P와 Q가 통신한다면 둘 사이의 링크가 있어야 한다. 아래의다양한 방식으로 구현될 수 있다.\n\n- Direct / Indirect\n- synchronous / asynchronous\n- automatinc / explicit\n\n**Direct**. 각 프로세스가 커뮤니케이션 상대를 알고 있다. send(P, messeage), receive(Q, message)와 같이 상대의 이름을 명시해야한다. 연결는 자동으로 생성되며정확히 두 프로세스만 연결한다. 각 프로세스 사이에는 단 하나의 연결만 존재한다.\n\n**Indirect**. 메시지가 mailbox, **port**로 보내지고 그곳에서 받아온다. 포트는 객체로 볼 수 있으며 프로세스에 의해 메시지가 배치되고 꺼내어질 수 있다. A가 메일박스라고 하면 send(A, message), receive(A, message)로 사용되어진다. 특정 대상이 있는 것이 아니라 메일함에 놓을 뿐. 두 멤버가 메일박스를 공유해야 연결이 성립하며메시지를 주고받을 수 있다. 두 개 이상의 프로세스간 연결이 성립될 수 있다. 각 프로세스 간 각각 하나의 메일박스와 대응되는 서로 다른 연결이 존재할 수 있다. OS는메일박스의 생성, 송수신 , 삭제의 기능을 제공한다.\n\n실제 구현에서는 **blocking**(sync), **non-blocking**(async)로도 나뉨. Blocking send에서는 메시지가잘수신될까지 sender가 block된다. 1기가짜리 버퍼에 4기가 영화를 보낸다고 하면 4기가 다 보내는 동안 sender는 다른 일을 못함. Blocking receive도 마찬가지로 메시지가 available할 때까지 아무것도 하지 않는다.\n\n## IPC 시스템의 예시\n\n- Shared Memory: POSIX Shared Memory. 여기서 POSIX란 Portable Operating System Interface (for UNIX).\n- Message Passing: Pipes. One of the earlist IPC mechanisms on UNIX systems.\n\n## POSIX Shared Memory\n\nmemory-mapped file로 버퍼를 잡는다. 여기서 버퍼란,\n\n> In computer science, a data buffer (or just buffer) is a region of a physical memory storage used to temporarily store data while it is being moved from one place to another.\n\n공유 메모리 영역을 파일과 연관짓는다고 한다. [메모리 매핑 참고](https://hololo-kumo.tistory.com/m/96)\n\n```c\n// Producer process illustrating POSIX shared-memory API\n// gcc test.c -lrt\n// maxOS는 lrt 필요없는듯~!\n\n#include <stdio.h>\n#include <unistd.h>   // ftruncate\n#include <sys/mman.h> // shm_open, mmap, PROT_READ\n#include <fcntl.h>    // O_CREAT\n#include <string.h>   // strlen\n\nint main()\n{\n    // the size of shared memory\n    const int SIZE = 4096;\n    // the name of shared memory\n    const char *name = \"OS\";\n    const char *message_0 = \"Hello, \";\n    const char *message_1 = \"Shared Memory!\\n\";\n\n    // the file descriptor of shared memory\n    int shm_fd;\n    // pointer to shared memory\n    char *ptr;\n\n    // create the shared memory object\n    shm_fd = shm_open(name, O_CREAT | O_RDWR, 0666);\n\n    // configure the size of the shared memory\n    ftruncate(shm_fd, SIZE);\n\n    // map the shared memory object\n    ptr = mmap(0, SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, 0);\n\n    // write to the shared memory\n    sprintf(ptr, \"%s\", message_0);\n    ptr += strlen(message_0);\n    sprintf(ptr, \"%s\", message_1);\n    ptr += strlen(message_1);\n\n    return 0;\n}\n```\n\n```c\n// Consumer process illustrating POSIX shared-memory API\n\n#include <stdio.h>\n#include <sys/mman.h>\n#include <fcntl.h>\n\nint main()\n{\n    const int SIZE = 4096;\n    const char *name = \"OS\";\n\n    int shm_fd;\n    char *ptr;\n\n    shm_fd = shm_open(name, O_RDONLY, 0666);\n    // 오 write 있으니까 안되네??\n    ptr = mmap(0, SIZE, PROT_READ, MAP_SHARED, shm_fd, 0);\n    printf(\"%s\", ptr);\n    shm_unlink(name);\n    return 0;\n}\n```\n\n## Pipe\n\n초기 유닉스에서 사용된 첫번째 IPC 매커니즘. 두 프로세스간 통신을 위한 전선의 역할을 한다. 공유메모리에서늬 shm read write close 과정이 부담스러워 사용.\n\n**파이프 구현의 네가지 핵심**\n\n- Unidirectional or Bidirectional\n- 양방향 통신이라면, half-duplex or full-duplex\n- 통신하는 프로세스 사이 부모-자식과 같은 관계가 있어야하는가\n- 네트워크를 지나 통신할 수 있는가(파이프 안쓰고 따로 소켓이라고 함)\n\nunidirection 한 것 두개를 만들면 양쪽 다 통신 가능하다. (그래서 굳이 bi로 안하고 uni로 한다는 뜻인가 ??)\n\n파이프는 구현의 편의상 부모자식관계를 가진다. **Ordinary pipe**는 파이프를 생성한 프로세스 밖에서는접근할 수 없다. 일반적으로 부모 프로세스가 자식과 소통하기위해 파이프를 만든다. Producer가 파이프의 write end에 쓰고 consumer가 read end에서 읽는다. Unidirectional하다. **Named pipe**는 부모 자식 관계가 없어도 접근할수있다.\n\n```c\n// Ordinary pipe in UNIX\n\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <string.h>\n\n#define BUFFER_SIZE 25\n#define READ_END 0\n#define WRITE_END 1\n\nint main()\n{\n    char parent_msg[BUFFER_SIZE] = \"Hi, child\";\n    char child_msg[BUFFER_SIZE] = \"Hi, parent\";\n    char read_msg[BUFFER_SIZE];\n    int fd[2];\n    pid_t pid;\n\n    // create the pipe\n    pipe(fd);\n\n    // fork a new process\n    pid = fork();\n    // parent process\n    if (pid > 0)\n    {\n        // wait(NULL); 이거 쓰면 안끝남!!\n        // write to the pipe\n        write(fd[WRITE_END], parent_msg, strlen(parent_msg) + 1);\n        read(fd[READ_END], read_msg, BUFFER_SIZE);\n        printf(\"parent read: %s\\n\", read_msg);\n        close(fd[WRITE_END]);\n        close(fd[READ_END]);\n    }\n    // child process\n    else if (pid == 0)\n    {\n        write(fd[WRITE_END], child_msg, strlen(child_msg) + 1);\n        // read to the pipe;\n        read(fd[READ_END], read_msg, BUFFER_SIZE);\n        printf(\"Child read %s\\n\", read_msg);\n        close(fd[READ_END]);\n        close(fd[WRITE_END]);\n    }\n    return 0;\n}\n```\n\n## 소켓\n\n**Sockets** are defined as endpoints for communication. **RPC** abstracts procedure calls between processes on networked systems.\n\n요즘엔 다들 인터넷에 연결되어있다. 다른 컴퓨터와도 프로세스간 통신해야해 소켓 등장. 파이프 대신 아이피 주소와 포트로 서로를 특정!\n\n하지만 서로 다른 시스템간 통신을 위해 엔디안, 크기 등등 다 지정해야돼서 **RPC**가 등장. Remote Procedure Calls. 네트워크 시스템간 프로세스간 프로시저 호출을 추상화함. 원격에 있는 함수를 호출.\n\n자바가 소켓관련 쉬운 인터페이스 제공함.\n\n- Socket class: TCP\n- DatagramSocket class: UDP\n- MulticastSocket class: multiple recipients\n\n```java\n// Date server in java\n\npackage dict.cs.os.process;\n\nimport java.io.*;\nimport java.net.*;\n\npublic class DateServer {\n\n  public static void main(String[] args) throws Exception {\n    ServerSocket server = new ServerSocket(6013);\n\n    // 서버 안닫았다고 warning떠서 내가 추가한 구문\n    Runtime\n      .getRuntime()\n      .addShutdownHook(\n        new Thread() {\n          public void run() {\n            try {\n              server.close();\n              System.out.println(\"The server is shut down!\");\n            } catch (IOException e) {\n              /* failed */\n            }\n          }\n        }\n      );\n\n    // now listen for connections\n    while (true) {\n      Socket client = server.accept();\n      PrintWriter pout = new PrintWriter(client.getOutputStream(), true);\n      // write the Dat to the socket\n      pout.println(new java.util.Date().toString());\n      // close the socket and resume listening for connections\n      System.out.println(\"Data send!\");\n      client.close();\n    }\n  }\n}\n```\n\n```java\npackage dict.cs.os.process;\n\nimport java.io.*;\nimport java.net.*;\n\npublic class DateClient {\n\n  public static void main(String[] args) throws Exception {\n    // make connection to server socket\n    Socket socket = new Socket(\"127.0.0.1\", 6013);\n\n    InputStream in = socket.getInputStream();\n    BufferedReader br = new BufferedReader(new InputStreamReader(in));\n\n    // read date from the socket\n    String line = null;\n    while ((line = br.readLine()) != null) System.out.println(line);\n\n    // close the socket connections\n    socket.close();\n  }\n}\n```\n\n## RPC(Remote Procedure Call)\n\n- one of the most common forms of remote service. IPC의 확장 개념.\n- Procedure-call 매커니즘을 추상화하기 위해 디자인되어 네트워크 연결된 시스템간사용할 수 있음.\n- 자바에서는 RMI\n- 클라이언트가 호스트의 프로시저를 invoke함.\n- stub을 클라이언트에게 제공해 서버에 뭐가 있는지 알아냄.\n- 근데 얘네도 엔디언 등등 알아내야해서 객체직렬화를 통해 stub을 보냄. marshal.\n- 서버의 stub은 이 메시지를 받아 마샬된 패러미터를 언팩하고 서버에서 procedure를수행함.\n- IDL\n\n얘는,,, 나중에 더 찾아봐야할듯.\n","path":"cs/os/process/index.md"}