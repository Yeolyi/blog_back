{"pathArr":[],"metaData":{"title":"동시성 제어의 고전적 문제들"},"content":"\n## Bounded-Buffer Problem\n\nProducer-Comsumer 문제에서 버퍼를 사용. 생산자는 버퍼를 채우고 소비자는 버퍼를비운다.\n\n이진 세마포어인 뮤텍스를 사용해서 버퍼 풀에 접근할 때 상호 배제를 보증한다. empty 세마포어는 n으로초기화되고 full 세마포어는 0으로 초기화된다.\n\n```java\n생산자 프로세스\n do {\n     ...\n     아이템을 생산한다.\n     ...\n     wait(empty);  //버퍼에 빈 공간이 생길 때까지 기다린다.\n     wait(mutex); //임계 구역에 진입할 수 있을 때까지 기다린다.\n     ...\n     아이템을 버퍼에 추가한다.\n     ...\n     signal(mutex); //임계 구역을 빠져나왔다고 알려준다.\n     signal(full);  //버퍼에 아이템이 있다고 알려준다.\n } while (1);\n\n소비자 프로세스\n  do {\n     wait(full);    //버퍼에 아이템이 생길 때까지 기다린다.\n     wait(mutex);\n     ...\n     버퍼로부터 아이템을 가져온다.\n     ...\n     signal(mutex);\n     signal(empty); //버퍼에 빈 공간이 생겼다고 알려준다.\n     ...\n     아이템을 소비한다.\n     ...\n } while (1);\n```\n\n> It is important to note here that though mutex seems to work as a semaphore with value of 1 (binary semaphore), but there is difference in the fact that mutex has ownership concept. **Ownership** means that mutex can only be \"incremented\" back (set to 1) by the same process that \"decremented\" it (set to 0), and all other tasks wait until mutex is available for decrement (effectively meaning that resource is available), which ensures mutual exclusivity and avoids deadlock. Thus using mutexes improperly can stall many processes when exclusive access is not required, but mutex is used instead of semaphore.\n\n[Bounded buffer, order of mutex vs empty. which comes first](https://stackoverflow.com/questions/23395545/bounded-buffer-order-of-mutex-vs-empty-which-comes-first) 왜 empty가 먼저일까? 버퍼가 가득 차있을 때 생산자 프로세스가 실행된다고 하자. 해당 프로세스는 mutex 를 얻고 버퍼에 빈 공간이 생기기를 기다린다. 하지만 mutex를 차지한 채로 기다리기 때문에 소비자 프로세스는 버퍼를 비울 수 없게된다.\n\n근데 이거 signal 순서도 맞아야 하나???\n\n서로 대칭 구조가 맞아야 한다. 요즘엔 이렇게 어려운건 안쓴다고 한다...\n\n## Readers-Writers Problem\n\n공유 데이터에 대해 누구는 읽기만 하고 누구는 읽고 쓰고 할 수 있다. ex. 여러 프로세스들에서 공유되는데이터베이스.\n\n그렇다면 두 개 이상의 reader가 동시에 접근한다고 문제가 발생하지는 않음. Reader 만 있는데 기다리게하면 성능에 좋지 않다. 반대로 writer는 동시에 접근하면 난리남 . writer + reader 조합도 마찬가지.\n\n**우선순위를 통한 분류**. 두 경우 모두 starvation 문제가 발생한다.\n\n- **first readers-writers problem**: readers-preference. Writer가 대기하고있다고 reader도 그 뒤에서대기하지 않는다.\n- **second readers-writers problem**: writers-preference. Writer가 대기하고 있으면 새로운 reader는읽지 못한다.\n\n## 구현\n\n두 개의 뮤텍스를 사용한다. rw_mutex는 reader writer 공통으로 사용되며 mutex는 read_count를 업데이트할 때 상호 배제를 위해 사용된다. read_count는 몇 개의 프로세스가 현재 객체를 읽고 있는지 기록한다.\n\n임계 영역에 writer가 있고 n명의 reader가 대기중이면 한 reader는 rw_mutex에 큐를잡고 n-1명의 reader는 mutex에 큐를 잡는다. 또한 writer가 signal(rw_mutex)를 하면 reader 전부나 한 명을 재개시킬 수 있다. 선택은 스케줄러의 몫. 여기서 스케줄러의선택에 따라 first와 second가 갈린다.\n\n아래는 readers-prefernce. 1차에 대한 구현. [참고](https://m.blog.naver.com/hirit808/221786966867)\n\n시간 나면 [위키](https://en.wikipedia.org/wiki/Readers%E2%80%93writers_problem)에서 구현들을 살펴보자.\n\n```c\n// Writer process\nwhile (true) {\n    wait (rw_mutex);\n    // perform writing\n    signal(rw_mutex);\n}\n\n// reader process\nwhile (true) {\n    wait(mutex);\n    read_count++;\n    if (read_count == 1)\n        wait(rw_mutex);\n    signal(mutex);\n\n    // perform read\n\n    wait(mutex);\n    read_count--;\n    if (read_count == 0)\n        signal(rw_mutex);\n    signal(mutex);\n}\n```\n\n사실 이 문제의 솔루션은 이미 일반화가 되어 **reader-writer lock**으로 제공된다. 락에 read와 write 모드가 있어 각각 필요한 것을 얻어야 하는 듯.\n\n## PThread solution to the Bounded_Buffer Problem\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <semaphore.h>\n#include <stdbool.h>\n\n#define BUFFER_SIZE 5\n\nint buffer[BUFFER_SIZE];\n\npthread_mutex_t mutex;\nsem_t *empty, *full;\n\nint in = 0, out = 0;\n\nvoid insert_item(int item)\n{\n    sem_wait(empty);\n    pthread_mutex_lock(&mutex);\n\n    buffer[in] = item;\n    in = (in + 1) % BUFFER_SIZE;\n    printf(\"Producer: inserted %d\\n\", item);\n\n    pthread_mutex_unlock(&mutex);\n    sem_post(full);\n}\n\nvoid remove_item(int *item)\n{\n    sem_wait(full);\n    pthread_mutex_lock(&mutex);\n\n    *item = buffer[out];\n    out = (out + 1) % BUFFER_SIZE;\n    printf(\"Consumer: removed %d\\n\", *item);\n\n    pthread_mutex_unlock(&mutex);\n    sem_post(empty);\n}\n\nvoid *producer()\n{\n    int item;\n    while (true)\n    {\n        usleep((1 + rand() % 5) * 100000);\n        item = 1000 + rand() % 1000;\n        insert_item(item); // critical section\n    }\n}\n\nvoid *consumer()\n{\n    int item;\n    while (true)\n    {\n        usleep((1 + rand() % 5) * 100000);\n        remove_item(&item); // critical section\n    }\n}\n\nint main()\n{\n    sem_unlink(\"empty\");\n    sem_unlink(\"full\");\n    int numOfProducers = 1, numOfConsumers = 1;\n    pthread_t pid;\n\n    pthread_mutex_init(&mutex, NULL);\n    empty = sem_open(\"empty\", O_CREAT | O_EXCL, 0, 5);\n    full = sem_open(\"full\", O_CREAT | O_EXCL, 0, 0);\n    //sem_init(empty, 0, 5);\n    //sem_init(full, 0, 0);\n    srand(time(0));\n\n    for (int i = 0; i < numOfProducers; i++)\n        pthread_create(&pid, NULL, producer, NULL);\n\n    for (int i = 0; i < numOfConsumers; i++)\n        pthread_create(&pid, NULL, consumer, NULL);\n\n    sleep(3);\n    return 0;\n}\n```\n\n뺄 것도 없는데 0으로 자꾸 나온건 mac에서 deprecated된 함수를 사용했기 때문. sem_wait가 -1이 반환됨. [링크](https://stackoverflow.com/questions/26797126/why-sem-wait-doesnt-wait-semaphore-on-mac-osx)\n\n## Java solution to the Bounded-Buffer Problem\n\n```java\npackage dict.cs.os.sync_examples;\n\npublic class BoundedBuffer {\n\n  public static void main(String[] args) throws InterruptedException {\n    CashBox cashBox = new CashBox(1);\n    Thread[] producers = new Thread[1];\n    Thread[] consumers = new Thread[1];\n    for (int i = 0; i < producers.length; i++) {\n      producers[i] = new Thread(new ProdRunner(cashBox));\n      producers[i].start();\n    }\n    for (int i = 0; i < consumers.length; i++) {\n      consumers[i] = new Thread(new ConsRunner(cashBox));\n      consumers[i].start();\n    }\n    Thread.sleep(3000);\n    for (int i = 0; i < producers.length; i++) {\n      producers[i].interrupt();\n    }\n    for (int i = 0; i < consumers.length; i++) {\n      consumers[i].interrupt();\n    }\n    return;\n  }\n}\n```\n\n```java\npackage dict.cs.os.sync_examples;\n\npublic class CashBox {\n\n  private int[] buffer;\n  private int count, in, out;\n\n  public CashBox(int bufferSize) {\n    buffer = new int[bufferSize];\n    count = in = out = 0;\n  }\n\n  public synchronized void give(int money) throws InterruptedException {\n    while (count == buffer.length) {\n      try {\n        wait();\n      } catch (InterruptedException e) {}\n    }\n    buffer[in] = money;\n    in = (in + 1) % buffer.length;\n    count++;\n    System.out.printf(\"Write %d\\n\", money);\n    notify();\n  }\n\n  public synchronized int take() throws InterruptedException {\n    while (count == 0) {\n      try {\n        wait();\n      } catch (InterruptedException e) {}\n    }\n    int money = buffer[out];\n    out = (out + 1) % buffer.length;\n    count--;\n    System.out.printf(\"Read %d\\n\", money);\n    notify();\n    return money;\n  }\n}\n```\n\n```java\npackage dict.cs.os.sync_examples;\n\npublic class ProdRunner implements Runnable {\n\n  CashBox cashBox;\n\n  public ProdRunner(CashBox cashBox) {\n    this.cashBox = cashBox;\n  }\n\n  @Override\n  public void run() {\n    try {\n      while (true) {\n        Thread.sleep((long) (Math.random() * 500));\n        int money = ((int) (1 + Math.random() * 9));\n        cashBox.give(money);\n      }\n    } catch (InterruptedException e) {}\n  }\n}\n```\n\n```java\npackage dict.cs.os.sync_examples;\n\npublic class ConsRunner implements Runnable {\n\n  CashBox cashBox;\n\n  public ConsRunner(CashBox cashBox) {\n    this.cashBox = cashBox;\n  }\n\n  @Override\n  public void run() {\n    try {\n      while (true) {\n        Thread.sleep((long) (Math.random() * 500));\n        cashBox.take();\n      }\n    } catch (InterruptedException e) {}\n  }\n}\n```\n\n## Java solution to the first Readers-Writers Problem\n\n```java\npackage dict.cs.os.sync_examples;\n\npublic class SharedDB {\n\n  private int readerCount = 0;\n  private boolean isWriting = false;\n\n  public void read() {\n    // read from the databas here\n  }\n\n  public void write() {\n    // write from the databas here\n  }\n\n  public synchronized void acquireReadLock() {\n    while (isWriting == true) {\n      try {\n        wait();\n      } catch (InterruptedException e) {}\n    }\n    readerCount++;\n  }\n\n  public synchronized void releaseReadLock() {\n    readerCount--;\n    if (readerCount == 0) notify();\n  }\n\n  public synchronized void acquireWriteLock() {\n    while (readerCount > 0 || isWriting == true) {\n      try {\n        wait();\n      } catch (InterruptedException e) {}\n    }\n    isWriting = true;\n  }\n\n  public synchronized void releaseWriteLock() {\n    isWriting = true;\n    notifyAll();\n  }\n}\n// sharedDB.acquireReadLock()\n// sharedDB.read()\n// sharedDB.releaseReadLock()\n// sharedDB.acquireWriteLock()\n// sharedDB.write())\n// sharedDB.releaseWriteLock()\n```\n\n## Dining-Philosophers Problem\n\n세마포어로 상호 배제는 간단하게 해결할 수 있다. 하지만 이 경우 모두가 왼쪽을 집으면 데드락이 발생한다.\n\n**데드락 해결법**\n\n- Allow at most four philosophers to be sitting simultaneously at the table?\n- 양쪽이 모두 가능할 때만 집게 하기.\n- 비대칭적인 해결책\n  - 홀수는 왼쪽 먼저 집고, 짝수는 오른쪽을 먼저 집기.\n  - 둘 중 하나는 무조건 밥을 먹을 수 있음.\n\n하지만 이 방법들은 기아까지 해결해주지는 못한다. 사실 데드락을 방지하는 비용은어마어마해서 발생하면해결하는 느낌으로 가는 중.\n\n**Moniter Solution**\n\n양쪽 젓가락이 가능할 때만 집자. 철학자들의 상태를 thinking, hungry, eating으로나눠보자. 철학자들은양쪽 이웃이 eating하지 않을때만 스스로의 상태를 eating으로바꿀 수 있다. Conditional variable은 hungry 할 때 대기하는 도구로 사용하자.\n\n> A **conditional variable** in operating system programming is a special kind of variable that is used to determine if a certain condition has been met or not. It is used to communicate between threads when certain conditions become true.\n>\n> A conditional variable is like a queue. A thread stops its execution and enters the queue if the specified condition is not met. Once another thread makes that condition true, it sends a signal to the leading thread in the queue to continue its execution.\n\nAtomic 변수와의 차이점.\n\n> The difference is that a condition variable doesn't consume CPU cycles while another thread is waiting for it. If you use an atomic variable for synchronization you have to keep checking its value in a loop.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <stdbool.h>\n\n#define NUM_PHILS 5\n\nenum\n{\n    THINKING,\n    HUNGRY,\n    EATING\n} state[NUM_PHILS];\n\npthread_mutex_t mutex_lock;\npthread_cond_t cond_vars[NUM_PHILS]; // 조건변수에 대한 접근은 항상 동기화된다\n\nvoid init()\n{\n    for (int i = 0; i < NUM_PHILS; i++)\n    {\n        state[i] = THINKING;\n        pthread_cond_init(&cond_vars[i], NULL);\n    }\n    pthread_mutex_init(&mutex_lock, NULL);\n    srand(time(0));\n}\n\nint leftOf(int i)\n{\n    return (i + NUM_PHILS - 1) % NUM_PHILS;\n}\n\nint rightOf(int i)\n{\n    return (i + 1) % NUM_PHILS;\n}\n\nvoid think(int id)\n{\n    printf(\"%d: THINKING\\n\", id);\n    usleep((1 + rand() % 50) * 10000);\n}\n\nvoid eat(int id)\n{\n    printf(\"%d: EATING\\n\", id);\n    usleep((1 + rand() % 50) * 10000);\n}\n\nvoid test(int i)\n{\n    if (state[i] == HUNGRY && state[leftOf(i)] != EATING && state[rightOf(i)] != EATING)\n    {\n        state[i] = EATING;\n        pthread_cond_signal(&cond_vars[i]);\n    }\n}\n\nvoid pickup(int i)\n{\n    pthread_mutex_lock(&mutex_lock);\n    // critical section\n    state[i] = HUNGRY;\n    test(i);\n    while (state[i] != EATING)\n        pthread_cond_wait(&cond_vars[i], &mutex_lock);\n    pthread_mutex_unlock(&mutex_lock);\n}\n\nvoid putdown(int i)\n{\n    pthread_mutex_lock(&mutex_lock);\n\n    state[i] = THINKING;\n    test(leftOf(i));\n    test(rightOf(i));\n\n    pthread_mutex_unlock(&mutex_lock);\n}\n\nvoid *philosopher(void *param)\n{\n    int id = *((int *)param);\n    printf(\"%d: CREATED\\n\", id);\n    for (int i = 0; i < 3; i++)\n    {\n        think(id);\n        pickup(id);\n        eat(id);\n        putdown(id);\n    }\n    pthread_exit(0);\n}\n\nint main()\n{\n    int ids[] = {0, 1, 2, 3, 4};\n    pthread_t tid[NUM_PHILS];\n    init();\n    for (int i = 0; i < NUM_PHILS; i++)\n        pthread_create(&tid[i], NULL, philosopher, (void *)&ids[i]);\n    for (int i = 0; i < NUM_PHILS; i++)\n        pthread_join(tid[i], NULL);\n    return 0;\n}\n```\n\npthread_create가 비동기적으로 되나?? id값을 따로 안빼주면 중복되고 난리도 아니네ㅠ\n\n## Thread-Safe한 동시성 어플리케이션\n\n동시성 어플리케이션은 멀티코어 시스템에서 좋은 성능을 보이지만 race condition이나 데드락과 같은 liveness hazard의 위험성이 있다.\n\nThread-safe한 개발을 위해 다양한 접근법이 있다.\n\n- Transational Memory: Transactional memory attempts to simplify concurrent programming by allowing a group of load and store instructions to execute in an atomic way.\n- OpenMP: 앞에서 써봄.\n- Functional Programming Language\n","path":"cs/os/sync_examples/index.md"}