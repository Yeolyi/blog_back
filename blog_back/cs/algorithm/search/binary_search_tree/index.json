{"pathArr":[],"metaData":{"title":"이진 탐색 트리"},"content":"\n> In computer science, a binary search tree (BST), also called an ordered or sorted binary tree, is a rooted binary tree data structure whose internal nodes each store a key greater than all the keys in the node’s left subtree and less than those in its right subtree.\n\n이중 포인터 쓰는 것 익숙해지기!\n\n아래처럼 바꾸기\n\n```{class=\"language-c\"}\nwhile (true)\n    {\n        if (!cur)\n            return NULL;\n        if (cur->data.key == key)\n            return cur;\n        if (cur->data.key > key)\n            cur = cur->left;\n        else\n            cur = cur->right;\n    }\n```\n\n```{class=\"language-c\"}\nwhile (!cur)\n    {\n        if (cur->data.key == key)\n            return cur;\n        if (cur->data.key > key)\n            cur = cur->left;\n        else\n            cur = cur->right;\n    }\n```\n\n이것도 첫 if문 필요 없음\n\n```c\nwhile (cur && (cur->data.key != key))\n    {\n        parent = cur;\n        if (cur->data.key == key)\n            break;\n        else if (cur->data.key < key)\n            cur = cur->right;\n        else\n            cur = cur->left;\n    }\n```\n\n## 구현\n\n이진 트리에서 함수 만들어놓고 왜 쓰지를 못하니,,,\n\n```{class=\"language-c\"}\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct _Color\n{\n    int key;\n    char *name;\n} Color;\n\ntypedef Color Data;\n\ntypedef struct _BTreeNode\n{\n    Data data;\n    struct _BTreeNode *left;\n    struct _BTreeNode *right;\n} BTreeNode;\n\nBTreeNode *MakeBTreeNode()\n{\n    BTreeNode *node = malloc(sizeof(BTreeNode));\n    node->left = NULL;\n    node->right = NULL;\n    return node;\n}\n\nData GetData(BTreeNode *bt)\n{\n    return bt->data;\n}\n\nvoid SetData(BTreeNode *bt, Data data)\n{\n    bt->data = data;\n}\n\nBTreeNode *GetLeftSubTree(BTreeNode *bt)\n{\n    return bt->left;\n}\n\nBTreeNode *GetRightSubTree(BTreeNode *bt)\n{\n    return bt->right;\n}\n\nvoid PostOrderTraverse(BTreeNode *main, void (*Transform)(BTreeNode *))\n{\n    if (!(main))\n        return;\n    PostOrderTraverse(main->left, Transform);\n    PostOrderTraverse(main->right, Transform);\n    Transform(main);\n}\n\nvoid FreeTreeNode(BTreeNode *main)\n{\n    free(main);\n}\n\nvoid DeleteTree(BTreeNode *main)\n{\n    PostOrderTraverse(main, FreeTreeNode);\n}\n\nvoid MakeLeftSubTree(BTreeNode *main, BTreeNode *sub)\n{\n    main->left = sub;\n}\n\nvoid MakeRightSubTree(BTreeNode *main, BTreeNode *sub)\n{\n    main->right = sub;\n}\n\nvoid BSTInit(BTreeNode **pRoot)\n{\n    *pRoot = NULL;\n}\n\nvoid BSTInsert(BTreeNode **pRoot, Data data)\n{\n    BTreeNode *cur = *pRoot;\n    BTreeNode *newNode = MakeBTreeNode();\n    newNode->data = data;\n\n    if (!cur)\n    {\n        *pRoot = MakeBTreeNode();\n        (*pRoot)->data = data;\n        return;\n    }\n    while (true)\n    {\n        if (data.key < cur->data.key)\n        {\n            if (cur->left)\n                cur = cur->left;\n            else\n            {\n                MakeLeftSubTree(cur, newNode);\n                return;\n            }\n        }\n        else\n        {\n            if (cur->right)\n                cur = cur->right;\n            else\n            {\n                MakeRightSubTree(cur, newNode);\n                return;\n            }\n        }\n    }\n}\n\n//NULL때문에 포인터 쓰는 것도 있는건가\nBTreeNode *BSTSearch(BTreeNode *cur, int key)\n{\n    while (true)\n    {\n        if (!cur)\n            return NULL;\n        if (cur->data.key == key)\n            return cur;\n        if (cur->data.key > key)\n            cur = cur->left;\n        else\n            cur = cur->right;\n    }\n}\n\nvoid InorderTraverse(BTreeNode *node)\n{\n    if (node->left)\n        InorderTraverse(node->left);\n    printf(\"%s\\n\", node->data.name);\n    if (node->right)\n        InorderTraverse(node->right);\n}\n\nvoid BSTRemove(BTreeNode **pRoot, int key)\n{\n    BTreeNode *tempNode = MakeBTreeNode();\n    BTreeNode *parent = tempNode;\n    BTreeNode *cur = *pRoot;\n\n    tempNode->right = *pRoot;\n\n    while (cur && (cur->data.key != key))\n    {\n        parent = cur;\n        if (cur->data.key < key)\n            cur = cur->right;\n        else\n            cur = cur->left;\n    }\n\n    if (!cur)\n        return;\n\n    if (cur->left && cur->right)\n    {\n        BTreeNode *altNode = cur->right;\n        BTreeNode *altNodeParent = cur;\n        while (altNode->left)\n        {\n            altNodeParent = altNode;\n            altNode = altNode->left;\n        }\n        cur->data = altNode->data;\n        if (altNodeParent->left == altNode)\n            altNodeParent->left = altNode->right;\n        else\n            altNodeParent->right = altNode->right;\n        free(altNode);\n    }\n    else if (cur->left || cur->right)\n    {\n        BTreeNode *curChild;\n        if (cur->left)\n            curChild = cur->left;\n        else\n            curChild = cur->right;\n        if (parent->left == cur)\n            parent->left = curChild;\n        else\n            parent->right = curChild;\n        free(cur);\n    }\n    else\n    {\n        if (parent->left == cur)\n            parent->left = NULL;\n        else\n            parent->right = NULL;\n        free(cur);\n    }\n    if (tempNode->right != *pRoot)\n        *pRoot = tempNode->right;\n    free(tempNode);\n    // free(cur); 애는 지우면 안되지,,,^^\n}\n\nint main()\n{\n    char *colorList[] = {\"Red\", \"Orange\", \"Yellow\", \"Green\", \"Blue\"};\n    int insertOrder[] = {3, 2, 0, 4, 1};\n    BTreeNode *bstRoot;\n    BSTInit(&bstRoot);\n    Data data;\n    for (int i = 0; i < 5; i++)\n    {\n        int order = insertOrder[i];\n        data.key = order;\n        data.name = colorList[order];\n        BSTInsert(&bstRoot, data);\n    }\n    BSTRemove(&bstRoot, 4);\n    InorderTraverse(bstRoot);\n    return 0;\n}\n```\n","path":"cs/algorithm/search/binary_search_tree/index.md"}